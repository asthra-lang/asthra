---
description:
globs:
alwaysApply: false
---
# Testing and Benchmarking Standards for Asthra

## Overview

This rule defines comprehensive testing and benchmarking standards for the Asthra programming language project. Given the project's complexity and performance requirements, rigorous testing is essential for maintaining code quality and ensuring reliable performance characteristics.

## Test Framework Architecture

### Core Test Framework (`test_framework.h`)

**USE** the established test framework for all testing:

```c
#include "test_framework.h"

// Basic test structure
TEST_CASE("descriptive_test_name") {
    // Setup phase
    AsthraResult result = {0};
    
    // Test execution
    result = function_under_test();
    
    // Assertions
    ASSERT_TRUE(result.success);
    ASSERT_EQ(result.error_code, ASTHRA_ERROR_NONE);
    ASSERT_NOT_NULL(result.data);
    
    // Cleanup phase
    cleanup_test_resources();
}

// Test suite organization
TEST_SUITE("component_name") {
    RUN_TEST(test_basic_functionality);
    RUN_TEST(test_error_conditions);
    RUN_TEST(test_edge_cases);
    RUN_TEST(test_performance_characteristics);
}
```

### Test Categories

**ORGANIZE** tests into these categories:

1. **Unit Tests**: Individual function/component testing
2. **Integration Tests**: Component interaction testing
3. **Performance Tests**: Benchmarking and performance validation
4. **Memory Tests**: Memory safety and leak detection
5. **Concurrency Tests**: Thread safety and race condition detection
6. **Cross-Platform Tests**: Platform-specific behavior validation

## Unit Testing Standards

### 1. Function-Level Testing

**EVERY** public function must have corresponding tests:

```c
// Test normal operation
TEST_CASE("slice_create_normal_operation") {
    const char *test_string = "Hello, World!";
    AsthraSlice slice = asthra_slice_from_string(test_string);
    
    ASSERT_NOT_NULL(slice.ptr);
    ASSERT_EQ(slice.len, 13);
    ASSERT_EQ(slice.element_size, sizeof(char));
    ASSERT_EQ(slice.ownership, ASTHRA_OWNERSHIP_BORROWED);
    ASSERT_FALSE(slice.is_mutable);
    
    // Verify content
    ASSERT_STREQ((char*)slice.ptr, test_string);
}

// Test error conditions
TEST_CASE("slice_create_null_input") {
    AsthraSlice slice = asthra_slice_from_string(NULL);
    
    ASSERT_NULL(slice.ptr);
    ASSERT_EQ(slice.len, 0);
    ASSERT_EQ(slice.element_size, 0);
}

// Test edge cases
TEST_CASE("slice_create_empty_string") {
    AsthraSlice slice = asthra_slice_from_string("");
    
    ASSERT_NOT_NULL(slice.ptr);
    ASSERT_EQ(slice.len, 0);
    ASSERT_EQ(slice.element_size, sizeof(char));
}
```

### 2. Error Path Testing

**ALWAYS** test error conditions and edge cases:

```c
TEST_CASE("memory_allocation_failure_handling") {
    // Simulate memory pressure
    size_t large_size = SIZE_MAX / 2;
    AsthraResult result = asthra_allocate_memory(large_size);
    
    ASSERT_FALSE(result.success);
    ASSERT_EQ(result.error_code, ASTHRA_ERROR_OUT_OF_MEMORY);
    ASSERT_NULL(result.data);
}

TEST_CASE("parser_invalid_syntax_handling") {
    const char *invalid_code = "let x = ;";  // Missing value
    AsthraParseResult result = asthra_parse_string(invalid_code);
    
    ASSERT_FALSE(result.success);
    ASSERT_EQ(result.error.type, ASTHRA_PARSE_ERROR_SYNTAX);
    ASSERT_NOT_NULL(result.error.message);
    ASSERT_GT(result.error.line, 0);
    ASSERT_GT(result.error.column, 0);
}
```

### 3. Boundary Testing

**TEST** boundary conditions and limits:

```c
TEST_CASE("slice_boundary_conditions") {
    // Test maximum size slice
    size_t max_elements = SIZE_MAX / sizeof(int);
    AsthraSlice slice = asthra_slice_create(sizeof(int), max_elements);
    
    if (slice.ptr != NULL) {  // May fail on memory-constrained systems
        ASSERT_EQ(slice.cap, max_elements);
        ASSERT_EQ(slice.element_size, sizeof(int));
        asthra_slice_destroy(&slice);
    }
    
    // Test zero-size slice
    AsthraSlice zero_slice = asthra_slice_create(sizeof(int), 0);
    ASSERT_EQ(zero_slice.len, 0);
    ASSERT_EQ(zero_slice.cap, 0);
}
```

## Integration Testing Standards

### 1. Component Interaction Testing

**VERIFY** that components work together correctly:

```c
TEST_CASE("parser_to_codegen_integration") {
    const char *source_code = "let x: i32 = 42;";
    
    // Parse source code
    AsthraParseResult parse_result = asthra_parse_string(source_code);
    ASSERT_TRUE(parse_result.success);
    ASSERT_NOT_NULL(parse_result.ast);
    
    // Generate code
    AsthraCodegenResult codegen_result = asthra_codegen_from_ast(parse_result.ast);
    ASSERT_TRUE(codegen_result.success);
    ASSERT_NOT_NULL(codegen_result.bytecode);
    
    // Verify generated code properties
    ASSERT_GT(codegen_result.bytecode_size, 0);
    
    // Cleanup
    asthra_ast_destroy(parse_result.ast);
    asthra_bytecode_destroy(codegen_result.bytecode);
}
```

### 2. Runtime Integration Testing

**TEST** runtime system integration:

```c
TEST_CASE("gc_integration_with_allocator") {
    // Allocate objects that should be GC-managed
    void *obj1 = asthra_gc_alloc(sizeof(AsthraObject));
    void *obj2 = asthra_gc_alloc(sizeof(AsthraObject));
    
    ASSERT_NOT_NULL(obj1);
    ASSERT_NOT_NULL(obj2);
    
    // Create references
    asthra_gc_add_root(obj1);
    asthra_gc_add_reference(obj1, obj2);
    
    // Force garbage collection
    size_t objects_before = asthra_gc_get_object_count();
    asthra_gc_collect();
    size_t objects_after = asthra_gc_get_object_count();
    
    // Verify GC behavior
    ASSERT_LE(objects_after, objects_before);
    
    // Cleanup
    asthra_gc_remove_root(obj1);
}
```

## Performance Testing Standards

### 1. Benchmark Framework Usage

**USE** the established benchmark framework:

```c
#include "test_benchmark_framework.h"

BENCHMARK("slice_creation_performance") {
    const size_t iterations = 100000;
    const size_t element_count = 1000;
    
    BENCHMARK_START();
    
    for (size_t i = 0; i < iterations; i++) {
        AsthraSlice slice = asthra_slice_create(sizeof(int), element_count);
        asthra_slice_destroy(&slice);
    }
    
    BENCHMARK_END();
    
    // Performance assertions
    ASSERT_BENCHMARK_TIME_LESS_THAN(1.0);  // Less than 1 second
    ASSERT_BENCHMARK_MEMORY_USAGE_STABLE(); // No memory leaks
}
```

### 2. Memory Performance Testing

**MONITOR** memory usage and allocation patterns:

```c
BENCHMARK("memory_allocation_efficiency") {
    const size_t allocation_count = 10000;
    void **allocations = malloc(allocation_count * sizeof(void*));
    
    BENCHMARK_START_MEMORY_TRACKING();
    
    // Allocation phase
    for (size_t i = 0; i < allocation_count; i++) {
        allocations[i] = asthra_gc_alloc(64);  // 64-byte allocations
    }
    
    // Deallocation phase (via GC)
    asthra_gc_collect();
    
    BENCHMARK_END_MEMORY_TRACKING();
    
    // Verify memory efficiency
    ASSERT_MEMORY_OVERHEAD_LESS_THAN(20);  // Less than 20% overhead
    ASSERT_NO_MEMORY_LEAKS();
    
    free(allocations);
}
```

### 3. Compilation Performance Testing

**MEASURE** compilation speed and efficiency:

```c
BENCHMARK("compilation_speed") {
    const char *large_source = generate_large_source_file(10000);  // 10k lines
    
    BENCHMARK_START();
    
    AsthraCompileResult result = asthra_compile_string(large_source);
    
    BENCHMARK_END();
    
    ASSERT_TRUE(result.success);
    ASSERT_BENCHMARK_TIME_LESS_THAN(5.0);  // Less than 5 seconds
    
    // Cleanup
    asthra_compile_result_destroy(&result);
    free((void*)large_source);
}
```

## Concurrency Testing Standards

### 1. Thread Safety Testing

**VERIFY** thread safety of concurrent operations:

```c
#include <pthread.h>

typedef struct {
    atomic_size_t counter;
    size_t iterations;
} ThreadTestData;

void* thread_increment_worker(void *arg) {
    ThreadTestData *data = (ThreadTestData*)arg;
    
    for (size_t i = 0; i < data->iterations; i++) {
        atomic_fetch_add_explicit(&data->counter, 1, memory_order_relaxed);
    }
    
    return NULL;
}

TEST_CASE("atomic_counter_thread_safety") {
    const size_t thread_count = 8;
    const size_t iterations_per_thread = 10000;
    
    ThreadTestData data = {
        .counter = ATOMIC_VAR_INIT(0),
        .iterations = iterations_per_thread
    };
    
    pthread_t threads[thread_count];
    
    // Start threads
    for (size_t i = 0; i < thread_count; i++) {
        int result = pthread_create(&threads[i], NULL, thread_increment_worker, &data);
        ASSERT_EQ(result, 0);
    }
    
    // Wait for completion
    for (size_t i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // Verify final count
    size_t expected = thread_count * iterations_per_thread;
    size_t actual = atomic_load(&data.counter);
    ASSERT_EQ(actual, expected);
}
```

### 2. Race Condition Detection

**USE** ThreadSanitizer for race condition detection:

```bash
# Build with ThreadSanitizer
make benchmark-tsan

# Run specific concurrency tests
./bin/test_concurrency_bridge
```

## Memory Safety Testing

### 1. Memory Leak Detection

**USE** Valgrind and AddressSanitizer:

```bash
# Valgrind testing
make benchmark-valgrind

# AddressSanitizer testing
make benchmark-asan
```

### 2. Bounds Checking

**VERIFY** memory bounds are respected:

```c
TEST_CASE("slice_bounds_checking") {
    AsthraSlice slice = asthra_slice_create(sizeof(int), 10);
    ASSERT_NOT_NULL(slice.ptr);
    
    // Valid access
    AsthraResult result = asthra_slice_set_element(&slice, 5, &(int){42});
    ASSERT_TRUE(result.success);
    
    // Invalid access (out of bounds)
    result = asthra_slice_set_element(&slice, 15, &(int){42});
    ASSERT_FALSE(result.success);
    ASSERT_EQ(result.error_code, ASTHRA_ERROR_INDEX_OUT_OF_BOUNDS);
    
    asthra_slice_destroy(&slice);
}
```

## Cross-Platform Testing

### 1. Platform-Specific Behavior

**TEST** platform differences explicitly:

```c
TEST_CASE("platform_specific_path_handling") {
#ifdef _WIN32
    const char *expected_separator = "\\";
    const char *test_path = "src\\main.c";
#else
    const char *expected_separator = "/";
    const char *test_path = "src/main.c";
#endif
    
    char normalized_path[256];
    AsthraResult result = asthra_normalize_path(test_path, normalized_path, sizeof(normalized_path));
    
    ASSERT_TRUE(result.success);
    ASSERT_STRCONTAINS(normalized_path, expected_separator);
}
```

### 2. Compiler-Specific Testing

**VERIFY** behavior across different compilers:

```c
TEST_CASE("c17_feature_availability") {
    // Test static assertions
    _Static_assert(sizeof(int) >= 4, "int must be at least 32 bits");
    
    // Test generic selections
    int test_int = 42;
    double test_double = 3.14;
    
    ASSERT_EQ(TYPE_SIZE(test_int), sizeof(int));
    ASSERT_EQ(TYPE_SIZE(test_double), sizeof(double));
    
    // Test atomic operations
    atomic_int atomic_counter = ATOMIC_VAR_INIT(0);
    atomic_fetch_add(&atomic_counter, 1);
    ASSERT_EQ(atomic_load(&atomic_counter), 1);
}
```

## Test Execution Guidelines

### 1. Pre-Commit Testing

**ALWAYS** run before committing changes:

```bash
# Full test suite
make clean && make test

# Performance regression testing
make test-benchmark

# Memory safety testing
make benchmark-asan

# Static analysis
make analyze
```

### 2. Continuous Integration Testing

**ENSURE** CI pipeline covers:

- Multiple platforms (macOS, Linux, Windows)
- Multiple compilers (GCC, Clang, MSVC)
- Debug and release builds
- Memory safety tools
- Performance benchmarks

### 3. Test Result Analysis

**ANALYZE** test results systematically:

```bash
# Generate test report
make test > test_results.txt 2>&1

# Check for failures
grep -i "failed\|error" test_results.txt

# Performance analysis
make benchmark | grep "Performance:"
```

## Test Maintenance

### 1. Test Code Quality

**MAINTAIN** high-quality test code:

- Clear, descriptive test names
- Comprehensive setup and cleanup
- Meaningful assertions with good error messages
- Proper resource management
- Documentation for complex test scenarios

### 2. Test Data Management

**ORGANIZE** test data effectively:

```c
// Use const data for immutable test inputs
static const char* const VALID_EXPRESSIONS[] = {
    "42",
    "x + y",
    "func(a, b, c)",
    NULL  // Sentinel
};

// Use helper functions for complex setup
static AsthraAST* create_test_ast(void) {
    AsthraAST *ast = asthra_ast_create();
    // ... setup logic
    return ast;
}
```

### 3. Test Documentation

**DOCUMENT** test purposes and expectations:

```c
/**
 * Test: slice_resize_performance
 * Purpose: Verify that slice resizing operations maintain O(1) amortized complexity
 * Expected: Resizing 100,000 elements should complete in under 100ms
 * Platform: All supported platforms
 * Dependencies: asthra_slice_resize, high-resolution timer
 */
BENCHMARK("slice_resize_performance") {
    // Test implementation
}
```

## Success Criteria

### 1. Coverage Metrics

**ACHIEVE** comprehensive test coverage:

- 100% of public API functions tested
- 90%+ line coverage for core components
- All error paths tested
- All platform-specific code paths tested

### 2. Performance Benchmarks

**MAINTAIN** performance standards:

- Compilation speed within 25% of baseline
- Runtime performance improvements preserved
- Memory usage optimizations maintained
- No performance regressions in CI

### 3. Quality Metrics

**ENSURE** high code quality:

- Zero memory leaks in Valgrind testing
- Zero race conditions in ThreadSanitizer testing
- All static analysis warnings addressed
- 100% test pass rate across all platforms

---

**Remember**: Testing is not just about finding bugs—it's about ensuring the reliability, performance, and maintainability of the Asthra programming language for its users.
