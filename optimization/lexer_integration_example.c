/**
 * Asthra Programming Language Compiler
 * Lexer Integration Example with Perfect Hash Keyword Lookup
 * 
 * This file demonstrates how to integrate the Gperf-generated perfect hash
 * function into the existing lexer for optimal keyword lookup performance.
 * 
 * Copyright (c) 2024 Asthra Project
 * Licensed under the terms specified in LICENSE
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

// Include the generated perfect hash header
// This would be: #include "asthra_keywords_hash.h"
// For this example, we'll define the interface

// Mock interface for the generated perfect hash functions
struct keyword_entry {
    const char *name;
    int token_type;
};

// These functions would be generated by Gperf
extern unsigned int asthra_keyword_hash(const char *str, size_t len);
extern const struct keyword_entry *asthra_keyword_lookup(const char *str, size_t len);
extern int asthra_keyword_get_token_type(const char *str, size_t len);
extern int asthra_keyword_is_keyword(const char *str, size_t len);

// Token types (subset for example)
typedef enum {
    TOKEN_IDENTIFIER = 0,
    TOKEN_PACKAGE = 1,
    TOKEN_IMPORT = 2,
    TOKEN_FN = 3,
    TOKEN_STRUCT = 4,
    TOKEN_LET = 5,
    TOKEN_IF = 6,
    TOKEN_ELSE = 7,
    TOKEN_FOR = 8,
    TOKEN_RETURN = 9,
    TOKEN_TRUE = 10,
    TOKEN_FALSE = 11,
    // ... other tokens
} TokenType;

// =============================================================================
// ENHANCED KEYWORD LOOKUP WITH PERFECT HASH
// =============================================================================

/**
 * Enhanced keyword lookup using perfect hash function
 * 
 * This replaces the original linear search keyword_lookup() function
 * with a perfect hash-based implementation for O(1) lookup time.
 * 
 * @param identifier The identifier string to look up
 * @param length The length of the identifier
 * @return The token type if it's a keyword, TOKEN_IDENTIFIER otherwise
 */
TokenType keyword_lookup_enhanced(const char *identifier, size_t length) {
    // Use the generated perfect hash function
    int token_type = asthra_keyword_get_token_type(identifier, length);
    
    // Return the token type if found, otherwise it's an identifier
    return (token_type != -1) ? (TokenType)token_type : TOKEN_IDENTIFIER;
}

/**
 * Check if a string is a reserved keyword
 * 
 * @param identifier The identifier string to check
 * @param length The length of the identifier
 * @return true if it's a keyword, false otherwise
 */
bool is_reserved_keyword_enhanced(const char *identifier, size_t length) {
    return asthra_keyword_is_keyword(identifier, length) != 0;
}

/**
 * Get keyword information including hash value (for debugging)
 * 
 * @param identifier The identifier string
 * @param length The length of the identifier
 * @param hash_value Pointer to store the hash value (can be NULL)
 * @return The keyword entry if found, NULL otherwise
 */
const struct keyword_entry *keyword_lookup_debug(const char *identifier, size_t length, unsigned int *hash_value) {
    if (hash_value) {
        *hash_value = asthra_keyword_hash(identifier, length);
    }
    return asthra_keyword_lookup(identifier, length);
}

// =============================================================================
// INTEGRATION EXAMPLE FOR LEXER
// =============================================================================

/**
 * Example of how to integrate the perfect hash into the existing lexer
 * 
 * This shows the minimal changes needed to the scan_identifier function
 * to use the perfect hash instead of linear search.
 */

// Mock token structure for example
typedef struct {
    TokenType type;
    char *value;
    size_t length;
} Token;

/**
 * Enhanced scan_identifier function using perfect hash
 * 
 * This is an example of how the existing scan_identifier function
 * would be modified to use the perfect hash lookup.
 */
Token scan_identifier_enhanced(const char *source, size_t *position) {
    Token token = {0};
    size_t start = *position;
    size_t length = 0;
    
    // Scan the identifier (simplified for example)
    while (source[*position] && (isalnum(source[*position]) || source[*position] == '_')) {
        (*position)++;
        length++;
    }
    
    // Allocate and copy the identifier
    token.value = malloc(length + 1);
    strncpy(token.value, source + start, length);
    token.value[length] = '\0';
    token.length = length;
    
    // Use perfect hash for keyword lookup
    token.type = keyword_lookup_enhanced(token.value, length);
    
    return token;
}

// =============================================================================
// PERFORMANCE COMPARISON FUNCTIONS
// =============================================================================

/**
 * Original linear search implementation (for comparison)
 */
typedef struct {
    const char *keyword;
    TokenType token_type;
} KeywordEntry;

static const KeywordEntry original_keywords[] = {
    {"package", TOKEN_PACKAGE},
    {"import", TOKEN_IMPORT},
    {"fn", TOKEN_FN},
    {"struct", TOKEN_STRUCT},
    {"let", TOKEN_LET},
    {"if", TOKEN_IF},
    {"else", TOKEN_ELSE},
    {"for", TOKEN_FOR},
    {"return", TOKEN_RETURN},
    {"true", TOKEN_TRUE},
    {"false", TOKEN_FALSE},
    // ... more keywords would be here
};

static const size_t original_keyword_count = sizeof(original_keywords) / sizeof(KeywordEntry);

TokenType keyword_lookup_original(const char *identifier, size_t length) {
    for (size_t i = 0; i < original_keyword_count; i++) {
        if (strlen(original_keywords[i].keyword) == length &&
            strncmp(original_keywords[i].keyword, identifier, length) == 0) {
            return original_keywords[i].token_type;
        }
    }
    return TOKEN_IDENTIFIER;
}

// =============================================================================
// INTEGRATION TESTING AND VALIDATION
// =============================================================================

/**
 * Test function to validate the perfect hash integration
 */
void test_keyword_lookup_integration(void) {
    printf("=== Keyword Lookup Integration Test ===\n\n");
    
    const char *test_keywords[] = {
        "package", "import", "fn", "struct", "let", "if", "else", "for", "return", "true", "false"
    };
    const size_t num_test_keywords = sizeof(test_keywords) / sizeof(test_keywords[0]);
    
    const char *test_identifiers[] = {
        "variable", "function_name", "my_struct", "hello_world"
    };
    const size_t num_test_identifiers = sizeof(test_identifiers) / sizeof(test_identifiers[0]);
    
    printf("Testing keyword recognition:\n");
    for (size_t i = 0; i < num_test_keywords; i++) {
        const char *keyword = test_keywords[i];
        size_t length = strlen(keyword);
        
        TokenType original_result = keyword_lookup_original(keyword, length);
        TokenType enhanced_result = keyword_lookup_enhanced(keyword, length);
        
        printf("  '%s': original=%d, enhanced=%d %s\n", 
               keyword, original_result, enhanced_result,
               (original_result == enhanced_result) ? "✓" : "✗");
    }
    
    printf("\nTesting identifier recognition:\n");
    for (size_t i = 0; i < num_test_identifiers; i++) {
        const char *identifier = test_identifiers[i];
        size_t length = strlen(identifier);
        
        TokenType original_result = keyword_lookup_original(identifier, length);
        TokenType enhanced_result = keyword_lookup_enhanced(identifier, length);
        
        printf("  '%s': original=%d, enhanced=%d %s\n", 
               identifier, original_result, enhanced_result,
               (original_result == enhanced_result) ? "✓" : "✗");
    }
}

/**
 * Performance comparison between original and enhanced lookup
 */
void benchmark_keyword_lookup_integration(void) {
    printf("\n=== Keyword Lookup Performance Benchmark ===\n\n");
    
    const char *test_words[] = {
        "package", "import", "fn", "struct", "let", "if", "else", "for",
        "return", "true", "false", "variable", "function", "identifier"
    };
    const size_t num_words = sizeof(test_words) / sizeof(test_words[0]);
    const int iterations = 1000000;
    
    printf("Running %d iterations with %d test words...\n\n", iterations, num_words);
    
    // Benchmark original implementation
    clock_t start = clock();
    volatile int result_original = 0;
    for (int i = 0; i < iterations; i++) {
        for (size_t j = 0; j < num_words; j++) {
            result_original += keyword_lookup_original(test_words[j], strlen(test_words[j]));
        }
    }
    clock_t end = clock();
    double time_original = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    // Benchmark enhanced implementation
    start = clock();
    volatile int result_enhanced = 0;
    for (int i = 0; i < iterations; i++) {
        for (size_t j = 0; j < num_words; j++) {
            result_enhanced += keyword_lookup_enhanced(test_words[j], strlen(test_words[j]));
        }
    }
    end = clock();
    double time_enhanced = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    printf("Results:\n");
    printf("  Original (linear search): %.6f seconds\n", time_original);
    printf("  Enhanced (perfect hash):  %.6f seconds\n", time_enhanced);
    printf("  Speedup: %.2fx\n", time_original / time_enhanced);
    printf("  Original: %.2f ns per lookup\n", (time_original * 1000000000.0) / (iterations * num_words));
    printf("  Enhanced: %.2f ns per lookup\n", (time_enhanced * 1000000000.0) / (iterations * num_words));
    printf("  Verification: %s\n", (result_original == result_enhanced) ? "PASS" : "FAIL");
}

// =============================================================================
// INTEGRATION INSTRUCTIONS
// =============================================================================

/**
 * Print integration instructions for developers
 */
void print_integration_instructions(void) {
    printf("\n=== Integration Instructions ===\n\n");
    
    printf("To integrate the perfect hash into your lexer:\n\n");
    
    printf("1. Include the generated header:\n");
    printf("   #include \"optimization/asthra_keywords_hash.h\"\n\n");
    
    printf("2. Replace the keyword_lookup function in lexer.c:\n");
    printf("   TokenType keyword_lookup(const char *identifier, size_t length) {\n");
    printf("       int token_type = asthra_keyword_get_token_type(identifier, length);\n");
    printf("       return (token_type != -1) ? (TokenType)token_type : TOKEN_IDENTIFIER;\n");
    printf("   }\n\n");
    
    printf("3. Replace the is_reserved_keyword function:\n");
    printf("   bool is_reserved_keyword(const char *identifier, size_t length) {\n");
    printf("       return asthra_keyword_is_keyword(identifier, length) != 0;\n");
    printf("   }\n\n");
    
    printf("4. Add the perfect hash object to your build:\n");
    printf("   - Link with: build/optimization/asthra_keywords_hash.o\n");
    printf("   - Or add to COMPILER_OBJECTS in Makefile\n\n");
    
    printf("5. Update dependencies in Makefile:\n");
    printf("   $(ASTHRA_COMPILER): $(COMPILER_OBJECTS) $(GPERF_OBJECT) $(ASTHRA_RUNTIME_LIB)\n\n");
    
    printf("6. Test the integration:\n");
    printf("   make gperf-test\n");
    printf("   make gperf-benchmark\n\n");
    
    printf("Benefits:\n");
    printf("  - O(1) keyword lookup time vs O(n) linear search\n");
    printf("  - Typically 2-5x faster keyword recognition\n");
    printf("  - Minimal memory overhead\n");
    printf("  - Automatic regeneration when keywords change\n");
}

// =============================================================================
// MAIN FUNCTION FOR TESTING
// =============================================================================

int main(void) {
    printf("Asthra Lexer Perfect Hash Integration Example\n");
    printf("=============================================\n\n");
    
    // Note: In a real integration, these functions would be linked
    // from the generated asthra_keywords_hash.c file
    printf("Note: This example shows the integration pattern.\n");
    printf("The actual perfect hash functions are generated by Gperf.\n");
    printf("Run 'make gperf-keywords' to generate the real implementation.\n\n");
    
    // Show integration instructions
    print_integration_instructions();
    
    // In a real scenario with the generated functions, you would run:
    // test_keyword_lookup_integration();
    // benchmark_keyword_lookup_integration();
    
    return 0;
} 
