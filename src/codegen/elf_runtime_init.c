/**
 * Asthra Programming Language Compiler
 * ELF Runtime Initialization
 * 
 * Copyright (c) 2024 Asthra Project
 * Licensed under the terms specified in LICENSE
 * 
 * Functions for generating runtime initialization code.
 */

#include "elf_writer.h"
#include "elf_writer_core.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// Runtime initialization function template
static const char ASTHRA_INIT_TEMPLATE[] = 
    "; Asthra Runtime Initialization Function\n"
    "; Generated by ELF Writer\n"
    "\n"
    "global _Asthra_init\n"
    "extern asthra_gc_init\n"
    "extern asthra_scheduler_init\n"
    "extern asthra_pattern_engine_init\n"
    "extern asthra_string_ops_init\n"
    "extern asthra_ffi_init\n"
    "\n"
    "section .text\n"
    "_Asthra_init:\n"
    "    ; Function prologue\n"
    "    push rbp\n"
    "    mov rbp, rsp\n"
    "    sub rsp, 32         ; Allocate stack space\n"
    "\n"
    "    ; Initialize garbage collector\n"
    "    call asthra_gc_init\n"
    "    test rax, rax\n"
    "    jz .init_error\n"
    "\n"
    "    ; Initialize task scheduler\n"
    "    call asthra_scheduler_init\n"
    "    test rax, rax\n"
    "    jz .init_error\n"
    "\n"
    "    ; Initialize pattern matching engine\n"
    "    call asthra_pattern_engine_init\n"
    "    test rax, rax\n"
    "    jz .init_error\n"
    "\n"
    "    ; Initialize string operations\n"
    "    call asthra_string_ops_init\n"
    "    test rax, rax\n"
    "    jz .init_error\n"
    "\n"
    "    ; Initialize FFI subsystem\n"
    "    call asthra_ffi_init\n"
    "    test rax, rax\n"
    "    jz .init_error\n"
    "\n"
    "    ; Success - return 1\n"
    "    mov rax, 1\n"
    "    jmp .init_done\n"
    "\n"
    ".init_error:\n"
    "    ; Error - return 0\n"
    "    mov rax, 0\n"
    "\n"
    ".init_done:\n"
    "    ; Function epilogue\n"
    "    add rsp, 32\n"
    "    pop rbp\n"
    "    ret\n"
    "\n";

// =============================================================================
// RUNTIME INITIALIZATION
// =============================================================================

bool elf_generate_runtime_init(ELFWriter *writer) {
    if (!writer) return false;
    
    // Skip runtime initialization for now - it's adding assembly text to .text section
    // which corrupts the ELF file. The actual machine code generation needs to be
    // implemented properly.
    return true;
}

bool elf_add_runtime_init_metadata(ELFWriter *writer) {
    if (!writer) return false;
    
    // Create .Asthra.runtime_init section if it doesn't exist
    ELFSection *runtime_section = elf_find_section_by_name(writer, ".Asthra.runtime_init");
    if (!runtime_section) {
        runtime_section = elf_add_section(writer, ".Asthra.runtime_init", SHT_PROGBITS, 0);
        if (!runtime_section) return false;
        runtime_section->asthra_type = ASTHRA_SECTION_RUNTIME_INIT;
        runtime_section->is_asthra_section = true;
        runtime_section->alignment = 8;
    }
    
    // Runtime initialization metadata structure
    struct {
        uint32_t magic;
        uint32_t version;
        uint32_t init_function_count;
        uint32_t dependency_count;
        
        struct {
            char name[64];
            uint64_t address;
            uint32_t priority;
            uint32_t required;
        } init_functions[8];
        
        struct {
            char name[64];
            uint32_t version_required;
            uint32_t optional;
        } dependencies[16];
    } runtime_metadata = {0};
    
    // Fill in metadata
    runtime_metadata.magic = 0x41494E49; // "AINI"
    runtime_metadata.version = ASTHRA_METADATA_VERSION;
    runtime_metadata.init_function_count = 5;
    runtime_metadata.dependency_count = 3;
    
    // Initialize function metadata
    const char *init_functions[] = {
        "asthra_gc_init",
        "asthra_scheduler_init", 
        "asthra_pattern_engine_init",
        "asthra_string_ops_init",
        "asthra_ffi_init"
    };
    
    for (int i = 0; i < 5; i++) {
        strncpy(runtime_metadata.init_functions[i].name, init_functions[i], 63);
        runtime_metadata.init_functions[i].address = 0; // Filled by linker
        runtime_metadata.init_functions[i].priority = i; // Initialization order
        runtime_metadata.init_functions[i].required = 1; // All required
    }
    
    // Dependency metadata
    const char *dependencies[][2] = {
        {"libc", "2.17"},
        {"libpthread", "2.17"},
        {"libm", "2.17"}
    };
    
    for (int i = 0; i < 3; i++) {
        strncpy(runtime_metadata.dependencies[i].name, dependencies[i][0], 63);
        runtime_metadata.dependencies[i].version_required = 0x00020017; // 2.17
        runtime_metadata.dependencies[i].optional = 0; // All required
    }
    
    // Write metadata to section
    size_t metadata_size = sizeof(runtime_metadata);
    if (!elf_expand_section_data(runtime_section, metadata_size)) {
        return false;
    }
    
    memcpy(runtime_section->data, &runtime_metadata, metadata_size);
    runtime_section->data_size = metadata_size;
    
    return true;
} 
