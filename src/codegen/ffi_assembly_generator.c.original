/**
 * Asthra Programming Language Compiler
 * FFI-Compatible Assembly Generator Implementation v1.2
 * 
 * Copyright (c) 2024 Asthra Project
 * Licensed under the terms specified in LICENSE
 * 
 * Implementation of enhanced code generation for:
 * - FFI calls with proper marshaling and annotations
 * - Pattern matching with optimized jump tables
 * - String operations (concatenation and interpolation)
 * - Slice operations with bounds checking
 * - Security features (constant-time, volatile memory)
 * - Concurrency (spawn statements)
 * - Unsafe blocks with GC interaction
 * - Zero-cost abstractions
 */

#include "ffi_assembly_generator.h"
#include "../../runtime/asthra_runtime.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>

// Define missing type constants
#define TYPE_VOID    ASTHRA_TYPE_VOID
#define TYPE_FLOAT   ASTHRA_TYPE_F32
#define TYPE_DOUBLE  ASTHRA_TYPE_F64
#define TYPE_USIZE   15  // Add missing USIZE type
#define TYPE_POINTER 16  // Add missing POINTER type

// Add missing register definitions
#define REG_AL REG_RAX  // Use RAX for AL register access

// Forward declarations for static functions
static FFIMarshalingType ffi_determine_marshaling_type(FFIAssemblyGenerator *generator, ASTNode *arg);
static FFIMarshalingType ffi_determine_return_marshaling_type(FFIAssemblyGenerator *generator, ASTNode *call);
static PatternMatchStrategy ffi_determine_pattern_strategy(FFIAssemblyGenerator *generator, PatternMatchContext *context);
static bool ffi_generate_linear_pattern_match(FFIAssemblyGenerator *generator, PatternMatchContext *context);
static bool ffi_marshal_slice_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg);
static bool ffi_marshal_string_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg);
static bool ffi_marshal_result_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg);
static bool ffi_generate_secure_operation(FFIAssemblyGenerator *generator, ASTNode *operation, SecurityContext *context);
static bool ffi_generate_function_declaration(FFIAssemblyGenerator *generator, ASTNode *decl);
static bool ffi_generate_extern_declaration(FFIAssemblyGenerator *generator, ASTNode *decl);
static bool ffi_generate_struct_declaration(FFIAssemblyGenerator *generator, ASTNode *decl);

// =============================================================================
// INTERNAL HELPER FUNCTIONS
// =============================================================================

static char *generate_unique_label(FFIAssemblyGenerator *generator, const char *prefix) {
    (void)generator; // Mark as unused to suppress warning
    static atomic_uint_fast32_t label_counter = 0;
    uint32_t id = atomic_fetch_add(&label_counter, 1);
    
    size_t len = strlen(prefix) + 32;
    char *label = malloc(len);
    if (!label) return NULL;
    
    snprintf(label, len, "%s_%u", prefix, id);
    return label;
}

static bool emit_instruction(FFIAssemblyGenerator *generator, InstructionType type, 
                           size_t operand_count, ...) {
    va_list args;
    va_start(args, operand_count);
    
    // Allocate instruction with flexible array member - same as create_instruction
    size_t size = sizeof(AssemblyInstruction) + operand_count * sizeof(AssemblyOperand);
    AssemblyInstruction *inst = malloc(size);
    if (!inst) {
        va_end(args);
        return false;
    }
    
    inst->type = type;
    inst->operand_count = operand_count;
    inst->comment = NULL;
    
    // Process variadic arguments for operands
    for (size_t i = 0; i < operand_count; i++) {
        inst->operands[i] = va_arg(args, AssemblyOperand);
    }
    
    va_end(args);
    
    bool result = instruction_buffer_add(generator->base_generator->instruction_buffer, inst);
    return result;
}

static void emit_comment(FFIAssemblyGenerator *generator, const char *comment) {
    if (!generator || !comment) return;
    
    // Create comment instruction using existing create_instruction
    AssemblyInstruction *inst = create_instruction(INST_MOV, 0); // Use MOV as placeholder
    if (!inst) return;
    
    // Override with comment
    inst->comment = strdup(comment);
    
    instruction_buffer_add(generator->base_generator->instruction_buffer, inst);
}

static void emit_label(FFIAssemblyGenerator *generator, const char *label) {
    if (!generator || !label) return;
    
    // Create a label entry in the label manager
    if (generator->base_generator->label_manager) {
        label_manager_define_label(generator->base_generator->label_manager, 
                                 label, 
                                 generator->base_generator->instruction_buffer->count);
    }
}

// =============================================================================
// CORE FFI ASSEMBLY GENERATOR FUNCTIONS
// =============================================================================

FFIAssemblyGenerator *ffi_assembly_generator_create(TargetArchitecture arch, 
                                                   CallingConvention conv) {
    FFIAssemblyGenerator *generator = calloc(1, sizeof(FFIAssemblyGenerator));
    if (!generator) return NULL;
    
    // Create base code generator
    generator->base_generator = code_generator_create(arch, conv);
    if (!generator->base_generator) {
        free(generator);
        return NULL;
    }
    
    // Initialize configuration with defaults
    generator->config.enable_bounds_checking = true;
    generator->config.enable_security_features = true;
    generator->config.enable_concurrency = true;
    generator->config.optimize_string_operations = true;
    generator->config.optimize_pattern_matching = true;
    generator->config.max_variadic_args = 32;
    generator->config.pic_mode = false;
    
    // Initialize runtime function names
    generator->runtime_functions.gc_alloc = strdup("asthra_gc_alloc");
    generator->runtime_functions.gc_free = strdup("asthra_gc_free");
    generator->runtime_functions.slice_bounds_check = strdup("asthra_slice_bounds_check");
    generator->runtime_functions.string_concat = strdup("asthra_string_concat");
    generator->runtime_functions.string_interpolate = strdup("asthra_string_interpolate");
    generator->runtime_functions.result_create_ok = strdup("asthra_result_create_ok");
    generator->runtime_functions.result_create_err = strdup("asthra_result_create_err");
    generator->runtime_functions.spawn_task = strdup("asthra_spawn_task");
    generator->runtime_functions.secure_zero = strdup("asthra_secure_zero");
    
    // Initialize atomic statistics
    atomic_init(&generator->ffi_calls_generated, 0);
    atomic_init(&generator->pattern_matches_generated, 0);
    atomic_init(&generator->string_operations_generated, 0);
    atomic_init(&generator->slice_operations_generated, 0);
    atomic_init(&generator->security_operations_generated, 0);
    atomic_init(&generator->spawn_statements_generated, 0);
    
    return generator;
}

void ffi_assembly_generator_destroy(FFIAssemblyGenerator *generator) {
    if (!generator) return;
    
    // Destroy base generator
    if (generator->base_generator) {
        code_generator_destroy(generator->base_generator);
    }
    
    // Free runtime function names
    free(generator->runtime_functions.gc_alloc);
    free(generator->runtime_functions.gc_free);
    free(generator->runtime_functions.slice_bounds_check);
    free(generator->runtime_functions.string_concat);
    free(generator->runtime_functions.string_interpolate);
    free(generator->runtime_functions.result_create_ok);
    free(generator->runtime_functions.result_create_err);
    free(generator->runtime_functions.spawn_task);
    free(generator->runtime_functions.secure_zero);
    
    // Free contexts if allocated
    free(generator->current_ffi_call);
    free(generator->current_pattern_match);
    free(generator->current_string_op);
    free(generator->current_slice_op);
    free(generator->current_security_op);
    free(generator->current_concurrency_op);
    
    free(generator);
}

bool ffi_generate_program(FFIAssemblyGenerator *generator, ASTNode *program) {
    if (!generator || !program || program->type != AST_PROGRAM) {
        return false;
    }
    
    emit_comment(generator, "Generated by Asthra FFI Assembly Generator");
    emit_comment(generator, "Target: System V AMD64 ABI with C17 compatibility");
    
    // Generate assembly directives
    if (generator->config.pic_mode) {
        emit_comment(generator, "Position Independent Code enabled");
    }
    
    // Process all top-level declarations
    ASTNodeList *declarations = program->data.program.declarations;
    for (size_t i = 0; i < declarations->count; i++) {
        ASTNode *decl = declarations->nodes[i];
        
        switch (decl->type) {
            case AST_FUNCTION_DECL:
                if (!ffi_generate_function_declaration(generator, decl)) {
                    return false;
                }
                break;
                
            case AST_EXTERN_DECL:
                if (!ffi_generate_extern_declaration(generator, decl)) {
                    return false;
                }
                break;
                
            case AST_STRUCT_DECL:
                if (!ffi_generate_struct_declaration(generator, decl)) {
                    return false;
                }
                break;
                
            case AST_MODULE_DECL:
                if (!ffi_generate_module_declaration(generator, decl)) {
                    return false;
                }
                break;
                
            case AST_USE_DECL:
                if (!ffi_generate_use_declaration(generator, decl)) {
                    return false;
                }
                break;
                
            default:
                // Skip other declaration types
                break;
        }
    }
    
    return true;
}

// =============================================================================
// FFI CALL GENERATION
// =============================================================================

bool ffi_generate_extern_call(FFIAssemblyGenerator *generator, ASTNode *call_expr) {
    if (!generator || !call_expr || call_expr->type != AST_CALL_EXPR) {
        return false;
    }
    
    atomic_fetch_add(&generator->ffi_calls_generated, 1);
    
    // Create FFI call context
    FFICallContext *context = calloc(1, sizeof(FFICallContext));
    if (!context) return false;
    
    generator->current_ffi_call = context;
    
    // Extract function name and arguments
    ASTNode *function = call_expr->data.call_expr.function;
    ASTNodeList *args = call_expr->data.call_expr.args;
    
    if (function->type != AST_IDENTIFIER) {
        free(context);
        return false;
    }
    
    context->function_name = strdup(function->data.identifier.name);
    context->calling_conv = FFI_CONV_SYSV_AMD64;
    context->parameter_count = args ? args->count : 0;
    
    emit_comment(generator, "FFI function call");
    
    // Allocate parameter information
    if (context->parameter_count > 0) {
        context->parameters = calloc(context->parameter_count, 
                                   sizeof(*context->parameters));
        if (!context->parameters) {
            free(context->function_name);
            free(context);
            return false;
        }
    }
    
    // Process parameters and determine marshaling
    size_t int_param_index = 0;
    size_t float_param_index = 0;
    (void)float_param_index; // Suppress unused variable warning
    size_t stack_offset = 0;
    
    for (size_t i = 0; i < context->parameter_count; i++) {
        ASTNode *arg = args->nodes[i];
        
        // Determine marshaling type based on argument type
        FFIMarshalingType marshal_type = ffi_determine_marshaling_type(generator, arg);
        context->parameters[i].marshal_type = marshal_type;
        
        // Allocate register or stack space
        Register param_reg = REG_NONE;
        
        switch (marshal_type) {
            case FFI_MARSHAL_DIRECT:
                if (int_param_index < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index++];
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 8; // 8-byte alignment
                }
                break;
                
            case FFI_MARSHAL_SLICE:
                // Slices need two registers (pointer + length)
                if (int_param_index + 1 < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index];
                    int_param_index += 2; // Use two registers
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 16; // Two 8-byte values
                }
                break;
                
            case FFI_MARSHAL_STRING:
                if (int_param_index < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index++];
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 8;
                }
                break;
                
            default:
                // Handle other marshaling types
                break;
        }
        
        context->parameters[i].allocated_reg = param_reg;
        
        // Generate parameter marshaling code
        if (!ffi_generate_parameter_marshaling(generator, arg, marshal_type, 
                                              FFI_TRANSFER_NONE, param_reg)) {
            // Cleanup and return error
            free(context->parameters);
            free(context->function_name);
            free(context);
            return false;
        }
    }
    
    context->total_stack_size = stack_offset;
    
    // Align stack to 16-byte boundary (System V AMD64 requirement)
    if (context->total_stack_size % 16 != 0) {
        context->alignment_padding = 16 - (context->total_stack_size % 16);
        context->total_stack_size += context->alignment_padding;
    }
    
    // Adjust stack pointer if needed
    if (context->total_stack_size > 0) {
        emit_instruction(generator, INST_SUB, 2,
                        create_register_operand(REG_RSP),
                        create_immediate_operand((int64_t)context->total_stack_size));
    }
    
    // Generate the actual call
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand(context->function_name));
    
    // Restore stack pointer
    if (context->total_stack_size > 0) {
        emit_instruction(generator, INST_ADD, 2,
                        create_register_operand(REG_RSP),
                        create_immediate_operand((int64_t)context->total_stack_size));
    }
    
    // Handle return value if needed
    if (call_expr->type_info && call_expr->type_info->base_type != TYPE_VOID) {
        // Return value is in RAX for integers, XMM0 for floats
        Register return_reg = (call_expr->type_info->base_type == TYPE_FLOAT || 
                              call_expr->type_info->base_type == TYPE_DOUBLE) ? 
                              REG_XMM0 : REG_RAX;
        
        context->return_reg = return_reg;
        context->return_marshal_type = ffi_determine_return_marshaling_type(generator, call_expr);
    }
    
    // Cleanup context
    free(context->parameters);
    free(context->function_name);
    free(context);
    generator->current_ffi_call = NULL;
    
    return true;
}

bool ffi_generate_variadic_call(FFIAssemblyGenerator *generator, 
                               ASTNode *call_expr, size_t fixed_args) {
    if (!generator || !call_expr || call_expr->type != AST_CALL_EXPR) {
        return false;
    }
    
    atomic_fetch_add(&generator->ffi_calls_generated, 1);
    
    // Create FFI call context for variadic function
    FFICallContext *context = calloc(1, sizeof(FFICallContext));
    if (!context) return false;
    
    generator->current_ffi_call = context;
    
    // Extract function name and arguments
    ASTNode *function = call_expr->data.call_expr.function;
    ASTNodeList *args = call_expr->data.call_expr.args;
    
    if (function->type != AST_IDENTIFIER) {
        free(context);
        return false;
    }
    
    context->function_name = strdup(function->data.identifier.name);
    context->calling_conv = FFI_CONV_SYSV_AMD64;
    context->parameter_count = args ? args->count : 0;
    
    if (context->parameter_count < fixed_args) {
        free(context->function_name);
        free(context);
        return false;
    }
    
    emit_comment(generator, "Variadic FFI function call");
    
    // Allocate parameter information
    if (context->parameter_count > 0) {
        context->parameters = calloc(context->parameter_count, 
                                   sizeof(*context->parameters));
        if (!context->parameters) {
            free(context->function_name);
            free(context);
            return false;
        }
    }
    
    // Process fixed parameters first
    size_t int_param_index = 0;
    size_t float_param_index = 0;
    size_t stack_offset = 0;
    
    (void)float_param_index; // Suppress unused variable warning
    
    for (size_t i = 0; i < fixed_args && i < context->parameter_count; i++) {
        ASTNode *arg = args->nodes[i];
        
        // Determine marshaling type
        FFIMarshalingType marshal_type = ffi_determine_marshaling_type(generator, arg);
        context->parameters[i].marshal_type = marshal_type;
        context->parameters[i].is_variadic = false;
        
        // Allocate register or stack space
        Register param_reg = REG_NONE;
        
        switch (marshal_type) {
            case FFI_MARSHAL_DIRECT:
                if (int_param_index < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index++];
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 8;
                }
                break;
                
            case FFI_MARSHAL_SLICE:
                if (int_param_index + 1 < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index];
                    int_param_index += 2;
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 16;
                }
                break;
                
            default:
                if (int_param_index < SYSV_INT_PARAM_COUNT) {
                    param_reg = SYSV_INT_PARAM_REGS[int_param_index++];
                } else {
                    context->parameters[i].stack_offset = stack_offset;
                    stack_offset += 8;
                }
                break;
        }
        
        context->parameters[i].allocated_reg = param_reg;
        
        // Generate parameter marshaling
        if (!ffi_generate_parameter_marshaling(generator, arg, marshal_type, 
                                              FFI_TRANSFER_NONE, param_reg)) {
            // Cleanup and return error
            free(context->parameters);
            free(context->function_name);
            free(context);
            return false;
        }
    }
    
    // Process variadic parameters
    for (size_t i = fixed_args; i < context->parameter_count; i++) {
        ASTNode *arg = args->nodes[i];
        
        context->parameters[i].marshal_type = FFI_MARSHAL_VARIADIC;
        context->parameters[i].is_variadic = true;
        
        // Variadic arguments are always passed on stack in System V AMD64
        context->parameters[i].stack_offset = stack_offset;
        context->parameters[i].allocated_reg = REG_NONE;
        
        // Generate variadic argument marshaling
        if (!ffi_generate_parameter_marshaling(generator, arg, FFI_MARSHAL_VARIADIC, 
                                              FFI_TRANSFER_NONE, REG_NONE)) {
            free(context->parameters);
            free(context->function_name);
            free(context);
            return false;
        }
        
        // Variadic arguments are 8-byte aligned
        stack_offset += 8;
    }
    
    context->total_stack_size = stack_offset;
    
    // Set AL register to number of vector registers used (required for variadic calls)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_AL),
                    create_immediate_operand(0)); // No vector registers for now
    
    // Align stack to 16-byte boundary
    if (context->total_stack_size % 16 != 0) {
        context->alignment_padding = 16 - (context->total_stack_size % 16);
        context->total_stack_size += context->alignment_padding;
    }
    
    // Adjust stack pointer if needed
    if (context->total_stack_size > 0) {
        emit_instruction(generator, INST_SUB, 2,
                        create_register_operand(REG_RSP),
                        create_immediate_operand((int64_t)context->total_stack_size));
    }
    
    // Generate the actual call
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand(context->function_name));
    
    // Restore stack pointer
    if (context->total_stack_size > 0) {
        emit_instruction(generator, INST_ADD, 2,
                        create_register_operand(REG_RSP),
                        create_immediate_operand((int64_t)context->total_stack_size));
    }
    
    // Handle return value
    if (call_expr->type_info && call_expr->type_info->base_type != TYPE_VOID) {
        context->return_reg = REG_RAX;
        context->return_marshal_type = ffi_determine_return_marshaling_type(generator, call_expr);
    }
    
    // Cleanup context
    free(context->parameters);
    free(context->function_name);
    free(context);
    generator->current_ffi_call = NULL;
    
    return true;
}

bool ffi_generate_parameter_marshaling(FFIAssemblyGenerator *generator,
                                     ASTNode *param, FFIMarshalingType marshal_type,
                                     FFITransferType transfer_type, Register target_reg) {
    (void)transfer_type; // Mark as unused to suppress warning
    
    if (!generator || !param) return false;
    
    switch (marshal_type) {
        case FFI_MARSHAL_SLICE:
            return ffi_marshal_slice_parameter(generator, param, target_reg);
            
        case FFI_MARSHAL_STRING:
            return ffi_marshal_string_parameter(generator, param, target_reg);
            
        case FFI_MARSHAL_RESULT:
            return ffi_marshal_result_parameter(generator, param, target_reg);
            
        case FFI_MARSHAL_VARIADIC:
            {
                emit_comment(generator, "Marshal variadic parameter");
                
                // Allocate register for the argument
                Register arg_reg = register_allocate(generator->base_generator->register_allocator, true);
                if (arg_reg == REG_NONE) return false;
                
                // Generate code to load the argument
                if (!code_generate_expression(generator->base_generator, param, arg_reg)) {
                    register_free(generator->base_generator->register_allocator, arg_reg);
                    return false;
                }
                
                // Push variadic argument onto stack
                emit_instruction(generator, INST_PUSH, 1,
                                create_register_operand(arg_reg));
                
                register_free(generator->base_generator->register_allocator, arg_reg);
                return true;
            }
            
        case FFI_MARSHAL_DIRECT:
        default:
            {
                // Direct marshaling - generate expression and move to target register
                if (target_reg == REG_NONE) {
                    // If no target register, push onto stack
                    Register temp_reg = register_allocate(generator->base_generator->register_allocator, true);
                    if (temp_reg == REG_NONE) return false;
                    
                    if (!code_generate_expression(generator->base_generator, param, temp_reg)) {
                        register_free(generator->base_generator->register_allocator, temp_reg);
                        return false;
                    }
                    
                    emit_instruction(generator, INST_PUSH, 1,
                                    create_register_operand(temp_reg));
                    
                    register_free(generator->base_generator->register_allocator, temp_reg);
                    return true;
                } else {
                    // Generate expression directly into target register
                    return code_generate_expression(generator->base_generator, param, target_reg);
                }
            }
    }
}

// =============================================================================
// PATTERN MATCHING GENERATION
// =============================================================================

bool ffi_generate_match_statement(FFIAssemblyGenerator *generator, ASTNode *match_stmt) {
    if (!generator || !match_stmt || match_stmt->type != AST_MATCH_STMT) {
        return false;
    }
    
    atomic_fetch_add(&generator->pattern_matches_generated, 1);
    
    // Create pattern match context
    PatternMatchContext *context = calloc(1, sizeof(PatternMatchContext));
    if (!context) return false;
    
    generator->current_pattern_match = context;
    
    emit_comment(generator, "Pattern match statement");
    
    // Generate match expression
    Register match_reg = register_allocate(generator->base_generator->register_allocator, true);
    if (match_reg == REG_NONE) {
        free(context);
        return false;
    }
    
    if (!code_generate_expression(generator->base_generator, 
                                 match_stmt->data.match_stmt.expression, match_reg)) {
        register_free(generator->base_generator->register_allocator, match_reg);
        free(context);
        return false;
    }
    
    context->match_value_reg = match_reg;
    context->match_type = match_stmt->data.match_stmt.expression->type_info;
    
    // Process match arms
    ASTNodeList *arms = match_stmt->data.match_stmt.arms;
    context->arm_count = arms->count;
    context->arms = calloc(context->arm_count, sizeof(*context->arms));
    
    if (!context->arms) {
        register_free(generator->base_generator->register_allocator, match_reg);
        free(context);
        return false;
    }
    
    // Determine pattern matching strategy
    context->strategy = ffi_determine_pattern_strategy(generator, context);
    
    // Generate labels for each arm
    for (size_t i = 0; i < context->arm_count; i++) {
        context->arms[i].pattern_label = generate_unique_label(generator, "pattern");
        context->arms[i].body_label = generate_unique_label(generator, "match_body");
        context->arms[i].end_label = generate_unique_label(generator, "match_end");
    }
    
    char *match_end_label = generate_unique_label(generator, "match_complete");
    
    // Generate pattern matching code based on strategy
    switch (context->strategy) {
        case PATTERN_STRATEGY_JUMP_TABLE:
            if (!ffi_generate_pattern_jump_table(generator, context)) {
                goto cleanup_match;
            }
            break;
            
        case PATTERN_STRATEGY_LINEAR:
            if (!ffi_generate_linear_pattern_match(generator, context)) {
                goto cleanup_match;
            }
            break;
            
        default:
            goto cleanup_match;
    }
    
    // Generate match arm bodies
    for (size_t i = 0; i < context->arm_count; i++) {
        ASTNode *arm = arms->nodes[i];
        
        // Labels will be handled during assembly output, not as instructions
        
        // Generate arm body
        if (!code_generate_statement(generator->base_generator, arm->data.match_arm.body)) {
            goto cleanup_match;
        }
        
        // Jump to end
        emit_instruction(generator, INST_JMP, 1, create_label_operand(match_end_label));
    }
    
    // Labels will be handled during assembly output, not as instructions
    
    register_free(generator->base_generator->register_allocator, match_reg);
    
    // Cleanup
    for (size_t i = 0; i < context->arm_count; i++) {
        free(context->arms[i].pattern_label);
        free(context->arms[i].body_label);
        free(context->arms[i].end_label);
    }
    free(context->arms);
    free(context);
    free(match_end_label);
    generator->current_pattern_match = NULL;
    
    return true;

cleanup_match:
    register_free(generator->base_generator->register_allocator, match_reg);
    for (size_t i = 0; i < context->arm_count; i++) {
        free(context->arms[i].pattern_label);
        free(context->arms[i].body_label);
        free(context->arms[i].end_label);
    }
    free(context->arms);
    free(context);
    free(match_end_label);
    generator->current_pattern_match = NULL;
    return false;
}

bool ffi_generate_result_pattern_match(FFIAssemblyGenerator *generator,
                                     ASTNode *pattern, Register result_reg) {
    if (!generator || !pattern) return false;
    
    emit_comment(generator, "Result<T,E> pattern match");
    
    // Result types are represented as tagged unions
    // First word: tag (0 = Ok, 1 = Err)
    // Second word: value
    
    Register tag_reg = register_allocate(generator->base_generator->register_allocator, true);
    if (tag_reg == REG_NONE) return false;
    
    // Load tag from result
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(tag_reg),
                    create_memory_operand(result_reg, REG_NONE, 1, 0));
    
    // Compare tag
    emit_instruction(generator, INST_CMP, 2,
                    create_register_operand(tag_reg),
                    create_immediate_operand(0)); // 0 = Ok
    
    char *ok_label = generate_unique_label(generator, "result_ok");
    char *err_label = generate_unique_label(generator, "result_err");
    
    emit_instruction(generator, INST_JE, 1, create_label_operand(ok_label));
    emit_instruction(generator, INST_JMP, 1, create_label_operand(err_label));
    
    register_free(generator->base_generator->register_allocator, tag_reg);
    free(ok_label);
    free(err_label);
    
    return true;
}

// =============================================================================
// STRING OPERATION GENERATION
// =============================================================================

bool ffi_generate_string_concatenation(FFIAssemblyGenerator *generator,
                                     Register left_reg, Register right_reg,
                                     Register result_reg) {
    if (!generator) return false;
    
    atomic_fetch_add(&generator->string_operations_generated, 1);
    
    emit_comment(generator, "String concatenation");
    
    // Call runtime string concatenation function
    // Parameters: left string, right string
    // Return: new concatenated string
    
    // Set up parameters according to System V AMD64 ABI
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDI),
                    create_register_operand(left_reg));
    
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RSI),
                    create_register_operand(right_reg));
    
    // Call runtime function
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand(generator->runtime_functions.string_concat));
    
    // Move result to target register
    if (result_reg != REG_RAX) {
        emit_instruction(generator, INST_MOV, 2,
                        create_register_operand(result_reg),
                        create_register_operand(REG_RAX));
    }
    
    return true;
}

bool ffi_generate_string_interpolation(FFIAssemblyGenerator *generator,
                                     ASTNode *interpolation_expr) {
    if (!generator || !interpolation_expr || 
        interpolation_expr->type != AST_STRING_INTERPOLATION) {
        return false;
    }
    
    atomic_fetch_add(&generator->string_operations_generated, 1);
    
    emit_comment(generator, "String interpolation");
    
    // Create string operation context
    StringOperationContext *context = calloc(1, sizeof(StringOperationContext));
    if (!context) return false;
    
    generator->current_string_op = context;
    context->operation = STRING_OP_INTERPOLATION;
    
    // Get template and expressions
    char *template = interpolation_expr->data.string_interpolation.template;
    ASTNodeList *expressions = interpolation_expr->data.string_interpolation.expressions;
    
    context->interpolation.template_string = template;
    context->interpolation.expression_count = expressions ? expressions->count : 0;
    
    if (context->interpolation.expression_count > 0) {
        context->interpolation.expression_regs = 
            calloc(context->interpolation.expression_count, sizeof(Register));
        
        if (!context->interpolation.expression_regs) {
            free(context);
            return false;
        }
        
        // Generate expressions and store in registers
        for (size_t i = 0; i < context->interpolation.expression_count; i++) {
            Register expr_reg = register_allocate(generator->base_generator->register_allocator, true);
            if (expr_reg == REG_NONE) {
                // Cleanup and return error
                for (size_t j = 0; j < i; j++) {
                    register_free(generator->base_generator->register_allocator, 
                                context->interpolation.expression_regs[j]);
                }
                free(context->interpolation.expression_regs);
                free(context);
                return false;
            }
            
            context->interpolation.expression_regs[i] = expr_reg;
            
            if (!code_generate_expression(generator->base_generator, 
                                        expressions->nodes[i], expr_reg)) {
                // Cleanup and return error
                for (size_t j = 0; j <= i; j++) {
                    register_free(generator->base_generator->register_allocator, 
                                context->interpolation.expression_regs[j]);
                }
                free(context->interpolation.expression_regs);
                free(context);
                return false;
            }
        }
    }
    
    // Set up call to runtime interpolation function
    // Parameters: template string, expression array, expression count
    
    // Template string in RDI
    Register template_reg = register_allocate(generator->base_generator->register_allocator, true);
    emit_instruction(generator, INST_LEA, 2,
                    create_register_operand(template_reg),
                    create_label_operand(template)); // Assume template is a string literal
    
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDI),
                    create_register_operand(template_reg));
    
    // Expression array in RSI (simplified - would need proper array setup)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RSI),
                    create_immediate_operand(0)); // NULL for now
    
    // Expression count in RDX
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDX),
                    create_immediate_operand((int64_t)context->interpolation.expression_count));
    
    // Call runtime function
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand(generator->runtime_functions.string_interpolate));
    
    // Cleanup
    register_free(generator->base_generator->register_allocator, template_reg);
    
    if (context->interpolation.expression_regs) {
        for (size_t i = 0; i < context->interpolation.expression_count; i++) {
            register_free(generator->base_generator->register_allocator, 
                        context->interpolation.expression_regs[i]);
        }
        free(context->interpolation.expression_regs);
    }
    
    free(context);
    generator->current_string_op = NULL;
    
    return true;
}

// =============================================================================
// SLICE OPERATION GENERATION
// =============================================================================

bool ffi_generate_slice_length_access(FFIAssemblyGenerator *generator,
                                     Register slice_reg, Register result_reg) {
    if (!generator) return false;
    
    atomic_fetch_add(&generator->slice_operations_generated, 1);
    
    emit_comment(generator, "Slice length access");
    
    // Slice structure: [ptr, len, cap] (simplified)
    // Length is at offset 8 from slice pointer
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(result_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 8));
    
    return true;
}

bool ffi_generate_slice_bounds_check(FFIAssemblyGenerator *generator,
                                    Register slice_reg, Register index_reg,
                                    char *bounds_error_label) {
    if (!generator || !generator->config.enable_bounds_checking) {
        return true; // Skip if bounds checking disabled
    }
    
    emit_comment(generator, "Slice bounds check");
    
    // Load slice length
    Register len_reg = register_allocate(generator->base_generator->register_allocator, true);
    if (len_reg == REG_NONE) return false;
    
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(len_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 8));
    
    // Compare index with length
    emit_instruction(generator, INST_CMP, 2,
                    create_register_operand(index_reg),
                    create_register_operand(len_reg));
    
    // Jump to error if index >= length
    emit_instruction(generator, INST_JAE, 1, create_label_operand(bounds_error_label));
    
    register_free(generator->base_generator->register_allocator, len_reg);
    
    return true;
}

bool ffi_generate_slice_to_ffi(FFIAssemblyGenerator *generator,
                              Register slice_reg, Register ptr_reg, Register len_reg) {
    if (!generator) return false;
    
    emit_comment(generator, "Slice to FFI pointer conversion");
    
    // Load pointer from slice
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(ptr_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 0));
    
    // Load length from slice
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(len_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 8));
    
    return true;
}

// =============================================================================
// ENHANCED SECURITY OPERATION GENERATION
// =============================================================================

bool ffi_generate_constant_time_operation(FFIAssemblyGenerator *generator,
                                        ASTNode *operation) {
    if (!generator || !generator->config.enable_security_features) {
        return code_generate_statement(generator->base_generator, operation);
    }
    
    atomic_fetch_add(&generator->security_operations_generated, 1);
    
    emit_comment(generator, "Constant-time operation");
    
    // Create security context
    SecurityContext *context = calloc(1, sizeof(SecurityContext));
    if (!context) return false;
    
    generator->current_security_op = context;
    context->operation = SECURITY_OP_CONSTANT_TIME;
    context->avoid_branches = true;
    context->use_cmov_instructions = true;
    context->avoid_memory_access_patterns = true;
    
    // Disable branch prediction and speculative execution
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_disable_speculation"));
    
    // Generate operation with constant-time constraints
    bool result = ffi_generate_secure_operation(generator, operation, context);
    
    // Re-enable optimizations
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_enable_speculation"));
    
    // Add memory barrier to prevent reordering
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_memory_barrier"));
    
    free(context);
    generator->current_security_op = NULL;
    
    return result;
}

bool ffi_generate_volatile_memory_access(FFIAssemblyGenerator *generator,
                                        Register memory_reg, size_t size,
                                        bool is_read) {
    if (!generator) return false;
    
    emit_comment(generator, is_read ? "Volatile memory read" : "Volatile memory write");
    
    // Add memory barrier before volatile access
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_memory_barrier"));
    
    // Generate volatile memory access with compiler barriers
    if (is_read) {
        // Volatile read with explicit memory ordering
        emit_instruction(generator, INST_MOV, 2,
                        create_register_operand(REG_RAX),
                        create_memory_operand(memory_reg, REG_NONE, 1, 0));
        
        // Prevent compiler from optimizing away the read
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_compiler_barrier"));
    } else {
        // Volatile write with explicit memory ordering
        emit_instruction(generator, INST_MOV, 2,
                        create_memory_operand(memory_reg, REG_NONE, 1, 0),
                        create_register_operand(REG_RAX));
        
        // Ensure write is committed before continuing
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_memory_fence"));
    }
    
    // Add memory barrier after volatile access
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_memory_barrier"));
    
    // For larger sizes, generate appropriate sized operations
    if (size > 8) {
        emit_comment(generator, "Multi-byte volatile access");
        
        // Generate loop for larger volatile operations
        Register counter_reg = register_allocate(generator->base_generator->register_allocator, false);
        if (counter_reg != REG_NONE) {
            // Initialize counter
            emit_instruction(generator, INST_MOV, 2,
                            create_register_operand(counter_reg),
                            create_immediate_operand(0));
            
            // Loop label
            const char *loop_label = "volatile_loop";
            emit_label(generator, loop_label);
            
            // Volatile access for current byte
            if (is_read) {
                emit_instruction(generator, INST_MOV, 2,
                                create_register_operand(REG_AL),
                                create_memory_operand(memory_reg, counter_reg, 1, 0));
            } else {
                emit_instruction(generator, INST_MOV, 2,
                                create_memory_operand(memory_reg, counter_reg, 1, 0),
                                create_register_operand(REG_AL));
            }
            
            // Increment counter
            emit_instruction(generator, INST_INC, 1,
                            create_register_operand(counter_reg));
            
            // Compare with size
            emit_instruction(generator, INST_CMP, 2,
                            create_register_operand(counter_reg),
                            create_immediate_operand((int64_t)size));
            
            // Jump back if not done
            emit_instruction(generator, INST_JL, 1,
                            create_label_operand(loop_label));
            
            register_free(generator->base_generator->register_allocator, counter_reg);
        }
    }
    
    return true;
}

bool ffi_generate_secure_zero(FFIAssemblyGenerator *generator,
                             Register memory_reg, Register size_reg) {
    if (!generator) return false;
    
    emit_comment(generator, "Secure memory zeroing");
    
    // Call runtime secure zero function
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDI),
                    create_register_operand(memory_reg));
    
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RSI),
                    create_register_operand(size_reg));
    
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_secure_zero"));
    
    // Add memory barrier to ensure zeroing is complete
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_memory_barrier"));
    
    return true;
}

bool ffi_generate_ffi_security_boundary(FFIAssemblyGenerator *generator,
                                       ASTNode *extern_call, bool entering_ffi) {
    if (!generator || !extern_call) return false;
    
    if (entering_ffi) {
        emit_comment(generator, "Entering FFI security boundary");
        
        // Validate security annotations on the extern function
        if (extern_call->type == AST_CALL_EXPR) {
            ASTNode *function = extern_call->data.call_expr.function;
            if (function && function->type == AST_IDENTIFIER) {
                const char *func_name = function->data.identifier.name;
                
                // Check if this is a security-sensitive FFI call
                if (strstr(func_name, "crypto") || strstr(func_name, "secure") || 
                    strstr(func_name, "constant_time")) {
                    
                    // Add security barriers for crypto functions
                    emit_instruction(generator, INST_CALL, 1,
                                    create_label_operand("asthra_crypto_barrier_enter"));
                    
                    // Clear sensitive registers
                    emit_instruction(generator, INST_XOR, 2,
                                    create_register_operand(REG_RAX),
                                    create_register_operand(REG_RAX));
                    emit_instruction(generator, INST_XOR, 2,
                                    create_register_operand(REG_RDX),
                                    create_register_operand(REG_RDX));
                }
            }
        }
        
        // Save security context
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_save_security_context"));
        
    } else {
        emit_comment(generator, "Exiting FFI security boundary");
        
        // Restore security context
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_restore_security_context"));
        
        // Clear any sensitive data that might have been returned
        if (extern_call->type == AST_CALL_EXPR) {
            ASTNode *function = extern_call->data.call_expr.function;
            if (function && function->type == AST_IDENTIFIER) {
                const char *func_name = function->data.identifier.name;
                
                if (strstr(func_name, "crypto") || strstr(func_name, "secure")) {
                    // Add security barriers for crypto functions
                    emit_instruction(generator, INST_CALL, 1,
                                    create_label_operand("asthra_crypto_barrier_exit"));
                }
            }
        }
        
        // Memory barrier to prevent sensitive data leakage
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_memory_barrier"));
    }
    
    return true;
}

bool ffi_validate_security_annotations_at_boundary(FFIAssemblyGenerator *generator,
                                                  ASTNode *extern_decl) {
    if (!generator || !extern_decl || extern_decl->type != AST_EXTERN_DECL) {
        return false;
    }
    
    emit_comment(generator, "Validating FFI security annotations");
    
    // Check for security annotations on the extern function
    ASTNodeList *annotations = extern_decl->data.extern_decl.annotations;
    bool has_constant_time = false;
    bool has_volatile_memory = false;
    
    if (annotations) {
        for (size_t i = 0; i < ast_node_list_size(annotations); i++) {
            ASTNode *annotation = ast_node_list_get(annotations, i);
            if (annotation && annotation->type == AST_SECURITY_TAG) {
                SecurityType security_type = annotation->data.security_tag.security_type;
                
                switch (security_type) {
                    case SECURITY_CONSTANT_TIME:
                        has_constant_time = true;
                        break;
                    case SECURITY_VOLATILE_MEMORY:
                        has_volatile_memory = true;
                        break;
                    default:
                        break;
                }
            }
        }
    }
    
    // Generate runtime validation for security properties
    if (has_constant_time) {
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_validate_constant_time_ffi"));
    }
    
    if (has_volatile_memory) {
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_validate_volatile_memory_ffi"));
    }
    
    // Validate parameter transfer annotations
    ASTNodeList *params = extern_decl->data.extern_decl.params;
    if (params) {
        for (size_t i = 0; i < ast_node_list_size(params); i++) {
            ASTNode *param = ast_node_list_get(params, i);
            if (param && param->data.param_decl.annotations) {
                // Generate validation for parameter transfer semantics
                emit_instruction(generator, INST_PUSH, 1,
                                create_immediate_operand((int64_t)i));
                emit_instruction(generator, INST_CALL, 1,
                                create_label_operand("asthra_validate_ffi_parameter"));
                emit_instruction(generator, INST_ADD, 2,
                                create_register_operand(REG_RSP),
                                create_immediate_operand(8));
            }
        }
    }
    
    return true;
}

// =============================================================================
// CONCURRENCY GENERATION
// =============================================================================

bool ffi_generate_spawn_statement(FFIAssemblyGenerator *generator, ASTNode *spawn_stmt) {
    if (!generator || !spawn_stmt || spawn_stmt->type != AST_SPAWN_STMT) {
        return false;
    }
    
    atomic_fetch_add(&generator->spawn_statements_generated, 1);
    
    emit_comment(generator, "Spawn statement");
    
    // Create concurrency context
    ConcurrencyContext *context = calloc(1, sizeof(ConcurrencyContext));
    if (!context) return false;
    
    generator->current_concurrency_op = context;
    context->operation = CONCURRENCY_OP_SPAWN;
    context->function_name = strdup(spawn_stmt->data.spawn_stmt.function_name);
    
    // Process arguments
    ASTNodeList *args = spawn_stmt->data.spawn_stmt.args;
    context->argument_count = args ? args->count : 0;
    
    if (context->argument_count > 0) {
        context->argument_regs = calloc(context->argument_count, sizeof(Register));
        if (!context->argument_regs) {
            free(context->function_name);
            free(context);
            return false;
        }
        
        // Generate arguments
        for (size_t i = 0; i < context->argument_count; i++) {
            Register arg_reg = register_allocate(generator->base_generator->register_allocator, true);
            if (arg_reg == REG_NONE) {
                // Cleanup
                for (size_t j = 0; j < i; j++) {
                    register_free(generator->base_generator->register_allocator, 
                                context->argument_regs[j]);
                }
                free(context->argument_regs);
                free(context->function_name);
                free(context);
                return false;
            }
            
            context->argument_regs[i] = arg_reg;
            
            if (!code_generate_expression(generator->base_generator, 
                                        args->nodes[i], arg_reg)) {
                // Cleanup and return error
                for (size_t j = 0; j <= i; j++) {
                    register_free(generator->base_generator->register_allocator, 
                                context->argument_regs[j]);
                }
                free(context->argument_regs);
                free(context->function_name);
                free(context);
                return false;
            }
        }
    }
    
    // Generate task creation call
    bool result = ffi_generate_task_creation(generator, context->function_name,
                                            context->argument_regs, context->argument_count,
                                            REG_RAX);
    
    // Cleanup
    if (context->argument_regs) {
        for (size_t i = 0; i < context->argument_count; i++) {
            register_free(generator->base_generator->register_allocator, 
                        context->argument_regs[i]);
        }
        free(context->argument_regs);
    }
    
    free(context->function_name);
    free(context);
    generator->current_concurrency_op = NULL;
    
    return result;
}

bool ffi_generate_task_creation(FFIAssemblyGenerator *generator,
                               char *function_name, Register *arg_regs,
                               size_t arg_count, Register handle_reg) {
    (void)arg_regs; // Mark as unused to suppress warning
    
    if (!generator) return false;
    
    emit_comment(generator, "Task creation");
    
    // Set up parameters for spawn_task runtime function
    // Parameters: function pointer, arguments, argument count
    
    // Function name/pointer in RDI
    emit_instruction(generator, INST_LEA, 2,
                    create_register_operand(REG_RDI),
                    create_label_operand(function_name));
    
    // Arguments array in RSI (simplified)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RSI),
                    create_immediate_operand(0)); // NULL for now
    
    // Argument count in RDX
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDX),
                    create_immediate_operand((int64_t)arg_count));
    
    // Call runtime spawn function
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand(generator->runtime_functions.spawn_task));
    
    // Move task handle to target register
    if (handle_reg != REG_RAX) {
        emit_instruction(generator, INST_MOV, 2,
                        create_register_operand(handle_reg),
                        create_register_operand(REG_RAX));
    }
    
    return true;
}

// =============================================================================
// UNSAFE BLOCK GENERATION
// =============================================================================

bool ffi_generate_unsafe_block(FFIAssemblyGenerator *generator, ASTNode *unsafe_block) {
    if (!generator || !unsafe_block || unsafe_block->type != AST_UNSAFE_BLOCK) {
        return false;
    }
    
    emit_comment(generator, "Unsafe block");
    
    // Generate GC barriers for entering unsafe code
    if (!ffi_generate_gc_barriers(generator, true, false)) {
        return false;
    }
    
    // Generate the unsafe block content
    bool result = code_generate_statement(generator->base_generator, 
                                        unsafe_block->data.unsafe_block.block);
    
    // Generate GC barriers for exiting unsafe code
    if (!ffi_generate_gc_barriers(generator, false, true)) {
        return false;
    }
    
    return result;
}

bool ffi_generate_gc_barriers(FFIAssemblyGenerator *generator,
                             bool entering_unsafe, bool exiting_unsafe) {
    if (!generator) return false;
    
    if (entering_unsafe) {
        emit_comment(generator, "GC barrier: entering unsafe code");
        // Notify GC that we're entering unsafe code
        // This might involve setting thread-local flags or calling runtime functions
    }
    
    if (exiting_unsafe) {
        emit_comment(generator, "GC barrier: exiting unsafe code");
        // Notify GC that we're exiting unsafe code
        // This might involve clearing flags or triggering GC checks
    }
    
    return true;
}

// =============================================================================
// MISSING FUNCTION IMPLEMENTATIONS
// =============================================================================

bool ffi_generate_return_unmarshaling(FFIAssemblyGenerator *generator,
                                    FFIMarshalingType marshal_type,
                                    FFITransferType transfer_type,
                                    Register source_reg, Register target_reg) {
    (void)marshal_type; // Mark as unused to suppress warning
    (void)transfer_type; // Mark as unused to suppress warning
    
    if (!generator) return false;
    
    // Simplified implementation - just move from source to target
    if (source_reg != target_reg) {
        return emit_instruction(generator, INST_MOV, 2,
                              create_register_operand(target_reg),
                              create_register_operand(source_reg));
    }
    return true;
}

bool ffi_generate_if_let_statement(FFIAssemblyGenerator *generator, ASTNode *if_let_stmt) {
    (void)generator; // Mark as unused to suppress warning
    (void)if_let_stmt; // Mark as unused to suppress warning
    // Simplified implementation - would generate if-let pattern matching
    return true;
}

bool ffi_generate_pattern_jump_table(FFIAssemblyGenerator *generator,
                                    PatternMatchContext *context) {
    (void)generator; // Mark as unused to suppress warning
    (void)context; // Mark as unused to suppress warning
    // Simplified implementation - would generate jump table
    return true;
}

bool ffi_generate_deterministic_string_op(FFIAssemblyGenerator *generator,
                                         StringOperationType op_type,
                                         Register *operand_regs, size_t operand_count,
                                         Register result_reg) {
    (void)generator; // Mark as unused to suppress warning
    (void)op_type; // Mark as unused to suppress warning
    (void)operand_regs; // Mark as unused to suppress warning
    (void)operand_count; // Mark as unused to suppress warning
    (void)result_reg; // Mark as unused to suppress warning
    // Simplified implementation - would generate deterministic string operations
    return true;
}

bool ffi_generate_slice_creation(FFIAssemblyGenerator *generator,
                                ASTNode *array_literal, Register result_reg) {
    (void)generator; // Mark as unused to suppress warning
    (void)array_literal; // Mark as unused to suppress warning
    (void)result_reg; // Mark as unused to suppress warning
    // Simplified implementation - would generate slice creation
    return true;
}

bool ffi_generate_await_expression(FFIAssemblyGenerator *generator, ASTNode *await_expr, Register result_reg) {
    if (!generator || !await_expr) {
        return false;
    }
    
    // Set up concurrency context for await operation
    ConcurrencyContext context = {
        .operation = CONCURRENCY_OP_AWAIT,
        .scheduler_await_function = (char*)"asthra_await_task"
    };
    
    generator->current_concurrency_op = &context;
    
    // For now, use a placeholder implementation
    emit_comment(generator, "await expression");
    
    return true;
}

bool ffi_generate_postfix_expression(FFIAssemblyGenerator *generator,
                                    ASTNode *postfix_expr, Register result_reg) {
    (void)generator; // Mark as unused to suppress warning
    (void)postfix_expr; // Mark as unused to suppress warning
    (void)result_reg; // Mark as unused to suppress warning
    // Simplified implementation - would generate postfix expressions
    return true;
}

bool ffi_generate_result_construction(FFIAssemblyGenerator *generator,
                                    bool is_ok, Register value_reg,
                                    TypeInfo *result_type, Register result_reg) {
    (void)generator; // Mark as unused to suppress warning
    (void)is_ok; // Mark as unused to suppress warning
    (void)value_reg; // Mark as unused to suppress warning
    (void)result_type; // Mark as unused to suppress warning
    (void)result_reg; // Mark as unused to suppress warning
    // Simplified implementation - would generate Result<T,E> construction
    return true;
}

bool ffi_generate_c_struct_layout(FFIAssemblyGenerator *generator,
                                 ASTNode *struct_decl, bool packed) {
    (void)generator; // Mark as unused to suppress warning
    (void)struct_decl; // Mark as unused to suppress warning
    (void)packed; // Mark as unused to suppress warning
    // Simplified implementation - would generate C-compatible struct layouts
    return true;
}

bool ffi_generate_ownership_transfer(FFIAssemblyGenerator *generator,
                                   Register source_reg, Register target_reg,
                                   FFITransferType transfer_type) {
    (void)generator; // Mark as unused to suppress warning
    (void)source_reg; // Mark as unused to suppress warning
    (void)target_reg; // Mark as unused to suppress warning
    (void)transfer_type; // Mark as unused to suppress warning
    // Simplified implementation - would generate ownership transfer code
    return true;
}

bool ffi_optimize_zero_cost_abstractions(FFIAssemblyGenerator *generator) {
    (void)generator; // Mark as unused to suppress warning
    // Simplified implementation - would optimize zero-cost abstractions
    return true;
}

// =============================================================================
// UTILITY AND VALIDATION FUNCTIONS
// =============================================================================

bool ffi_validate_generated_assembly(FFIAssemblyGenerator *generator) {
    if (!generator) return false;
    
    // Validate the generated assembly for correctness
    return code_generator_validate_instructions(generator->base_generator);
}

void ffi_get_generation_statistics(FFIAssemblyGenerator *generator,
                                  size_t *ffi_calls, size_t *pattern_matches,
                                  size_t *string_ops, size_t *slice_ops,
                                  size_t *security_ops, size_t *spawn_stmts) {
    if (!generator) return;
    
    if (ffi_calls) *ffi_calls = atomic_load(&generator->ffi_calls_generated);
    if (pattern_matches) *pattern_matches = atomic_load(&generator->pattern_matches_generated);
    if (string_ops) *string_ops = atomic_load(&generator->string_operations_generated);
    if (slice_ops) *slice_ops = atomic_load(&generator->slice_operations_generated);
    if (security_ops) *security_ops = atomic_load(&generator->security_operations_generated);
    if (spawn_stmts) *spawn_stmts = atomic_load(&generator->spawn_statements_generated);
}

bool ffi_print_nasm_assembly(FFIAssemblyGenerator *generator,
                            char * restrict output_buffer, size_t buffer_size) {
    if (!generator || !output_buffer) return false;
    
    // Generate NASM-compatible assembly output
    return code_generator_emit_assembly(generator->base_generator, 
                                      output_buffer, buffer_size);
}

// =============================================================================
// HELPER FUNCTION IMPLEMENTATIONS (Complete implementations)
// =============================================================================

static FFIMarshalingType ffi_determine_marshaling_type(FFIAssemblyGenerator *generator, ASTNode *arg) {
    if (!generator || !arg) return FFI_MARSHAL_DIRECT;
    
    // Check if the argument has type information
    if (!arg->type_info) {
        // Fallback to AST node type analysis
        switch (arg->type) {
            case AST_STRING_LITERAL:
            case AST_STRING_INTERPOLATION:
                return FFI_MARSHAL_STRING;
            case AST_ARRAY_LITERAL:
                return FFI_MARSHAL_SLICE;
            case AST_IDENTIFIER:
                // Would need symbol table lookup for precise type
                return FFI_MARSHAL_DIRECT;
            default:
                return FFI_MARSHAL_DIRECT;
        }
    }
    
    // Use type information for precise marshaling
    switch (arg->type_info->base_type) {
        case ASTHRA_TYPE_STRING:
            return FFI_MARSHAL_STRING;
        case ASTHRA_TYPE_SLICE:
            return FFI_MARSHAL_SLICE;
        case ASTHRA_TYPE_RESULT:
            return FFI_MARSHAL_RESULT;
        case ASTHRA_TYPE_I8:
        case ASTHRA_TYPE_U8:
        case ASTHRA_TYPE_I16:
        case ASTHRA_TYPE_U16:
        case ASTHRA_TYPE_I32:
        case ASTHRA_TYPE_U32:
        case ASTHRA_TYPE_I64:
        case ASTHRA_TYPE_U64:
        case ASTHRA_TYPE_F32:
        case ASTHRA_TYPE_F64:
        case ASTHRA_TYPE_BOOL:
        case TYPE_USIZE:
        case TYPE_POINTER:
            return FFI_MARSHAL_DIRECT;
        default:
            return FFI_MARSHAL_DIRECT;
    }
}

static FFIMarshalingType ffi_determine_return_marshaling_type(FFIAssemblyGenerator *generator, ASTNode *call) {
    if (!generator || !call) return FFI_MARSHAL_DIRECT;
    
    // Check if the call has type information for return type
    if (!call->type_info) {
        return FFI_MARSHAL_DIRECT;
    }
    
    // Use type information for precise marshaling
    switch (call->type_info->base_type) {
        case ASTHRA_TYPE_STRING:
            return FFI_MARSHAL_STRING;
        case ASTHRA_TYPE_SLICE:
            return FFI_MARSHAL_SLICE;
        case ASTHRA_TYPE_RESULT:
            return FFI_MARSHAL_RESULT;
        default:
            return FFI_MARSHAL_DIRECT;
    }
}

static PatternMatchStrategy ffi_determine_pattern_strategy(FFIAssemblyGenerator *generator, PatternMatchContext *context) {
    if (!generator || !context) return PATTERN_STRATEGY_LINEAR;
    
    // Analyze pattern characteristics for optimal strategy
    if (context->arm_count <= 2) {
        return PATTERN_STRATEGY_LINEAR;
    }
    
    // Check if patterns are suitable for jump table
    bool all_integer_patterns = true;
    for (size_t i = 0; i < context->arm_count; i++) {
        if (!context->arms[i].is_result_ok && !context->arms[i].is_result_err) {
            all_integer_patterns = false;
            break;
        }
    }
    
    if (all_integer_patterns && context->arm_count <= 8) {
        return PATTERN_STRATEGY_JUMP_TABLE;
    }
    
    if (context->arm_count > 8) {
        return PATTERN_STRATEGY_BINARY_SEARCH;
    }
    
    return PATTERN_STRATEGY_LINEAR;
}

static bool ffi_generate_linear_pattern_match(FFIAssemblyGenerator *generator, PatternMatchContext *context) {
    if (!generator || !context) return false;
    
    emit_comment(generator, "Linear pattern matching");
    
    // Generate linear comparison chain
    for (size_t i = 0; i < context->arm_count; i++) {
        // Generate comparison for this pattern
        if (context->arms[i].is_result_ok) {
            emit_instruction(generator, INST_CMP, 2,
                            create_register_operand(context->match_value_reg),
                            create_immediate_operand(0)); // Ok tag = 0
            emit_instruction(generator, INST_JE, 1,
                            create_label_operand(context->arms[i].body_label));
        } else if (context->arms[i].is_result_err) {
            emit_instruction(generator, INST_CMP, 2,
                            create_register_operand(context->match_value_reg),
                            create_immediate_operand(1)); // Err tag = 1
            emit_instruction(generator, INST_JE, 1,
                            create_label_operand(context->arms[i].body_label));
        }
    }
    
    // Generate default case if no match
    if (context->has_default_arm) {
        for (size_t i = 0; i < context->arm_count; i++) {
            if (context->arms[i].is_default) {
                emit_instruction(generator, INST_JMP, 1,
                                create_label_operand(context->arms[i].body_label));
                break;
            }
        }
    }
    
    return true;
}

static bool ffi_marshal_slice_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg) {
    if (!generator || !param) return false;
    
    emit_comment(generator, "Marshal slice parameter to pointer+length");
    
    // Allocate registers for slice components
    Register slice_reg = register_allocate(generator->base_generator->register_allocator, true);
    Register ptr_reg = register_allocate(generator->base_generator->register_allocator, true);
    Register len_reg = register_allocate(generator->base_generator->register_allocator, true);
    
    if (slice_reg == REG_NONE || ptr_reg == REG_NONE || len_reg == REG_NONE) {
        if (slice_reg != REG_NONE) register_free(generator->base_generator->register_allocator, slice_reg);
        if (ptr_reg != REG_NONE) register_free(generator->base_generator->register_allocator, ptr_reg);
        if (len_reg != REG_NONE) register_free(generator->base_generator->register_allocator, len_reg);
        return false;
    }
    
    // Generate code to load the slice
    if (!code_generate_expression(generator->base_generator, param, slice_reg)) {
        register_free(generator->base_generator->register_allocator, slice_reg);
        register_free(generator->base_generator->register_allocator, ptr_reg);
        register_free(generator->base_generator->register_allocator, len_reg);
        return false;
    }
    
    // Extract pointer from slice (offset 0)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(ptr_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 0));
    
    // Extract length from slice (offset 8)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(len_reg),
                    create_memory_operand(slice_reg, REG_NONE, 1, 8));
    
    // Move pointer to target register (first parameter)
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(target_reg),
                    create_register_operand(ptr_reg));
    
    // Length will be passed in the next parameter register
    // This is handled by the calling function
    
    // Cleanup
    register_free(generator->base_generator->register_allocator, slice_reg);
    register_free(generator->base_generator->register_allocator, ptr_reg);
    register_free(generator->base_generator->register_allocator, len_reg);
    
    return true;
}

static bool ffi_marshal_string_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg) {
    if (!generator || !param) return false;
    
    emit_comment(generator, "Marshal string parameter to C string");
    
    // Allocate register for string
    Register string_reg = register_allocate(generator->base_generator->register_allocator, true);
    if (string_reg == REG_NONE) return false;
    
    // Generate code to load the string
    if (!code_generate_expression(generator->base_generator, param, string_reg)) {
        register_free(generator->base_generator->register_allocator, string_reg);
        return false;
    }
    
    // Call runtime function to convert Asthra string to C string
    // Set up parameter for runtime call
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(REG_RDI),
                    create_register_operand(string_reg));
    
    // Call asthra_string_to_cstr
    emit_instruction(generator, INST_CALL, 1,
                    create_label_operand("asthra_string_to_cstr"));
    
    // Move result to target register
    if (target_reg != REG_RAX) {
        emit_instruction(generator, INST_MOV, 2,
                        create_register_operand(target_reg),
                        create_register_operand(REG_RAX));
    }
    
    register_free(generator->base_generator->register_allocator, string_reg);
    return true;
}

static bool ffi_marshal_result_parameter(FFIAssemblyGenerator *generator, ASTNode *param, Register target_reg) {
    if (!generator || !param) return false;
    
    emit_comment(generator, "Marshal Result<T,E> parameter");
    
    // Allocate register for result
    Register result_reg = register_allocate(generator->base_generator->register_allocator, true);
    if (result_reg == REG_NONE) return false;
    
    // Generate code to load the result
    if (!code_generate_expression(generator->base_generator, param, result_reg)) {
        register_free(generator->base_generator->register_allocator, result_reg);
        return false;
    }
    
    // Result types are passed as tagged unions
    // For FFI, we might need to convert to a specific C representation
    // For now, pass the result structure directly
    emit_instruction(generator, INST_MOV, 2,
                    create_register_operand(target_reg),
                    create_register_operand(result_reg));
    
    register_free(generator->base_generator->register_allocator, result_reg);
    return true;
}

static bool ffi_generate_secure_operation(FFIAssemblyGenerator *generator, ASTNode *operation, SecurityContext *context) {
    if (!generator || !operation) return false;
    
    // Check if security features are enabled
    if (!generator->config.enable_security_features) {
        // Fall back to normal code generation
        return code_generate_statement(generator->base_generator, operation);
    }
    
    emit_comment(generator, "Secure operation with constant-time guarantees");
    
    // Generate secure code based on context
    if (context && context->operation == SECURITY_OP_CONSTANT_TIME) {
        // Implement constant-time operation
        emit_comment(generator, "Constant-time operation");
        
        // Disable branch prediction optimizations
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_disable_branch_prediction"));
        
        // Generate the operation
        bool result = code_generate_statement(generator->base_generator, operation);
        
        // Re-enable optimizations
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_enable_branch_prediction"));
        
        return result;
    }
    
    if (context && context->operation == SECURITY_OP_VOLATILE_MEMORY) {
        // Implement volatile memory access
        emit_comment(generator, "Volatile memory access");
        
        // Use memory barriers
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_memory_barrier"));
        
        bool result = code_generate_statement(generator->base_generator, operation);
        
        emit_instruction(generator, INST_CALL, 1,
                        create_label_operand("asthra_memory_barrier"));
        
        return result;
    }
    
    // Default secure operation
    return code_generate_statement(generator->base_generator, operation);
}

static bool ffi_generate_function_declaration(FFIAssemblyGenerator *generator, ASTNode *decl) {
    if (!generator || !decl || decl->type != AST_FUNCTION_DECL) return false;
    
    // Generate function using base code generator
    return code_generate_function(generator->base_generator, decl);
}

static bool ffi_generate_extern_declaration(FFIAssemblyGenerator *generator, ASTNode *decl) {
    if (!generator || !decl || decl->type != AST_EXTERN_DECL) return false;
    
    emit_comment(generator, "External function declaration");
    
    // Extract extern declaration information
    const char *function_name = decl->data.extern_decl.name;
    const char *extern_name = decl->data.extern_decl.extern_name;
    
    if (!function_name) return false;
    
    // Generate external symbol reference
    char comment_buffer[256];
    if (extern_name) {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "External function: %s from %s", function_name, extern_name);
    } else {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "External function: %s", function_name);
    }
    emit_comment(generator, comment_buffer);
    
    // For extern declarations, we don't generate code, just metadata
    // The actual linking is handled by the linker
    
    return true;
}

static bool ffi_generate_struct_declaration(FFIAssemblyGenerator *generator, ASTNode *decl) {
    if (!generator || !decl || decl->type != AST_STRUCT_DECL) return false;
    
    emit_comment(generator, "Struct declaration");
    
    // For struct declarations, we don't generate assembly code
    // The struct layout is handled during semantic analysis
    // However, we can emit metadata for debugging
    
    const char *struct_name = decl->data.struct_decl.name;
    if (struct_name) {
        char comment_buffer[256];
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Struct: %s", struct_name);
        emit_comment(generator, comment_buffer);
    }
    
    return true;
}

bool ffi_generate_module_declaration(FFIAssemblyGenerator *generator, ASTNode *decl) {
    if (!generator || !decl || decl->type != AST_MODULE_DECL) return false;
    
    const char *module_name = decl->data.module_decl.name;
    ASTNodeList *items = decl->data.module_decl.items;
    bool is_file_module = decl->data.module_decl.is_file_module;
    
    if (!module_name) {
        return false;
    }
    
    // Emit module start comment
    char comment_buffer[256];
    if (is_file_module) {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "File-based module: %s", module_name);
    } else {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Inline module: %s", module_name);
    }
    emit_comment(generator, comment_buffer);
    
    // For file-based modules, we don't process items here
    // They are processed when the file is compiled separately
    if (is_file_module) {
        return true;
    }
    
    // For inline modules, process all items
    if (items) {
        for (size_t i = 0; i < items->count; i++) {
            ASTNode *item = items->nodes[i];
            if (!item) continue;
            
            switch (item->type) {
                case AST_FUNCTION_DECL:
                    if (!ffi_generate_function_declaration(generator, item)) {
                        return false;
                    }
                    break;
                    
                case AST_EXTERN_DECL:
                    if (!ffi_generate_extern_declaration(generator, item)) {
                        return false;
                    }
                    break;
                    
                case AST_STRUCT_DECL:
                    if (!ffi_generate_struct_declaration(generator, item)) {
                        return false;
                    }
                    break;
                    
                default:
                    // Skip other item types
                    break;
            }
        }
    }
    
    snprintf(comment_buffer, sizeof(comment_buffer), 
            "End module: %s", module_name);
    emit_comment(generator, comment_buffer);
    
    return true;
}

bool ffi_generate_use_declaration(FFIAssemblyGenerator *generator, ASTNode *decl) {
    if (!generator || !decl || decl->type != AST_USE_DECL) return false;
    
    const char *path = decl->data.use_decl.path;
    const char *alias = decl->data.use_decl.alias;
    ASTNodeList *items = decl->data.use_decl.items;
    bool is_glob_import = decl->data.use_decl.is_glob_import;
    
    if (!path) {
        return false;
    }
    
    // Emit use declaration comment
    char comment_buffer[512];
    if (alias) {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Use declaration: %s as %s", path, alias);
    } else if (is_glob_import) {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Use declaration: %s (glob import)", path);
    } else if (items && items->count > 0) {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Use declaration: %s (selective import)", path);
    } else {
        snprintf(comment_buffer, sizeof(comment_buffer), 
                "Use declaration: %s", path);
    }
    emit_comment(generator, comment_buffer);
    
    // Use declarations don't generate assembly code
    // They are handled during semantic analysis and linking
    
    return true;
} 

// Implementation of advanced concurrency code generation functions

bool ffi_generate_spawn_with_handle_statement(FFIAssemblyGenerator *generator, ASTNode *spawn_stmt) {
    if (!generator || !spawn_stmt) {
        return false;
    }
    
    // Set up concurrency context
    ConcurrencyContext context = {
        .operation = CONCURRENCY_OP_SPAWN_WITH_HANDLE,
        .scheduler_spawn_function = (char*)"asthra_spawn_with_handle"
    };
    
    generator->current_concurrency_op = &context;
    
    // For now, use a placeholder implementation
    emit_comment(generator, "spawn_with_handle statement");
    
    return true;
}

bool ffi_generate_channel_declaration(FFIAssemblyGenerator *generator, ASTNode *channel_decl) {
    if (!generator || !channel_decl) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "channel declaration");
    
    return true;
}

bool ffi_generate_send_statement(FFIAssemblyGenerator *generator, ASTNode *send_stmt) {
    if (!generator || !send_stmt) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "send statement");
    
    return true;
}

bool ffi_generate_recv_expression(FFIAssemblyGenerator *generator, ASTNode *recv_expr, Register result_reg) {
    if (!generator || !recv_expr) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "recv expression");
    
    return true;
}

bool ffi_generate_select_statement(FFIAssemblyGenerator *generator, ASTNode *select_stmt) {
    if (!generator || !select_stmt) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "select statement");
    
    return true;
}

bool ffi_generate_worker_pool_declaration(FFIAssemblyGenerator *generator, ASTNode *worker_pool_decl) {
    if (!generator || !worker_pool_decl) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "worker pool declaration");
    
    return true;
}

bool ffi_generate_close_statement(FFIAssemblyGenerator *generator, ASTNode *close_stmt) {
    if (!generator || !close_stmt) {
        return false;
    }
    
    // For now, use a placeholder implementation
    emit_comment(generator, "close statement");
    
    return true;
}

// Helper functions for channel operations

bool ffi_generate_channel_send(FFIAssemblyGenerator *generator, Register channel_reg, Register value_reg) {
    if (!generator) return false;
    
    // For now, use a placeholder implementation
    emit_comment(generator, "channel send operation");
    
    return true;
}

bool ffi_generate_channel_recv(FFIAssemblyGenerator *generator, Register channel_reg, Register result_reg, ASTNode *timeout_expr) {
    if (!generator) return false;
    
    // For now, use a placeholder implementation
    emit_comment(generator, "channel recv operation");
    
    return true;
}
