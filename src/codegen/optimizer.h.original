/**
 * Asthra Programming Language Compiler
 * Optimization Pass System with C17 Modernization
 * 
 * Copyright (c) 2024 Asthra Project
 * Licensed under the terms specified in LICENSE
 * 
 * Phase 3.2 Enhancements:
 * - C17 _Generic for polymorphic optimization operations
 * - Atomic operations for thread-safe optimization statistics
 * - _Static_assert for optimization assumptions validation
 * - Memory ordering for optimization data structures
 */

#ifndef ASTHRA_OPTIMIZER_H
#define ASTHRA_OPTIMIZER_H

#include "code_generator.h"
#include "../analysis/semantic_analyzer.h"
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdatomic.h>
#include <pthread.h>

#ifdef __cplusplus
extern "C" {
#endif

// C17 static assertions for optimization assumptions
_Static_assert(sizeof(size_t) >= sizeof(uint32_t), "size_t must be at least 32-bit for optimization data structures");
_Static_assert(__STDC_VERSION__ >= 201710L, "C17 standard required for optimization modernization");
_Static_assert(sizeof(atomic_uint_fast64_t) >= sizeof(uint64_t), "Atomic types must support 64-bit counters");

// Forward declarations
typedef struct Optimizer Optimizer;
typedef struct OptimizationPass OptimizationPass;
typedef struct DataFlowAnalysis DataFlowAnalysis;
typedef struct OptimizationStatistics OptimizationStatistics;
typedef struct BasicBlock BasicBlock;
typedef struct ControlFlowGraph ControlFlowGraph;

// =============================================================================
// OPTIMIZATION PASS TYPES AND CONFIGURATION
// =============================================================================

// Optimization pass types
typedef enum {
    OPT_PASS_DEAD_CODE_ELIMINATION,
    OPT_PASS_CONSTANT_FOLDING,
    OPT_PASS_CONSTANT_PROPAGATION,
    OPT_PASS_COPY_PROPAGATION,
    OPT_PASS_COMMON_SUBEXPRESSION_ELIMINATION,
    OPT_PASS_LOOP_INVARIANT_CODE_MOTION,
    OPT_PASS_STRENGTH_REDUCTION,
    OPT_PASS_REGISTER_COALESCING,
    OPT_PASS_INSTRUCTION_SCHEDULING,
    OPT_PASS_PEEPHOLE_OPTIMIZATION,
    OPT_PASS_TAIL_CALL_OPTIMIZATION,
    OPT_PASS_INLINING,
    OPT_PASS_COUNT
} OptimizationPassType;

// C17 static assertion for optimization pass enum
_Static_assert(OPT_PASS_COUNT <= 32, "Optimization passes must fit in 32-bit bitmask");

// Optimization levels
typedef enum {
    OPT_LEVEL_NONE = 0,     // -O0: No optimization
    OPT_LEVEL_BASIC = 1,    // -O1: Basic optimizations
    OPT_LEVEL_STANDARD = 2, // -O2: Standard optimizations
    OPT_LEVEL_AGGRESSIVE = 3, // -O3: Aggressive optimizations
    OPT_LEVEL_SIZE = 4,     // -Os: Size optimizations
    OPT_LEVEL_COUNT
} OptimizationLevel;

// Optimization pass configuration with C17 designated initializers
typedef struct {
    OptimizationPassType type;
    bool enabled;
    uint32_t priority;  // Lower numbers run first
    uint32_t max_iterations;
    
    // Pass-specific configuration
    union {
        struct {
            bool remove_unreachable_code;
            bool remove_unused_variables;
            bool remove_empty_blocks;
        } dead_code;
        
        struct {
            bool fold_arithmetic;
            bool fold_comparisons;
            bool fold_logical;
            bool fold_bitwise;
        } constant_folding;
        
        struct {
            bool propagate_constants;
            bool propagate_copies;
            size_t max_propagation_distance;
        } propagation;
        
        struct {
            bool enable_global_cse;
            bool enable_local_cse;
            size_t hash_table_size;
        } cse;
    } config;
} OptimizationPassConfig;

// =============================================================================
// DATA FLOW ANALYSIS WITH C17 ATOMIC OPERATIONS
// =============================================================================

// Data flow analysis types
typedef enum {
    DATAFLOW_REACHING_DEFINITIONS,
    DATAFLOW_LIVE_VARIABLES,
    DATAFLOW_AVAILABLE_EXPRESSIONS,
    DATAFLOW_VERY_BUSY_EXPRESSIONS,
    DATAFLOW_DOMINANCE,
    DATAFLOW_POST_DOMINANCE,
    DATAFLOW_COUNT
} DataFlowAnalysisType;

// Bit vector for data flow analysis
typedef struct {
    uint64_t *bits;
    size_t size;  // Number of bits
    size_t word_count;  // Number of 64-bit words
} BitVector;

// Data flow analysis results with atomic reference counting
struct DataFlowAnalysis {
    DataFlowAnalysisType type;
    ControlFlowGraph *cfg;
    
    // Analysis results
    BitVector **in_sets;   // Input sets for each basic block
    BitVector **out_sets;  // Output sets for each basic block
    BitVector **gen_sets;  // Generated sets for each basic block
    BitVector **kill_sets; // Killed sets for each basic block
    
    // C17 atomic reference counting for thread-safe sharing
    atomic_uint_fast32_t ref_count;
    
    // Analysis statistics with memory ordering
    atomic_uint_fast32_t iterations_performed;
    atomic_uint_fast64_t analysis_time_ns;
    
    // Thread safety
    pthread_rwlock_t rwlock;
};

// =============================================================================
// BASIC BLOCK AND CONTROL FLOW GRAPH
// =============================================================================

// Basic block representation
struct BasicBlock {
    uint32_t id;
    char *label;
    
    // Instructions in this block
    AssemblyInstruction **instructions;
    size_t instruction_count;
    size_t instruction_capacity;
    
    // Control flow
    BasicBlock **predecessors;
    BasicBlock **successors;
    size_t predecessor_count;
    size_t successor_count;
    
    // Data flow analysis sets
    BitVector *def_set;    // Definitions in this block
    BitVector *use_set;    // Uses in this block
    BitVector *live_in;    // Live variables at block entry
    BitVector *live_out;   // Live variables at block exit
    
    // Optimization flags
    struct {
        bool is_loop_header : 1;
        bool is_loop_exit : 1;
        bool is_unreachable : 1;
        bool has_side_effects : 1;
        bool is_critical_edge : 1;
        uint8_t reserved : 3;
    } flags;
};

// Control flow graph with C17 atomic operations
struct ControlFlowGraph {
    BasicBlock **blocks;
    size_t block_count;
    size_t block_capacity;
    
    BasicBlock *entry_block;
    BasicBlock *exit_block;
    
    // Graph properties with atomic updates
    atomic_uint_fast32_t next_block_id;
    atomic_bool is_reducible;
    atomic_uint_fast32_t loop_count;
    
    // Thread safety
    pthread_mutex_t mutex;
};

// =============================================================================
// OPTIMIZATION STATISTICS WITH ATOMIC OPERATIONS
// =============================================================================

struct OptimizationStatistics {
    // Pass execution statistics
    atomic_uint_fast64_t passes_executed;
    atomic_uint_fast64_t total_optimization_time_ns;
    atomic_uint_fast32_t iterations_performed;
    
    // Transformation statistics
    atomic_uint_fast32_t instructions_eliminated;
    atomic_uint_fast32_t constants_folded;
    atomic_uint_fast32_t copies_propagated;
    atomic_uint_fast32_t common_subexpressions_eliminated;
    atomic_uint_fast32_t dead_stores_eliminated;
    atomic_uint_fast32_t unreachable_blocks_removed;
    
    // Code size statistics
    atomic_uint_fast64_t original_instruction_count;
    atomic_uint_fast64_t optimized_instruction_count;
    atomic_uint_fast64_t code_size_reduction_bytes;
    
    // Performance statistics
    atomic_uint_fast32_t register_pressure_reduced;
    atomic_uint_fast32_t memory_accesses_eliminated;
    atomic_uint_fast32_t branches_eliminated;
    atomic_uint_fast32_t function_calls_inlined;
    
    // Analysis statistics
    atomic_uint_fast32_t dataflow_analyses_performed;
    atomic_uint_fast64_t dataflow_analysis_time_ns;
    atomic_uint_fast32_t cfg_constructions;
};

// =============================================================================
// MAIN OPTIMIZER STRUCTURE
// =============================================================================

struct Optimizer {
    // Target configuration
    OptimizationLevel level;
    uint32_t enabled_passes;  // Bitmask of enabled passes
    bool debug_mode;
    bool verify_optimizations;
    
    // Core components
    CodeGenerator *code_generator;
    SemanticAnalyzer *semantic_analyzer;
    ControlFlowGraph *cfg;
    
    // Optimization passes
    OptimizationPassConfig *pass_configs;
    size_t pass_count;
    
    // Data flow analyses
    DataFlowAnalysis **analyses;
    size_t analysis_count;
    
    // Statistics
    OptimizationStatistics stats;
    
    // Configuration
    struct {
        size_t max_iterations;
        size_t max_inlining_depth;
        size_t max_unroll_factor;
        bool preserve_debug_info;
        bool aggressive_dead_code_elimination;
        bool enable_interprocedural_optimization;
    } config;
};

// =============================================================================
// C17 GENERIC MACROS FOR TYPE-SAFE OPTIMIZATION OPERATIONS
// =============================================================================

// Type-safe optimization dispatch using C17 _Generic
#define optimize_instruction(optimizer, instruction) _Generic((instruction), \
    AssemblyInstruction*: optimize_instruction_impl, \
    const AssemblyInstruction*: optimize_instruction_const_impl \
)(optimizer, instruction)

#define optimize_basic_block(optimizer, block) _Generic((block), \
    BasicBlock*: optimize_basic_block_impl, \
    const BasicBlock*: optimize_basic_block_const_impl \
)(optimizer, block)

#define analyze_data_flow(cfg, type) _Generic((type), \
    DataFlowAnalysisType: analyze_data_flow_impl, \
    default: analyze_data_flow_impl \
)(cfg, type)

// Type-safe bit vector operations
#define bitvector_operation(vec1, vec2, op) _Generic((op), \
    int: bitvector_union, \
    default: bitvector_union \
)(vec1, vec2)

// Type-safe optimization pass configuration
#define configure_optimization_pass(type, config) _Generic((type), \
    OptimizationPassType: configure_optimization_pass_impl, \
    default: configure_optimization_pass_impl \
)(type, config)

// =============================================================================
// OPTIMIZER INTERFACE
// =============================================================================

// Creation and destruction
Optimizer *optimizer_create(OptimizationLevel level);
void optimizer_destroy(Optimizer *optimizer);
void optimizer_reset(Optimizer *optimizer);

// Configuration
bool optimizer_set_level(Optimizer *optimizer, OptimizationLevel level);
bool optimizer_enable_pass(Optimizer *optimizer, OptimizationPassType pass);
bool optimizer_disable_pass(Optimizer *optimizer, OptimizationPassType pass);
bool optimizer_configure_pass(Optimizer *optimizer, OptimizationPassType pass, 
                             const OptimizationPassConfig *config);

// Main optimization entry points
bool optimizer_optimize_program(Optimizer *optimizer, ASTNode *program);
bool optimizer_optimize_function(Optimizer *optimizer, ASTNode *function);
bool optimizer_optimize_instructions(Optimizer *optimizer, 
                                    AssemblyInstruction **instructions, 
                                    size_t instruction_count);

// =============================================================================
// CONTROL FLOW GRAPH OPERATIONS
// =============================================================================

ControlFlowGraph *cfg_create(void);
void cfg_destroy(ControlFlowGraph *cfg);

// Basic block management
BasicBlock *cfg_create_basic_block(ControlFlowGraph *cfg, const char *label);
bool cfg_add_edge(ControlFlowGraph *cfg, BasicBlock *from, BasicBlock *to);
bool cfg_remove_edge(ControlFlowGraph *cfg, BasicBlock *from, BasicBlock *to);
bool cfg_remove_basic_block(ControlFlowGraph *cfg, BasicBlock *block);

// CFG construction from instructions
bool cfg_build_from_instructions(ControlFlowGraph *cfg, 
                                AssemblyInstruction **instructions, 
                                size_t instruction_count);

// CFG analysis
bool cfg_compute_dominance(ControlFlowGraph *cfg);
bool cfg_compute_post_dominance(ControlFlowGraph *cfg);
bool cfg_detect_loops(ControlFlowGraph *cfg);
bool cfg_is_reducible(ControlFlowGraph *cfg);

// =============================================================================
// DATA FLOW ANALYSIS OPERATIONS
// =============================================================================

DataFlowAnalysis *dataflow_create(DataFlowAnalysisType type, ControlFlowGraph *cfg);
void dataflow_destroy(DataFlowAnalysis *analysis);

// Reference counting with atomic operations
void dataflow_retain(DataFlowAnalysis *analysis);
void dataflow_release(DataFlowAnalysis *analysis);

// Analysis execution
bool dataflow_analyze(DataFlowAnalysis *analysis);
bool dataflow_is_converged(DataFlowAnalysis *analysis);
uint32_t dataflow_get_iteration_count(DataFlowAnalysis *analysis);

// Specific analyses
DataFlowAnalysis *dataflow_reaching_definitions(ControlFlowGraph *cfg);
DataFlowAnalysis *dataflow_live_variables(ControlFlowGraph *cfg);
DataFlowAnalysis *dataflow_available_expressions(ControlFlowGraph *cfg);

// =============================================================================
// BIT VECTOR OPERATIONS
// =============================================================================

BitVector *bitvector_create(size_t size);
void bitvector_destroy(BitVector *vec);
BitVector *bitvector_clone(const BitVector *vec);

// Bit operations
bool bitvector_set(BitVector *vec, size_t bit);
bool bitvector_clear(BitVector *vec, size_t bit);
bool bitvector_test(const BitVector *vec, size_t bit);
void bitvector_clear_all(BitVector *vec);
void bitvector_set_all(BitVector *vec);

// Set operations
bool bitvector_union(BitVector *dest, const BitVector *src);
bool bitvector_intersection(BitVector *dest, const BitVector *src);
bool bitvector_difference(BitVector *dest, const BitVector *src);
bool bitvector_equals(const BitVector *vec1, const BitVector *vec2);

// =============================================================================
// OPTIMIZATION PASS IMPLEMENTATIONS
// =============================================================================

// Dead code elimination
bool opt_dead_code_elimination(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_remove_unreachable_blocks(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_remove_unused_variables(Optimizer *optimizer, ControlFlowGraph *cfg);

// Constant folding and propagation
bool opt_constant_folding(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_constant_propagation(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_copy_propagation(Optimizer *optimizer, ControlFlowGraph *cfg);

// Common subexpression elimination
bool opt_common_subexpression_elimination(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_local_cse(Optimizer *optimizer, BasicBlock *block);
bool opt_global_cse(Optimizer *optimizer, ControlFlowGraph *cfg);

// Loop optimizations
bool opt_loop_invariant_code_motion(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_strength_reduction(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_loop_unrolling(Optimizer *optimizer, ControlFlowGraph *cfg);

// Register and instruction optimizations
bool opt_register_coalescing(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_instruction_scheduling(Optimizer *optimizer, ControlFlowGraph *cfg);
bool opt_peephole_optimization(Optimizer *optimizer, ControlFlowGraph *cfg);

// Function optimizations
bool opt_function_inlining(Optimizer *optimizer, ASTNode *program);
bool opt_tail_call_optimization(Optimizer *optimizer, ControlFlowGraph *cfg);

// =============================================================================
// OPTIMIZATION VERIFICATION AND DEBUGGING
// =============================================================================

// Verification
bool optimizer_verify_correctness(Optimizer *optimizer, ControlFlowGraph *original, 
                                 ControlFlowGraph *optimized);
bool optimizer_verify_cfg_integrity(ControlFlowGraph *cfg);
bool optimizer_verify_dataflow_results(DataFlowAnalysis *analysis);

// Debugging and diagnostics
void optimizer_print_cfg(const ControlFlowGraph *cfg);
void optimizer_print_basic_block(const BasicBlock *block);
void optimizer_print_dataflow_results(const DataFlowAnalysis *analysis);
void optimizer_dump_optimization_log(const Optimizer *optimizer, const char *filename);

// =============================================================================
// STATISTICS AND PROFILING
// =============================================================================

OptimizationStatistics optimizer_get_statistics(const Optimizer *optimizer);
void optimizer_reset_statistics(Optimizer *optimizer);
void optimizer_print_statistics(const Optimizer *optimizer);

// Performance profiling
void optimizer_start_profiling(Optimizer *optimizer);
void optimizer_stop_profiling(Optimizer *optimizer);
double optimizer_get_optimization_time(const Optimizer *optimizer);

// Pass-specific statistics
uint32_t optimizer_get_pass_execution_count(const Optimizer *optimizer, OptimizationPassType pass);
double optimizer_get_pass_execution_time(const Optimizer *optimizer, OptimizationPassType pass);

// =============================================================================
// IMPLEMENTATION FUNCTIONS FOR _Generic MACROS
// =============================================================================

// Implementation functions (not for direct use)
bool optimize_instruction_impl(Optimizer *optimizer, AssemblyInstruction *instruction);
bool optimize_instruction_const_impl(Optimizer *optimizer, const AssemblyInstruction *instruction);

bool optimize_basic_block_impl(Optimizer *optimizer, BasicBlock *block);
bool optimize_basic_block_const_impl(Optimizer *optimizer, const BasicBlock *block);

DataFlowAnalysis *analyze_data_flow_impl(ControlFlowGraph *cfg, DataFlowAnalysisType type);

bool configure_optimization_pass_impl(OptimizationPassType type, const OptimizationPassConfig *config);

// =============================================================================
// ERROR HANDLING
// =============================================================================

// Optimization error codes
typedef enum {
    OPT_ERROR_NONE = 0,
    OPT_ERROR_OUT_OF_MEMORY,
    OPT_ERROR_INVALID_CFG,
    OPT_ERROR_DATAFLOW_FAILED,
    OPT_ERROR_PASS_FAILED,
    OPT_ERROR_VERIFICATION_FAILED,
    OPT_ERROR_INFINITE_LOOP,
    OPT_ERROR_UNSUPPORTED_OPERATION,
    OPT_ERROR_COUNT
} OptimizationErrorCode;

// Error reporting
void optimizer_report_error(Optimizer *optimizer, OptimizationErrorCode code, 
                           const char *format, ...);
const char *optimizer_error_name(OptimizationErrorCode code);

#ifdef __cplusplus
}
#endif

#endif // ASTHRA_OPTIMIZER_H 
