/**
 * Asthra Programming Language C Backend
 * Transpiles Asthra AST to C code
 * 
 * Copyright (c) 2024 Asthra Project
 * Licensed under the terms specified in LICENSE
 */

#include "backend_interface.h"
#include "../compiler/code_generation.h"
#include "../parser/ast_types.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Private data for C backend
typedef struct CBackendData {
    FILE *output_file;
    char *temp_filename;
    bool include_runtime;
    size_t lines_written;
    size_t functions_count;
} CBackendData;

// Initialize the C backend
static int c_backend_initialize(AsthraBackend *backend, const AsthraCompilerOptions *options) {
    if (!backend || !options) return -1;
    
    // Allocate private data
    CBackendData *data = calloc(1, sizeof(CBackendData));
    if (!data) {
        backend->last_error = "Failed to allocate backend data";
        return -1;
    }
    
    // Store options
    backend->options.optimization_level = options->opt_level;
    backend->options.debug_info = options->debug_info;
    backend->options.verbose = options->verbose;
    backend->options.target_arch = options->target_arch;
    
    // Determine if we need runtime includes
    data->include_runtime = !options->no_stdlib;
    
    backend->private_data = data;
    return 0;
}

// Generate C code from AST
static int c_backend_generate(AsthraBackend *backend, 
                             AsthraCompilerContext *ctx,
                             const ASTNode *ast,
                             const char *output_file) {
    if (!backend || !ctx || !ast) return -1;
    
    CBackendData *data = (CBackendData*)backend->private_data;
    if (!data) {
        backend->last_error = "Backend not initialized";
        return -1;
    }
    
    // Track generation time
    clock_t start_time = clock();
    
    // Open output file
    FILE *fp = stdout;
    if (output_file && strcmp(output_file, "-") != 0) {
        fp = fopen(output_file, "w");
        if (!fp) {
            backend->last_error = "Failed to open output file";
            return -1;
        }
        data->temp_filename = strdup(output_file);
    }
    data->output_file = fp;
    
    // Generate standard C headers
    fprintf(fp, "// Generated by Asthra C Backend\n");
    fprintf(fp, "// Asthra version: %s\n\n", asthra_compiler_get_version());
    
    fprintf(fp, "#include <stdio.h>\n");
    fprintf(fp, "#include <stdlib.h>\n");
    fprintf(fp, "#include <string.h>\n");
    fprintf(fp, "#include <stdbool.h>\n");
    fprintf(fp, "#include <stdint.h>\n");
    
    // Include runtime headers if needed
    if (data->include_runtime) {
        fprintf(fp, "\n// Asthra Runtime Headers (stub for now)\n");
        fprintf(fp, "typedef struct AsthraSliceHeader {\n");
        fprintf(fp, "    void *ptr;\n");
        fprintf(fp, "    size_t len;\n");
        fprintf(fp, "    size_t cap;\n");
        fprintf(fp, "    size_t element_size;\n");
        fprintf(fp, "    int ownership;\n");
        fprintf(fp, "    int is_mutable;\n");
        fprintf(fp, "    int type_id;\n");
        fprintf(fp, "} AsthraSliceHeader;\n");
        fprintf(fp, "#define ASTHRA_OWNERSHIP_GC 1\n");
    }
    
    fprintf(fp, "\n");
    data->lines_written += 20; // Approximate header lines
    
    // Use existing code generation function
    // Cast away const for compatibility with existing function
    int result = generate_c_code(fp, (ASTNode*)ast);
    
    // Close file if not stdout
    if (fp != stdout) {
        fclose(fp);
    }
    
    // Update statistics
    backend->stats.lines_generated = data->lines_written;
    backend->stats.functions_processed = data->functions_count;
    backend->stats.generation_time = ((double)(clock() - start_time)) / CLOCKS_PER_SEC;
    
    return result;
}

// Optimize C code (minimal for C backend)
static int c_backend_optimize(AsthraBackend *backend, void *ir, int opt_level) {
    // C backend doesn't perform optimizations directly
    // The C compiler will handle optimizations
    return 0;
}

// Cleanup C backend
static void c_backend_cleanup(AsthraBackend *backend) {
    if (!backend || !backend->private_data) return;
    
    CBackendData *data = (CBackendData*)backend->private_data;
    
    if (data->temp_filename) {
        free(data->temp_filename);
    }
    
    free(data);
    backend->private_data = NULL;
}

// Check if C backend supports a feature
static bool c_backend_supports_feature(AsthraBackend *backend, const char *feature) {
    if (!feature) return false;
    
    // List of supported features
    const char *supported[] = {
        "functions",
        "expressions",
        "statements",
        "types",
        "string_literals",
        "integer_literals",
        "float_literals",
        "boolean_literals",
        "arithmetic",
        "comparisons",
        "logical_operations",
        "if_statements",
        "while_loops",
        "for_loops",
        "return_statements",
        "blocks",
        "function_calls",
        "builtin_log",
        "builtin_panic",
        NULL
    };
    
    for (int i = 0; supported[i]; i++) {
        if (strcmp(feature, supported[i]) == 0) {
            return true;
        }
    }
    
    return false;
}

// Get backend version
static const char* c_backend_get_version(AsthraBackend *backend) {
    return "1.0.0";
}

// Get backend name
static const char* c_backend_get_name(AsthraBackend *backend) {
    return "Asthra C Transpiler Backend";
}

// C Backend operations structure
const AsthraBackendOps c_backend_ops = {
    .initialize = c_backend_initialize,
    .generate = c_backend_generate,
    .optimize = c_backend_optimize,
    .cleanup = c_backend_cleanup,
    .supports_feature = c_backend_supports_feature,
    .get_version = c_backend_get_version,
    .get_name = c_backend_get_name
};