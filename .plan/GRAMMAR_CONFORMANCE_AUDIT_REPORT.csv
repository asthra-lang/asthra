File Path,Line Number,Violation Type,Priority,Description,Line Content,Suggested Fix
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_19.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn go_style() -> Result<(), string> {","pub fn go_style(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_17.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn potential_deadlock() -> Result<(), string> {","pub fn potential_deadlock(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_17.asthra,12,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn safe_channels() -> Result<(), string> {","pub fn safe_channels(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_4.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn robust_parallel_work() -> Result<Vec<i32>, string> {","pub fn robust_parallel_work(none) -> Result<Vec<i32>, string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_8.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn multi_producer_pattern() -> Result<Vec<WorkResult>, string> {","pub fn multi_producer_pattern(none) -> Result<Vec<WorkResult>, string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_13.asthra,6,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn resource_managed_channels() -> Result<(), string> {","pub fn resource_managed_channels(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_6.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn tier2_function() -> Result<(), string> {","pub fn tier2_function(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_11.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),fn tokio_runtime_new() -> *mut TokioRuntime;,fn tokio_runtime_new(none) -> *mut TokioRuntime;
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_11.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn high_performance_server() -> Result<(), string> {","pub fn high_performance_server(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_11.asthra,23,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match tokio_result.map_err(|e| format!(""Tokio error: {:?}"", e)) {","Convert to concatenation: ""match tokio_result.map_err(|e| format!(""Tokio error:"" + :? + "", e)) {"""
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_14.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn with_timeout() -> Result<i32, string> {","pub fn with_timeout(none) -> Result<i32, string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_1.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn main() -> Result<(), string> {","pub fn main(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_16.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn missing_annotation() -> Result<(), string> {","pub fn missing_annotation(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_16.asthra,14,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn with_annotation() -> Result<(), string> {","pub fn with_annotation(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_12.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn well_handled_concurrency() -> Result<Vec<Data>, string> {","pub fn well_handled_concurrency(none) -> Result<Vec<Data>, string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_9.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn worker_pool_example() -> Result<Vec<ProcessedData>, string> {","pub fn worker_pool_example(none) -> Result<Vec<ProcessedData>, string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_10.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn synchronized_processing() -> Result<(), string> {","pub fn synchronized_processing(none) -> Result<(), string> {"
temp/manual_validation/concurrency_balanced/concurrency_balanced.md_example_7.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn simple_producer_consumer() -> Result<Vec<i32>, string> {","pub fn simple_producer_consumer(none) -> Result<Vec<i32>, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_10.asthra,23,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn pqc_key_encapsulation() -> Result<EncapsulationResult, string> {","priv fn pqc_key_encapsulation(none) -> Result<EncapsulationResult, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_2.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn grammar_compliant_function() -> Result<void, string> {","priv fn grammar_compliant_function(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_12.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn grammar_test_case() -> Result<void, string> {","priv fn grammar_test_case(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_16.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn result_chain_example() -> Result<string, string> {","priv fn result_chain_example(none) -> Result<string, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_16.asthra,12,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn advanced_task_coordination() -> Result<void, string> {","priv fn advanced_task_coordination(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_16.asthra,33,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn enhanced_ffi_pattern() -> Result<[]u8, string> {","priv fn enhanced_ffi_pattern(none) -> Result<[]u8, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_14.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn optimized_string_operations() -> Result<void, string> {","priv fn optimized_string_operations(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_8.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn generate_pqc_keypair() -> Result<PQCKeyPair, string> {","priv fn generate_pqc_keypair(none) -> Result<PQCKeyPair, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_11.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn comprehensive_pqc_workflow() -> Result<SecureSession, string> {","priv fn comprehensive_pqc_workflow(none) -> Result<SecureSession, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_13.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn tuple_pattern_matching() -> Result<void, string> {","priv fn tuple_pattern_matching(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_3.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn comprehensive_error_handling() -> Result<string, string> {","priv fn comprehensive_error_handling(none) -> Result<string, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_7.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn cryptographic_key_exchange() -> Result<SharedSecret, string> {","priv fn cryptographic_key_exchange(none) -> Result<SharedSecret, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_7.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn complex_concurrent_operation() -> Result<void, string> {","priv fn complex_concurrent_operation(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_7.asthra,17,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn simple_c_wrapper() -> Result<void, string> {","priv fn simple_c_wrapper(none) -> Result<void, string> {"
temp/manual_validation/advanced-topics/advanced-topics.md_example_15.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"priv fn advanced_slice_operations() -> Result<void, string> {","priv fn advanced_slice_operations(none) -> Result<void, string> {"
temp/manual_validation/security/security.md_example_5.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn generate_secure_random() -> Result<[]u8, string> {","pub fn generate_secure_random(none) -> Result<[]u8, string> {"
temp/manual_validation/security/security.md_example_11.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn secure_crypto_operation() -> Result<[]u8, string> {","pub fn secure_crypto_operation(none) -> Result<[]u8, string> {"
temp/manual_validation/security/security.md_example_7.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn generate_session_id() -> Result<string, string> {","pub fn generate_session_id(none) -> Result<string, string> {"
temp/manual_validation/security/security.md_example_7.asthra,18,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn generate_salt() -> Result<[]u8, string> {","pub fn generate_salt(none) -> Result<[]u8, string> {"
temp/manual_validation/security/security.md_example_14.asthra,4,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","true => return Result.Err(""Input too small: {data.len} < "" + min_size + """"),","Convert to concatenation: ""true => return Result.Err(""Input too small:"" + data.len + ""< "" + min_size + """"),"""
temp/manual_validation/security/security.md_example_14.asthra,7,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","true => return Result.Err(""Input too large: {data.len} > "" + max_size + """"),","Convert to concatenation: ""true => return Result.Err(""Input too large:"" + data.len + ""> "" + max_size + """"),"""
temp/manual_validation/security/security.md_example_18.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn test_security_features() -> Result<void, string> {","pub fn test_security_features(none) -> Result<void, string> {"
temp/manual_validation/security/security.md_example_10.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn handle_sensitive_key() -> Result<void, string> {","pub fn handle_sensitive_key(none) -> Result<void, string> {"
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_25.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn conflicting_annotations() -> void {},pub fn conflicting_annotations(none) -> void {}
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_25.asthra,8,empty_params,HIGH,Function with empty parameter list should use (none),pub fn consistent_annotation() -> void {},pub fn consistent_annotation(none) -> void {}
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_23.asthra,8,empty_params,HIGH,Function with empty parameter list should use (none),fn c_function_owned() -> *mut u8;,fn c_function_owned(none) -> *mut u8;
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_23.asthra,15,empty_params,HIGH,Function with empty parameter list should use (none),pub fn use_c_functions() -> void {,pub fn use_c_functions(none) -> void {
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_24.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),pub fn main() -> void {,pub fn main(none) -> void {
temp/manual_validation/ai_generation_guidelines/ai_generation_guidelines.md_example_22.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn complex_coordination() -> void {,pub fn complex_coordination(none) -> void {
temp/manual_validation/introduction/introduction.md_example_4.asthra,4,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""DEBUG"", ""Processing {data.len} data points"");","Convert to concatenation: ""log(""DEBUG"", ""Processing"" + data.len + ""data points"");"""
temp/manual_validation/introduction/introduction.md_example_4.asthra,11,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""PERF"", ""Calculation completed in {timer.elapsed()}ms"");","Convert to concatenation: ""log(""PERF"", ""Calculation completed in"" + timer.elapsed() + ""ms"");"""
temp/manual_validation/introduction/introduction.md_example_6.asthra,6,empty_params,HIGH,Function with empty parameter list should use (none),pub fn main() -> i32 {,pub fn main(none) -> i32 {
temp/manual_validation/building-projects/building-projects.md_example_2.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn debug_function() -> void {,pub fn debug_function(none) -> void {
temp/manual_validation/building-projects/building-projects.md_example_2.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn crypto_function() -> Result<[]u8, string> {","pub fn crypto_function(none) -> Result<[]u8, string> {"
temp/manual_validation/building-projects/building-projects.md_example_2.asthra,14,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn full_feature_function() -> Result<void, string> {","pub fn full_feature_function(none) -> Result<void, string> {"
temp/manual_validation/building-projects/building-projects.md_example_4.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn robust_build_step() -> Result<void, string> {","pub fn robust_build_step(none) -> Result<void, string> {"
temp/manual_validation/building-projects/building-projects.md_example_3.asthra,8,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn test_key_generation() -> Result<void, string> {","pub fn test_key_generation(none) -> Result<void, string> {"
temp/manual_validation/building-projects/building-projects.md_example_3.asthra,23,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn test_secure_compare() -> Result<void, string> {","pub fn test_secure_compare(none) -> Result<void, string> {"
temp/manual_validation/building-projects/building-projects.md_example_1.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn pre_build() -> Result<void, string> {","pub fn pre_build(none) -> Result<void, string> {"
temp/manual_validation/building-projects/building-projects.md_example_1.asthra,18,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn post_build() -> Result<void, string> {","pub fn post_build(none) -> Result<void, string> {"
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_2.asthra,23,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> IntList { /* ... */ },fn new(none) -> IntList { /* ... */ }
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_2.asthra,28,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> StringList { /* ... */ },fn new(none) -> StringList { /* ... */ }
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_2.asthra,33,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> FloatList { /* ... */ },fn new(none) -> FloatList { /* ... */ }
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_17.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn test_user_cache_integration() -> void {,pub fn test_user_cache_integration(none) -> void {
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_8.asthra,21,empty_params,HIGH,Function with empty parameter list should use (none),pub fn example_ffi_usage() -> void {,pub fn example_ffi_usage(none) -> void {
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_16.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn test_vec_operations() -> void {,pub fn test_vec_operations(none) -> void {
temp/manual_validation/generic_structs_migration/generic_structs_migration.md_example_3.asthra,11,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> List<T> {,fn new(none) -> List<T> {
temp/manual_validation/ffi-interop/ffi-interop.md_example_7.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn get_data_from_c() -> Result<[]u8, string> {","pub fn get_data_from_c(none) -> Result<[]u8, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_17.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn get_errno() -> i32;","extern ""libc"" fn get_errno(none) -> i32;"
temp/manual_validation/ffi-interop/ffi-interop.md_example_21.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn simple_c_call() -> Result<void, string> {","pub fn simple_c_call(none) -> Result<void, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_5.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn comprehensive_string_example() -> Result<void, string> {","pub fn comprehensive_string_example(none) -> Result<void, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_3.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn use_primitive_marshaling() -> i32 {,pub fn use_primitive_marshaling(none) -> i32 {
temp/manual_validation/ffi-interop/ffi-interop.md_example_20.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn variadic_example() -> Result<void, string> {","pub fn variadic_example(none) -> Result<void, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_14.asthra,6,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn complex_ownership_example() -> Result<void, string> {","pub fn complex_ownership_example(none) -> Result<void, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_18.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn robust_c_interaction() -> Result<string, string> {","pub fn robust_c_interaction(none) -> Result<string, string> {"
temp/manual_validation/ffi-interop/ffi-interop.md_example_10.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_buffer() -> #[transfer_full] *mut u8 { ... },pub fn create_buffer(none) -> #[transfer_full] *mut u8 { ... }
temp/manual_validation/ffi-interop/ffi-interop.md_example_2.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn safe_wrapper_example() -> Result<void, string> {","pub fn safe_wrapper_example(none) -> Result<void, string> {"
temp/manual_validation/object-oriented/object-oriented.md_example_17.asthra,16,empty_params,HIGH,Function with empty parameter list should use (none),pub fn method_resolution_examples() -> void {,pub fn method_resolution_examples(none) -> void {
temp/manual_validation/object-oriented/object-oriented.md_example_15.asthra,62,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn file_operations() -> Result<void, string> {","pub fn file_operations(none) -> Result<void, string> {"
temp/manual_validation/object-oriented/object-oriented.md_example_19.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_connection() -> HttpClient { ... },pub fn create_connection(none) -> HttpClient { ... }
temp/manual_validation/object-oriented/object-oriented.md_example_11.asthra,7,empty_params,HIGH,Function with empty parameter list should use (none),pub fn new() -> StringBuilder {,pub fn new(none) -> StringBuilder {
temp/manual_validation/object-oriented/object-oriented.md_example_11.asthra,25,empty_params,HIGH,Function with empty parameter list should use (none),pub fn build_message() -> string {,pub fn build_message(none) -> string {
temp/manual_validation/object-oriented/object-oriented.md_example_16.asthra,21,empty_params,HIGH,Function with empty parameter list should use (none),pub fn test_visibility() -> void {,pub fn test_visibility(none) -> void {
temp/manual_validation/object-oriented/object-oriented.md_example_14.asthra,43,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_database_connections() -> void {,pub fn create_database_connections(none) -> void {
temp/manual_validation/object-oriented/object-oriented.md_example_18.asthra,4,empty_params,HIGH,Function with empty parameter list should use (none),fn create_default() -> Calculator { ... },fn create_default(none) -> Calculator { ... }
temp/manual_validation/object-oriented/object-oriented.md_example_12.asthra,74,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_request() -> HttpRequest {,pub fn create_request(none) -> HttpRequest {
temp/manual_validation/object-oriented/object-oriented.md_example_12.asthra,78,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation",".with_body(""{\""name\"": \""John Doe\""}"")","Convert to concatenation: "".with_body("" + \""name\"": \""John Doe\"" + "")"""
temp/manual_validation/observability/observability.md_example_14.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn memory_debugging_example() -> Result<void, string> {","pub fn memory_debugging_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_7.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn replay_enabled_workflow() -> Result<void, string> {","pub fn replay_enabled_workflow(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_5.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn structured_logging_example() -> Result<void, string> {","pub fn structured_logging_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_9.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn comprehensive_debugging_example() -> Result<void, string> {","pub fn comprehensive_debugging_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_9.asthra,9,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""DEBUG"", ""Data slice: ptr={data.ptr} len={data.len}"");","Convert to concatenation: ""log(""DEBUG"", ""Data slice: ptr="" + data.ptr + ""len="" + data.len + "");"""
temp/manual_validation/observability/observability.md_example_9.asthra,18,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""DEBUG"", ""Processing successful: {processed.len} bytes output"");","Convert to concatenation: ""log(""DEBUG"", ""Processing successful:"" + processed.len + ""bytes output"");"""
temp/manual_validation/observability/observability.md_example_9.asthra,31,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""DEBUG"", ""Input data length: {data.len}"");","Convert to concatenation: ""log(""DEBUG"", ""Input data length:"" + data.len + "");"""
temp/manual_validation/observability/observability.md_example_12.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn performance_monitoring_example() -> Result<void, string> {","pub fn performance_monitoring_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_1.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),pub fn basic_logging_example() -> void {,pub fn basic_logging_example(none) -> void {
temp/manual_validation/observability/observability.md_example_3.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn io_comparison_example() -> Result<void, string> {","pub fn io_comparison_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_10.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn ai_diagnostic_example() -> Result<void, string> {","pub fn ai_diagnostic_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_15.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn external_tool_integration() -> Result<void, string> {","pub fn external_tool_integration(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_4.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn error_logging_example() -> Result<void, string> {","pub fn error_logging_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_8.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn debug_pattern_matching() -> Result<void, string> {","pub fn debug_pattern_matching(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_13.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn concurrent_debugging_example() -> Result<void, string> {","pub fn concurrent_debugging_example(none) -> Result<void, string> {"
temp/manual_validation/observability/observability.md_example_2.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),pub fn string_logging_example() -> void {,pub fn string_logging_example(none) -> void {
temp/manual_validation/observability/observability.md_example_11.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn ai_error_context_example() -> Result<void, string> {","pub fn ai_error_context_example(none) -> Result<void, string> {"
temp/manual_validation/annotations/annotations.md_example_20.asthra,5,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn secure_function() -> Result<void, string> {","pub fn secure_function(none) -> Result<void, string> {"
temp/manual_validation/annotations/annotations.md_example_20.asthra,19,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn crypto_function() -> Result<[]u8, string> {","pub fn crypto_function(none) -> Result<[]u8, string> {"
temp/manual_validation/annotations/annotations.md_example_6.asthra,21,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn generate_random_salt() -> Result<[]u8, string> {","pub fn generate_random_salt(none) -> Result<[]u8, string> {"
temp/manual_validation/annotations/annotations.md_example_15.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_managed_data() -> []u8 {,pub fn create_managed_data(none) -> []u8 {
temp/manual_validation/annotations/annotations.md_example_15.asthra,11,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_c_compatible_data() -> *mut u8 {,pub fn create_c_compatible_data(none) -> *mut u8 {
temp/manual_validation/annotations/annotations.md_example_15.asthra,19,empty_params,HIGH,Function with empty parameter list should use (none),pub fn create_pinned_secure_buffer() -> []u8 {,pub fn create_pinned_secure_buffer(none) -> []u8 {
temp/manual_validation/memory-management/memory-management.md_example_8.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn slice_management_examples() -> Result<void, string> {","pub fn slice_management_examples(none) -> Result<void, string> {"
temp/manual_validation/memory-management/memory-management.md_example_11.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn secure_memory_example() -> Result<void, string> {","pub fn secure_memory_example(none) -> Result<void, string> {"
temp/manual_validation/memory-management/memory-management.md_example_5.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""my_lib"" fn get_fixed_buffer() -> *mut u8;","extern ""my_lib"" fn get_fixed_buffer(none) -> *mut u8;"
temp/manual_validation/memory-management/memory-management.md_example_9.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn get_data_from_c() -> Result<[]u8, string> {","pub fn get_data_from_c(none) -> Result<[]u8, string> {"
temp/manual_validation/memory-management/memory-management.md_example_7.asthra,8,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn slice_operations_example() -> Result<usize, string> {","pub fn slice_operations_example(none) -> Result<usize, string> {"
temp/manual_validation/memory-management/memory-management.md_example_12.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn memory_safety_example() -> Result<void, string> {","pub fn memory_safety_example(none) -> Result<void, string> {"
temp/manual_validation/memory-management/memory-management.md_example_10.asthra,2,empty_params,HIGH,Function with empty parameter list should use (none),"pub fn handle_sensitive_key() -> Result<void, string> {","pub fn handle_sensitive_key(none) -> Result<void, string> {"
internal/runtime/memory_allocator.asthra,93,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_timestamp() -> u64;","extern ""asthra_runtime"" fn asthra_get_timestamp(none) -> u64;"
internal/runtime/memory_allocator.asthra,108,empty_params,HIGH,Function with empty parameter list should use (none),"fn get_allocation_stats() -> (usize, usize, usize) {","fn get_allocation_stats(none) -> (usize, usize, usize) {"
docs/examples/generic_structs_example.asthra,154,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Mathematical constants: π≈{x}, e≈{y}"");","Convert to concatenation: ""log(""Mathematical constants: π≈"" + x + "", e≈"" + y + "");"""
docs/examples/generic_structs_example.asthra,160,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Person: {name} is {age} years old"");","Convert to concatenation: ""log(""Person:"" + name + ""is"" + age + ""years old"");"""
docs/examples/generic_structs_example.asthra,168,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Active user cache (ID: {id}) contains {user_list.len} users"");","Convert to concatenation: ""log(""Active user cache (ID:"" + id + "") contains"" + user_list.len + ""users"");"""
docs/examples/generic_structs_example.asthra,170,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Inactive user cache (ID: {id})"");","Convert to concatenation: ""log(""Inactive user cache (ID:"" + id + "")"");"""
docs/examples/generic_structs_example.asthra,179,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Found number at index 1: {num}"");","Convert to concatenation: ""log(""Found number at index 1:"" + num + "");"""
docs/examples/generic_structs_example.asthra,187,auto_type,MEDIUM,Auto type annotation should be explicit type,"let auto_pair: auto = Pair.new(""inference"", 42);  // Pair<string, i32> inferred;","let auto_pair: <explicit_type> = Pair.new(""inference"", 42);  // Pair<string, i32> inferred;"
docs/examples/generic_structs_example.asthra,188,auto_type,MEDIUM,Auto type annotation should be explicit type,"let auto_container: auto = Container.new(auto_pair, ""metadata"", 999);  // Container<Pair<string, i32>, string>;","let auto_container: <explicit_type> = Container.new(auto_pair, ""metadata"", 999);  // Container<Pair<string, i32>, string>;"
docs/examples/generic_structs_example.asthra,191,auto_type,MEDIUM,Auto type annotation should be explicit type,"let point_2d: auto = Point2D { x: 10.0, y: 20.0 };","let point_2d: <explicit_type> = Point2D { x: 10.0, y: 20.0 };"
docs/examples/optional_elements_phase1_examples.asthra,35,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/optional_elements_phase1_examples.asthra,40,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/optional_elements_phase1_examples.asthra,44,empty_struct_void,HIGH,Empty struct should use { none } instead of { void },priv struct Empty { void },priv struct Empty { none }
docs/examples/optional_elements_phase2_examples.asthra,21,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/optional_elements_phase2_examples.asthra,26,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/optional_elements_phase2_examples.asthra,56,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/optional_elements_phase2_examples.asthra,67,return_void,LOW,Functions returning void should use return; not return void;,return void;,return;
docs/examples/annotations/human_review_examples.asthra,191,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""INFO"", ""Operation succeeded after {attempt} retries"");","Convert to concatenation: ""log(""INFO"", ""Operation succeeded after"" + attempt + ""retries"");"""
docs/examples/annotations/human_review_examples.asthra,199,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","return Result.Err(""Operation failed after {max_retries} attempts: "" + error);","Convert to concatenation: ""return Result.Err(""Operation failed after"" + max_retries + ""attempts: "" + error);"""
docs/examples/annotations/human_review_examples.asthra,207,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""WARN"", ""Attempt {attempt} failed, retrying in {actual_delay}ms: "" + error);","Convert to concatenation: ""log(""WARN"", ""Attempt"" + attempt + ""failed, retrying in"" + actual_delay + ""ms: "" + error);"""
docs/examples/annotations/human_review_examples.asthra,303,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_VALIDATION_FAILED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_VALIDATION_FAILED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,313,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_INSUFFICIENT_FUNDS"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_INSUFFICIENT_FUNDS"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,322,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_LIMIT_EXCEEDED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_LIMIT_EXCEEDED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,332,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_FRAUD_DETECTED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_FRAUD_DETECTED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,357,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_DEBIT_FAILED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_DEBIT_FAILED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,371,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_CREDIT_FAILED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_CREDIT_FAILED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,384,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_RECORD_FAILED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_RECORD_FAILED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,392,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_COMMIT_FAILED"", ""Transaction {transaction.id}: "" + error);","Convert to concatenation: ""audit_log(""TRANSACTION_COMMIT_FAILED"", ""Transaction"" + transaction.id + "": "" + error);"""
docs/examples/annotations/human_review_examples.asthra,403,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","audit_log(""TRANSACTION_SUCCESS"", ""Transaction {transaction.id} completed successfully"");","Convert to concatenation: ""audit_log(""TRANSACTION_SUCCESS"", ""Transaction"" + transaction.id + ""completed successfully"");"""
docs/examples/annotations/human_review_examples.asthra,492,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_cryptographic_salt() -> Result<[]u8, string> {","fn generate_cryptographic_salt(none) -> Result<[]u8, string> {"
docs/examples/annotations/human_review_examples.asthra,628,empty_params,HIGH,Function with empty parameter list should use (none),pub fn new() -> Config {,pub fn new(none) -> Config {
docs/examples/annotations/human_review_examples.asthra,651,empty_params,HIGH,Function with empty parameter list should use (none),pub fn new() -> ProcessedRecord {,pub fn new(none) -> ProcessedRecord {
docs/examples/annotations/ffi_annotations.asthra,274,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","return Result.Err(""Secure operation failed with code: {result}"");","Convert to concatenation: ""return Result.Err(""Secure operation failed with code:"" + result + "");"""
docs/examples/annotations/ffi_annotations.asthra,423,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","return Result.Err(""Complex function failed with code: {result}"");","Convert to concatenation: ""return Result.Err(""Complex function failed with code:"" + result + "");"""
docs/examples/annotations/ffi_annotations.asthra,478,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","_ => return Result.Err(""Unknown error code: {result}"")","Convert to concatenation: ""_ => return Result.Err(""Unknown error code:"" + result + "")"""
docs/examples/annotations/ffi_annotations.asthra,511,empty_params,HIGH,Function with empty parameter list should use (none),pub fn new() -> SecurityConfig {,pub fn new(none) -> SecurityConfig {
examples/concurrency_simple.asthra,8,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/worker_pool_demo.asthra,6,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/struct_methods.asthra,27,empty_params,HIGH,Function with empty parameter list should use (none),fn origin() -> Point {,fn origin(none) -> Point {
examples/struct_methods.asthra,38,auto_type,MEDIUM,Auto type annotation should be explicit type,let dx: auto = self.x - other.x;,let dx: <explicit_type> = self.x - other.x;
examples/struct_methods.asthra,39,auto_type,MEDIUM,Auto type annotation should be explicit type,let dy: auto = self.y - other.y;,let dy: <explicit_type> = self.y - other.y;
examples/struct_methods.asthra,112,auto_type,MEDIUM,Auto type annotation should be explicit type,let origin: auto = Point::origin();,let origin: <explicit_type> = Point::origin();
examples/struct_methods.asthra,113,auto_type,MEDIUM,Auto type annotation should be explicit type,"let point1: auto = Point::new(3.0, 4.0);","let point1: <explicit_type> = Point::new(3.0, 4.0);"
examples/struct_methods.asthra,114,auto_type,MEDIUM,Auto type annotation should be explicit type,"let point2: auto = Point::new(6.0, 8.0);","let point2: <explicit_type> = Point::new(6.0, 8.0);"
examples/struct_methods.asthra,117,auto_type,MEDIUM,Auto type annotation should be explicit type,let distance1: auto = point1.distance_from_origin();,let distance1: <explicit_type> = point1.distance_from_origin();
examples/struct_methods.asthra,118,auto_type,MEDIUM,Auto type annotation should be explicit type,let distance2: auto = point1.distance_to(point2);,let distance2: <explicit_type> = point1.distance_to(point2);
examples/struct_methods.asthra,119,auto_type,MEDIUM,Auto type annotation should be explicit type,let is_origin: auto = origin.is_origin();,let is_origin: <explicit_type> = origin.is_origin();
examples/struct_methods.asthra,122,auto_type,MEDIUM,Auto type annotation should be explicit type,"let transformed_point: auto = point1.translate(1.0, 1.0).scale(2.0);","let transformed_point: <explicit_type> = point1.translate(1.0, 1.0).scale(2.0);"
examples/struct_methods.asthra,125,auto_type,MEDIUM,Auto type annotation should be explicit type,"let rect: auto = Rectangle::new(0.0, 0.0, 10.0, 5.0);","let rect: <explicit_type> = Rectangle::new(0.0, 0.0, 10.0, 5.0);"
examples/struct_methods.asthra,126,auto_type,MEDIUM,Auto type annotation should be explicit type,"let square: auto = Rectangle::square(2.0, 2.0, 4.0);","let square: <explicit_type> = Rectangle::square(2.0, 2.0, 4.0);"
examples/struct_methods.asthra,128,auto_type,MEDIUM,Auto type annotation should be explicit type,let area: auto = rect.area();,let area: <explicit_type> = rect.area();
examples/struct_methods.asthra,129,auto_type,MEDIUM,Auto type annotation should be explicit type,let perimeter: auto = rect.perimeter();,let perimeter: <explicit_type> = rect.perimeter();
examples/struct_methods.asthra,130,auto_type,MEDIUM,Auto type annotation should be explicit type,let corner: auto = rect.bottom_right();,let corner: <explicit_type> = rect.bottom_right();
examples/struct_methods.asthra,131,auto_type,MEDIUM,Auto type annotation should be explicit type,let contains_point: auto = rect.contains(point1);,let contains_point: <explicit_type> = rect.contains(point1);
examples/struct_methods.asthra,134,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Point distance from origin: {distance1}"");","Convert to concatenation: ""log(""Point distance from origin:"" + distance1 + "");"""
examples/struct_methods.asthra,135,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Distance between points: {distance2}"");","Convert to concatenation: ""log(""Distance between points:"" + distance2 + "");"""
examples/struct_methods.asthra,136,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Rectangle area: {area}"");","Convert to concatenation: ""log(""Rectangle area:"" + area + "");"""
examples/struct_methods.asthra,137,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Rectangle perimeter: {perimeter}"");","Convert to concatenation: ""log(""Rectangle perimeter:"" + perimeter + "");"""
examples/if_with_call.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn my_function() -> void {,fn my_function(none) -> void {
examples/if_with_call.asthra,7,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/ffi_complete_example.asthra,65,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_string_marshaling() -> Result<void, string> {","fn demonstrate_string_marshaling(none) -> Result<void, string> {"
examples/ffi_complete_example.asthra,99,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_slice_marshaling() -> Result<void, string> {","fn demonstrate_slice_marshaling(none) -> Result<void, string> {"
examples/ffi_complete_example.asthra,127,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_variadic_functions() -> Result<void, string> {","fn demonstrate_variadic_functions(none) -> Result<void, string> {"
examples/ffi_complete_example.asthra,166,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_ownership_transfer() -> Result<void, string> {","fn demonstrate_ownership_transfer(none) -> Result<void, string> {"
examples/ffi_complete_example.asthra,205,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_result_marshaling() -> Result<string, string> {","fn demonstrate_result_marshaling(none) -> Result<string, string> {"
examples/ffi_complete_example.asthra,230,empty_params,HIGH,Function with empty parameter list should use (none),"fn perform_risky_operation() -> Result<i32, string> {","fn perform_risky_operation(none) -> Result<i32, string> {"
examples/ffi_complete_example.asthra,241,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/type_inference_demo.asthra,7,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> void {,fn main(none) -> void {
examples/type_inference_demo.asthra,9,auto_type,MEDIUM,Auto type annotation should be explicit type,let integer: auto = 42;        // Should infer i32;,let integer: <explicit_type> = 42;        // Should infer i32;
examples/type_inference_demo.asthra,10,auto_type,MEDIUM,Auto type annotation should be explicit type,let float: auto = 3.14;        // Should infer f64;,let float: <explicit_type> = 3.14;        // Should infer f64;
examples/type_inference_demo.asthra,11,auto_type,MEDIUM,Auto type annotation should be explicit type,"let text: auto = ""hello"";      // Should infer string;","let text: <explicit_type> = ""hello"";      // Should infer string;"
examples/type_inference_demo.asthra,12,auto_type,MEDIUM,Auto type annotation should be explicit type,let flag: auto = true;         // Should infer bool;,let flag: <explicit_type> = true;         // Should infer bool;
examples/type_inference_demo.asthra,13,auto_type,MEDIUM,Auto type annotation should be explicit type,let character: auto = 'A';     // Should infer char;,let character: <explicit_type> = 'A';     // Should infer char;
examples/type_inference_demo.asthra,16,auto_type,MEDIUM,Auto type annotation should be explicit type,"let numbers: auto = [1, 2, 3];           // Should infer []i32;","let numbers: <explicit_type> = [1, 2, 3];           // Should infer []i32;"
examples/type_inference_demo.asthra,17,auto_type,MEDIUM,Auto type annotation should be explicit type,"let names: auto = [""Alice"", ""Bob""];      // Should infer []string;","let names: <explicit_type> = [""Alice"", ""Bob""];      // Should infer []string;"
examples/type_inference_demo.asthra,18,auto_type,MEDIUM,Auto type annotation should be explicit type,"let flags: auto = [true, false, true];   // Should infer []bool;","let flags: <explicit_type> = [true, false, true];   // Should infer []bool;"
examples/type_inference_demo.asthra,21,auto_type,MEDIUM,Auto type annotation should be explicit type,let sum: auto = integer + 10;            // Should infer i32;,let sum: <explicit_type> = integer + 10;            // Should infer i32;
examples/type_inference_demo.asthra,22,auto_type,MEDIUM,Auto type annotation should be explicit type,let product: auto = float * 2.0;         // Should infer f64;,let product: <explicit_type> = float * 2.0;         // Should infer f64;
examples/type_inference_demo.asthra,23,auto_type,MEDIUM,Auto type annotation should be explicit type,let comparison: auto = integer < 100;    // Should infer bool;,let comparison: <explicit_type> = integer < 100;    // Should infer bool;
examples/type_inference_demo.asthra,36,auto_type,MEDIUM,Auto type annotation should be explicit type,let temp: auto = x * 2;      // Should infer i32;,let temp: <explicit_type> = x * 2;      // Should infer i32;
examples/type_inference_demo.asthra,37,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = temp + y; // Should infer i32;,let result: <explicit_type> = temp + y; // Should infer i32;
examples/test_log_function.asthra,7,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/error_context_example.asthra,46,empty_params,HIGH,Function with empty parameter list should use (none),"fn perform_operation_traditional() -> Result<i32, string> {","fn perform_operation_traditional(none) -> Result<i32, string> {"
examples/error_context_example.asthra,49,auto_type,MEDIUM,Auto type annotation should be explicit type,let fetch_result: auto = fetch_data(url);,let fetch_result: <explicit_type> = fetch_data(url);
examples/error_context_example.asthra,50,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = match fetch_result {;,let data: <explicit_type> = match fetch_result {;
examples/error_context_example.asthra,57,auto_type,MEDIUM,Auto type annotation should be explicit type,let parse_result: auto = parse_data(data);,let parse_result: <explicit_type> = parse_data(data);
examples/error_context_example.asthra,58,auto_type,MEDIUM,Auto type annotation should be explicit type,let items: auto = match parse_result {;,let items: <explicit_type> = match parse_result {;
examples/error_context_example.asthra,65,auto_type,MEDIUM,Auto type annotation should be explicit type,let process_result: auto = process_data(items);,let process_result: <explicit_type> = process_data(items);
examples/error_context_example.asthra,77,empty_params,HIGH,Function with empty parameter list should use (none),"fn perform_operation_with_context() -> Result<i32, error::ErrorWithContext<string>> {","fn perform_operation_with_context(none) -> Result<i32, error::ErrorWithContext<string>> {"
examples/error_context_example.asthra,81,auto_type,MEDIUM,Auto type annotation should be explicit type,"let data: auto = fetch_data(url).with_context(""Failed to fetch data from URL"");","let data: <explicit_type> = fetch_data(url).with_context(""Failed to fetch data from URL"");"
examples/error_context_example.asthra,82,auto_type,MEDIUM,Auto type annotation should be explicit type,"let items: auto = parse_data(data?).with_context(""Failed to parse fetched data"");","let items: <explicit_type> = parse_data(data?).with_context(""Failed to parse fetched data"");"
examples/error_context_example.asthra,83,auto_type,MEDIUM,Auto type annotation should be explicit type,"let count: auto = process_data(items?).with_context(""Failed to process parsed items"");","let count: <explicit_type> = process_data(items?).with_context(""Failed to process parsed items"");"
examples/error_context_example.asthra,89,empty_params,HIGH,Function with empty parameter list should use (none),"fn perform_complex_operation() -> Result<i32, error::ErrorWithContext<string>> {","fn perform_complex_operation(none) -> Result<i32, error::ErrorWithContext<string>> {"
examples/error_context_example.asthra,90,auto_type,MEDIUM,Auto type annotation should be explicit type,"let url: auto = ""api"";  // This will fail (too short);","let url: <explicit_type> = ""api"";  // This will fail (too short);"
examples/error_context_example.asthra,93,auto_type,MEDIUM,Auto type annotation should be explicit type,let fetch_result: auto = fetch_data(url);,let fetch_result: <explicit_type> = fetch_data(url);
examples/error_context_example.asthra,96,auto_type,MEDIUM,Auto type annotation should be explicit type,let context: auto = error::new_context_builder(err);,let context: <explicit_type> = error::new_context_builder(err);
examples/error_context_example.asthra,106,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = fetch_result.unwrap();,let data: <explicit_type> = fetch_result.unwrap();
examples/error_context_example.asthra,111,empty_params,HIGH,Function with empty parameter list should use (none),"fn multilayer_context_example() -> Result<i32, error::ErrorWithContext<string>> {","fn multilayer_context_example(none) -> Result<i32, error::ErrorWithContext<string>> {"
examples/error_context_example.asthra,115,auto_type,MEDIUM,Auto type annotation should be explicit type,"let parsed: auto = parse_data(data).with_context(""Failed in first parsing step"");","let parsed: <explicit_type> = parse_data(data).with_context(""Failed in first parsing step"");"
examples/error_context_example.asthra,124,auto_type,MEDIUM,Auto type annotation should be explicit type,"let enhanced: auto = context.add_context(""Validation phase encountered an error"");","let enhanced: <explicit_type> = context.add_context(""Validation phase encountered an error"");"
examples/error_context_example.asthra,131,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/error_context_example.asthra,134,auto_type,MEDIUM,Auto type annotation should be explicit type,let traditional_result: auto = perform_operation_traditional();,let traditional_result: <explicit_type> = perform_operation_traditional();
examples/error_context_example.asthra,146,auto_type,MEDIUM,Auto type annotation should be explicit type,let context_result: auto = perform_operation_with_context();,let context_result: <explicit_type> = perform_operation_with_context();
examples/error_context_example.asthra,162,auto_type,MEDIUM,Auto type annotation should be explicit type,let complex_result: auto = perform_complex_operation();,let complex_result: <explicit_type> = perform_complex_operation();
examples/error_context_example.asthra,174,auto_type,MEDIUM,Auto type annotation should be explicit type,let multilayer_result: auto = multilayer_context_example();,let multilayer_result: <explicit_type> = multilayer_context_example();
examples/minimal_if_log.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/concurrency_example.asthra,11,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Worker {id} starting"");","Convert to concatenation: ""log(""Worker"" + id + ""starting"");"""
examples/concurrency_example.asthra,14,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = id * 2;,let result: <explicit_type> = id * 2;
examples/concurrency_example.asthra,16,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Worker {id} completed with result {result}"");","Convert to concatenation: ""log(""Worker"" + id + ""completed with result"" + result + "");"""
examples/concurrency_example.asthra,22,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Complex worker {name} (id: {id}) starting with multiplier {multiplier}"");","Convert to concatenation: ""log(""Complex worker"" + name + ""(id:"" + id + "") starting with multiplier"" + multiplier + "");"""
examples/concurrency_example.asthra,24,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = id * multiplier;,let result: <explicit_type> = id * multiplier;
examples/concurrency_example.asthra,26,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Complex worker {name} completed with result {result}"");","Convert to concatenation: ""log(""Complex worker"" + name + ""completed with result"" + result + "");"""
examples/concurrency_example.asthra,32,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Starting parallel computation with {data.len} elements"");","Convert to concatenation: ""log(""Starting parallel computation with"" + data.len + ""elements"");"""
examples/concurrency_example.asthra,39,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""All {data.len} tasks spawned"");","Convert to concatenation: ""log(""All"" + data.len + ""tasks spawned"");"""
examples/concurrency_example.asthra,67,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/concurrency_example.asthra,70,auto_type,MEDIUM,Auto type annotation should be explicit type,"let data: auto = [1, 2, 3, 4, 5];","let data: <explicit_type> = [1, 2, 3, 4, 5];"
examples/concurrency_example.asthra,76,auto_type,MEDIUM,Auto type annotation should be explicit type,let task_count: auto = parallel_computation(data);,let task_count: <explicit_type> = parallel_computation(data);
examples/concurrency_example.asthra,77,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Spawned {task_count} parallel tasks"");","Convert to concatenation: ""log(""Spawned"" + task_count + ""parallel tasks"");"""
examples/test_initialization_simple.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/import_examples.asthra,54,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/import_examples.asthra,60,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","let json_data: mypkg::JsonValue = mypkg::parse_json(""{\""key\"": \""value\""}"");","Convert to concatenation: ""let json_data: mypkg::JsonValue = mypkg::parse_json("" + \""key\"": \""value\"" + "");"""
examples/test_pattern_matching.asthra,10,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/test_pattern_matching.asthra,14,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Division result: {value}"");","Convert to concatenation: ""log(""Division result:"" + value + "");"""
examples/test_pattern_matching.asthra,17,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Error: {error}"");","Convert to concatenation: ""log(""Error:"" + error + "");"""
examples/simple_if.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/test_initialization.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/string_escape_sequences.asthra,45,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","let json_like: string = ""{\n\t\""name\"": \"""" + name + ""\"",\n\t\""age\"": "" + string::from_int(age) + "",\n\t\""department\"": \"""" + department + ""\""\n}"";","Convert to concatenation: ""let json_like: string = "" + \n\t\""name\"": \"""" + name + ""\"",\n\t\""age\"": "" + string::from_int(age) + "",\n\t\""department\"": \"""" + department + ""\""\n + "";"""
examples/string_escape_sequences.asthra,92,empty_params,HIGH,Function with empty parameter list should use (none),fn get_timestamp() -> string {,fn get_timestamp(none) -> string {
examples/string_escape_sequences.asthra,96,empty_params,HIGH,Function with empty parameter list should use (none),fn generate_session_id() -> string {,fn generate_session_id(none) -> string {
examples/simple_log_test.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/json_examples.asthra,14,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_basic_parsing() -> Result<void, json::JSONError> {","fn example_basic_parsing(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,18,auto_type,MEDIUM,Auto type annotation should be explicit type,"let null_result: auto = json::parse(""null"");","let null_result: <explicit_type> = json::parse(""null"");"
examples/json_examples.asthra,29,auto_type,MEDIUM,Auto type annotation should be explicit type,"let bool_result: auto = json::parse(""true"");","let bool_result: <explicit_type> = json::parse(""true"");"
examples/json_examples.asthra,32,auto_type,MEDIUM,Auto type annotation should be explicit type,let bool_val_result: auto = json::as_bool(value);,let bool_val_result: <explicit_type> = json::as_bool(value);
examples/json_examples.asthra,33,auto_type,MEDIUM,Auto type annotation should be explicit type,let bool_val: auto = match bool_val_result {;,let bool_val: <explicit_type> = match bool_val_result {;
examples/json_examples.asthra,43,auto_type,MEDIUM,Auto type annotation should be explicit type,"let number_result: auto = json::parse(""42.5"");","let number_result: <explicit_type> = json::parse(""42.5"");"
examples/json_examples.asthra,46,auto_type,MEDIUM,Auto type annotation should be explicit type,let num_val_result: auto = json::as_number(value);,let num_val_result: <explicit_type> = json::as_number(value);
examples/json_examples.asthra,47,auto_type,MEDIUM,Auto type annotation should be explicit type,let num_val: auto = match num_val_result {;,let num_val: <explicit_type> = match num_val_result {;
examples/json_examples.asthra,57,auto_type,MEDIUM,Auto type annotation should be explicit type,"let string_result: auto = json::parse('""Hello, JSON!""');","let string_result: <explicit_type> = json::parse('""Hello, JSON!""');"
examples/json_examples.asthra,60,auto_type,MEDIUM,Auto type annotation should be explicit type,let str_val_result: auto = json::as_string(value);,let str_val_result: <explicit_type> = json::as_string(value);
examples/json_examples.asthra,61,auto_type,MEDIUM,Auto type annotation should be explicit type,let str_val: auto = match str_val_result {;,let str_val: <explicit_type> = match str_val_result {;
examples/json_examples.asthra,77,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_complex_structures() -> Result<void, json::JSONError> {","fn example_complex_structures(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,82,auto_type,MEDIUM,Auto type annotation should be explicit type,let array_result: auto = json::parse(array_json);,let array_result: <explicit_type> = json::parse(array_json);
examples/json_examples.asthra,85,auto_type,MEDIUM,Auto type annotation should be explicit type,let array_result: auto = json::as_array(value);,let array_result: <explicit_type> = json::as_array(value);
examples/json_examples.asthra,86,auto_type,MEDIUM,Auto type annotation should be explicit type,let array: auto = match array_result {;,let array: <explicit_type> = match array_result {;
examples/json_examples.asthra,93,auto_type,MEDIUM,Auto type annotation should be explicit type,"let first_element_result: auto = json::array_get(array, 0);","let first_element_result: <explicit_type> = json::array_get(array, 0);"
examples/json_examples.asthra,94,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_element: auto = match first_element_result {;,let first_element: <explicit_type> = match first_element_result {;
examples/json_examples.asthra,98,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_num_result: auto = json::as_number(first_element);,let first_num_result: <explicit_type> = json::as_number(first_element);
examples/json_examples.asthra,99,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_num: auto = match first_num_result {;,let first_num: <explicit_type> = match first_num_result {;
examples/json_examples.asthra,105,auto_type,MEDIUM,Auto type annotation should be explicit type,"let fourth_element_result: auto = json::array_get(array, 3);","let fourth_element_result: <explicit_type> = json::array_get(array, 3);"
examples/json_examples.asthra,106,auto_type,MEDIUM,Auto type annotation should be explicit type,let fourth_element: auto = match fourth_element_result {;,let fourth_element: <explicit_type> = match fourth_element_result {;
examples/json_examples.asthra,110,auto_type,MEDIUM,Auto type annotation should be explicit type,let fourth_str_result: auto = json::as_string(fourth_element);,let fourth_str_result: <explicit_type> = json::as_string(fourth_element);
examples/json_examples.asthra,111,auto_type,MEDIUM,Auto type annotation should be explicit type,let fourth_str: auto = match fourth_str_result {;,let fourth_str: <explicit_type> = match fourth_str_result {;
examples/json_examples.asthra,121,auto_type,MEDIUM,Auto type annotation should be explicit type,let object_json: auto = '{;,let object_json: <explicit_type> = '{;
examples/json_examples.asthra,130,auto_type,MEDIUM,Auto type annotation should be explicit type,let object_result: auto = json::parse(object_json);,let object_result: <explicit_type> = json::parse(object_json);
examples/json_examples.asthra,133,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj_result: auto = json::as_object(value);,let obj_result: <explicit_type> = json::as_object(value);
examples/json_examples.asthra,134,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj: auto = match obj_result {;,let obj: <explicit_type> = match obj_result {;
examples/json_examples.asthra,141,auto_type,MEDIUM,Auto type annotation should be explicit type,"let name_value_result: auto = json::object_get(obj, ""name"");","let name_value_result: <explicit_type> = json::object_get(obj, ""name"");"
examples/json_examples.asthra,142,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_value: auto = match name_value_result {;,let name_value: <explicit_type> = match name_value_result {;
examples/json_examples.asthra,146,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_result: auto = json::as_string(name_value);,let name_result: <explicit_type> = json::as_string(name_value);
examples/json_examples.asthra,147,auto_type,MEDIUM,Auto type annotation should be explicit type,let name: auto = match name_result {;,let name: <explicit_type> = match name_result {;
examples/json_examples.asthra,153,auto_type,MEDIUM,Auto type annotation should be explicit type,"let age_value_result: auto = json::object_get(obj, ""age"");","let age_value_result: <explicit_type> = json::object_get(obj, ""age"");"
examples/json_examples.asthra,154,auto_type,MEDIUM,Auto type annotation should be explicit type,let age_value: auto = match age_value_result {;,let age_value: <explicit_type> = match age_value_result {;
examples/json_examples.asthra,158,auto_type,MEDIUM,Auto type annotation should be explicit type,let age_result: auto = json::as_number(age_value);,let age_result: <explicit_type> = json::as_number(age_value);
examples/json_examples.asthra,159,auto_type,MEDIUM,Auto type annotation should be explicit type,let age: auto = match age_result {;,let age: <explicit_type> = match age_result {;
examples/json_examples.asthra,165,auto_type,MEDIUM,Auto type annotation should be explicit type,"let active_value_result: auto = json::object_get(obj, ""active"");","let active_value_result: <explicit_type> = json::object_get(obj, ""active"");"
examples/json_examples.asthra,166,auto_type,MEDIUM,Auto type annotation should be explicit type,let active_value: auto = match active_value_result {;,let active_value: <explicit_type> = match active_value_result {;
examples/json_examples.asthra,170,auto_type,MEDIUM,Auto type annotation should be explicit type,let active_result: auto = json::as_bool(active_value);,let active_result: <explicit_type> = json::as_bool(active_value);
examples/json_examples.asthra,171,auto_type,MEDIUM,Auto type annotation should be explicit type,let active: auto = match active_result {;,let active: <explicit_type> = match active_result {;
examples/json_examples.asthra,187,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_nested_structures() -> Result<void, json::JSONError> {","fn example_nested_structures(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,190,auto_type,MEDIUM,Auto type annotation should be explicit type,let nested_json: auto = '{;,let nested_json: <explicit_type> = '{;
examples/json_examples.asthra,217,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = json::parse(nested_json);,let result: <explicit_type> = json::parse(nested_json);
examples/json_examples.asthra,220,auto_type,MEDIUM,Auto type annotation should be explicit type,let root_obj_result: auto = json::as_object(root_value);,let root_obj_result: <explicit_type> = json::as_object(root_value);
examples/json_examples.asthra,221,auto_type,MEDIUM,Auto type annotation should be explicit type,let root_obj: auto = match root_obj_result {;,let root_obj: <explicit_type> = match root_obj_result {;
examples/json_examples.asthra,227,auto_type,MEDIUM,Auto type annotation should be explicit type,"let user_value_result: auto = json::object_get(root_obj, ""user"");","let user_value_result: <explicit_type> = json::object_get(root_obj, ""user"");"
examples/json_examples.asthra,228,auto_type,MEDIUM,Auto type annotation should be explicit type,let user_value: auto = match user_value_result {;,let user_value: <explicit_type> = match user_value_result {;
examples/json_examples.asthra,232,auto_type,MEDIUM,Auto type annotation should be explicit type,let user_obj_result: auto = json::as_object(user_value);,let user_obj_result: <explicit_type> = json::as_object(user_value);
examples/json_examples.asthra,233,auto_type,MEDIUM,Auto type annotation should be explicit type,let user_obj: auto = match user_obj_result {;,let user_obj: <explicit_type> = match user_obj_result {;
examples/json_examples.asthra,238,auto_type,MEDIUM,Auto type annotation should be explicit type,"let profile_value_result: auto = json::object_get(user_obj, ""profile"");","let profile_value_result: <explicit_type> = json::object_get(user_obj, ""profile"");"
examples/json_examples.asthra,239,auto_type,MEDIUM,Auto type annotation should be explicit type,let profile_value: auto = match profile_value_result {;,let profile_value: <explicit_type> = match profile_value_result {;
examples/json_examples.asthra,243,auto_type,MEDIUM,Auto type annotation should be explicit type,let profile_obj_result: auto = json::as_object(profile_value);,let profile_obj_result: <explicit_type> = json::as_object(profile_value);
examples/json_examples.asthra,244,auto_type,MEDIUM,Auto type annotation should be explicit type,let profile_obj: auto = match profile_obj_result {;,let profile_obj: <explicit_type> = match profile_obj_result {;
examples/json_examples.asthra,249,auto_type,MEDIUM,Auto type annotation should be explicit type,"let name_value_result: auto = json::object_get(profile_obj, ""name"");","let name_value_result: <explicit_type> = json::object_get(profile_obj, ""name"");"
examples/json_examples.asthra,250,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_value: auto = match name_value_result {;,let name_value: <explicit_type> = match name_value_result {;
examples/json_examples.asthra,254,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_result: auto = json::as_string(name_value);,let name_result: <explicit_type> = json::as_string(name_value);
examples/json_examples.asthra,255,auto_type,MEDIUM,Auto type annotation should be explicit type,let name: auto = match name_result {;,let name: <explicit_type> = match name_result {;
examples/json_examples.asthra,262,auto_type,MEDIUM,Auto type annotation should be explicit type,"let prefs_value_result: auto = json::object_get(profile_obj, ""preferences"");","let prefs_value_result: <explicit_type> = json::object_get(profile_obj, ""preferences"");"
examples/json_examples.asthra,263,auto_type,MEDIUM,Auto type annotation should be explicit type,let prefs_value: auto = match prefs_value_result {;,let prefs_value: <explicit_type> = match prefs_value_result {;
examples/json_examples.asthra,267,auto_type,MEDIUM,Auto type annotation should be explicit type,let prefs_obj_result: auto = json::as_object(prefs_value);,let prefs_obj_result: <explicit_type> = json::as_object(prefs_value);
examples/json_examples.asthra,268,auto_type,MEDIUM,Auto type annotation should be explicit type,let prefs_obj: auto = match prefs_obj_result {;,let prefs_obj: <explicit_type> = match prefs_obj_result {;
examples/json_examples.asthra,273,auto_type,MEDIUM,Auto type annotation should be explicit type,"let theme_value_result: auto = json::object_get(prefs_obj, ""theme"");","let theme_value_result: <explicit_type> = json::object_get(prefs_obj, ""theme"");"
examples/json_examples.asthra,274,auto_type,MEDIUM,Auto type annotation should be explicit type,let theme_value: auto = match theme_value_result {;,let theme_value: <explicit_type> = match theme_value_result {;
examples/json_examples.asthra,278,auto_type,MEDIUM,Auto type annotation should be explicit type,let theme_result: auto = json::as_string(theme_value);,let theme_result: <explicit_type> = json::as_string(theme_value);
examples/json_examples.asthra,279,auto_type,MEDIUM,Auto type annotation should be explicit type,let theme: auto = match theme_result {;,let theme: <explicit_type> = match theme_result {;
examples/json_examples.asthra,286,auto_type,MEDIUM,Auto type annotation should be explicit type,"let roles_value_result: auto = json::object_get(user_obj, ""roles"");","let roles_value_result: <explicit_type> = json::object_get(user_obj, ""roles"");"
examples/json_examples.asthra,287,auto_type,MEDIUM,Auto type annotation should be explicit type,let roles_value: auto = match roles_value_result {;,let roles_value: <explicit_type> = match roles_value_result {;
examples/json_examples.asthra,291,auto_type,MEDIUM,Auto type annotation should be explicit type,let roles_array_result: auto = json::as_array(roles_value);,let roles_array_result: <explicit_type> = json::as_array(roles_value);
examples/json_examples.asthra,292,auto_type,MEDIUM,Auto type annotation should be explicit type,let roles_array: auto = match roles_array_result {;,let roles_array: <explicit_type> = match roles_array_result {;
examples/json_examples.asthra,298,auto_type,MEDIUM,Auto type annotation should be explicit type,"let first_role_value_result: auto = json::array_get(roles_array, 0);","let first_role_value_result: <explicit_type> = json::array_get(roles_array, 0);"
examples/json_examples.asthra,299,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_role_value: auto = match first_role_value_result {;,let first_role_value: <explicit_type> = match first_role_value_result {;
examples/json_examples.asthra,303,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_role_result: auto = json::as_string(first_role_value);,let first_role_result: <explicit_type> = json::as_string(first_role_value);
examples/json_examples.asthra,304,auto_type,MEDIUM,Auto type annotation should be explicit type,let first_role: auto = match first_role_result {;,let first_role: <explicit_type> = match first_role_result {;
examples/json_examples.asthra,320,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_serialization() -> Result<void, json::JSONError> {","fn example_serialization(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,329,auto_type,MEDIUM,Auto type annotation should be explicit type,let simple_value: auto = json::JSONValue.Object(simple_obj);,let simple_value: <explicit_type> = json::JSONValue.Object(simple_obj);
examples/json_examples.asthra,330,auto_type,MEDIUM,Auto type annotation should be explicit type,let simple_json_result: auto = json::stringify(simple_value);,let simple_json_result: <explicit_type> = json::stringify(simple_value);
examples/json_examples.asthra,331,auto_type,MEDIUM,Auto type annotation should be explicit type,let simple_json: auto = match simple_json_result {;,let simple_json: <explicit_type> = match simple_json_result {;
examples/json_examples.asthra,366,auto_type,MEDIUM,Auto type annotation should be explicit type,let complex_value: auto = json::JSONValue.Object(user);,let complex_value: <explicit_type> = json::JSONValue.Object(user);
examples/json_examples.asthra,367,auto_type,MEDIUM,Auto type annotation should be explicit type,let complex_json_result: auto = json::stringify(complex_value);,let complex_json_result: <explicit_type> = json::stringify(complex_value);
examples/json_examples.asthra,368,auto_type,MEDIUM,Auto type annotation should be explicit type,let complex_json: auto = match complex_json_result {;,let complex_json: <explicit_type> = match complex_json_result {;
examples/json_examples.asthra,381,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_pretty_printing() -> Result<void, json::JSONError> {","fn example_pretty_printing(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,404,auto_type,MEDIUM,Auto type annotation should be explicit type,let data_value: auto = json::JSONValue.Object(data);,let data_value: <explicit_type> = json::JSONValue.Object(data);
examples/json_examples.asthra,407,auto_type,MEDIUM,Auto type annotation should be explicit type,let pretty_config: auto = json::JSONSerializeConfig {;,let pretty_config: <explicit_type> = json::JSONSerializeConfig {;
examples/json_examples.asthra,415,auto_type,MEDIUM,Auto type annotation should be explicit type,"let pretty_json_result: auto = json::stringify_with_config(data_value, pretty_config);","let pretty_json_result: <explicit_type> = json::stringify_with_config(data_value, pretty_config);"
examples/json_examples.asthra,416,auto_type,MEDIUM,Auto type annotation should be explicit type,let pretty_json: auto = match pretty_json_result {;,let pretty_json: <explicit_type> = match pretty_json_result {;
examples/json_examples.asthra,430,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_error_handling() -> Result<void, json::JSONError> {","fn example_error_handling(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,446,auto_type,MEDIUM,Auto type annotation should be explicit type,let test_json: auto = test_cases[i];,let test_json: <explicit_type> = test_cases[i];
examples/json_examples.asthra,449,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = json::parse(test_json);,let result: <explicit_type> = json::parse(test_json);
examples/json_examples.asthra,487,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_custom_configuration() -> Result<void, json::JSONError> {","fn example_custom_configuration(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,491,auto_type,MEDIUM,Auto type annotation should be explicit type,let relaxed_config: auto = json::JSONConfig {;,let relaxed_config: <explicit_type> = json::JSONConfig {;
examples/json_examples.asthra,501,auto_type,MEDIUM,Auto type annotation should be explicit type,let config_json: auto = '{;,let config_json: <explicit_type> = '{;
examples/json_examples.asthra,520,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result: auto = json::parse_with_config(config_json, relaxed_config);","let result: <explicit_type> = json::parse_with_config(config_json, relaxed_config);"
examples/json_examples.asthra,524,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj_result: auto = json::as_object(value);,let obj_result: <explicit_type> = json::as_object(value);
examples/json_examples.asthra,525,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj: auto = match obj_result {;,let obj: <explicit_type> = match obj_result {;
examples/json_examples.asthra,531,auto_type,MEDIUM,Auto type annotation should be explicit type,"let db_value_result: auto = json::object_get(obj, ""database"");","let db_value_result: <explicit_type> = json::object_get(obj, ""database"");"
examples/json_examples.asthra,532,auto_type,MEDIUM,Auto type annotation should be explicit type,let db_value: auto = match db_value_result {;,let db_value: <explicit_type> = match db_value_result {;
examples/json_examples.asthra,536,auto_type,MEDIUM,Auto type annotation should be explicit type,let db_obj_result: auto = json::as_object(db_value);,let db_obj_result: <explicit_type> = json::as_object(db_value);
examples/json_examples.asthra,537,auto_type,MEDIUM,Auto type annotation should be explicit type,let db_obj: auto = match db_obj_result {;,let db_obj: <explicit_type> = match db_obj_result {;
examples/json_examples.asthra,542,auto_type,MEDIUM,Auto type annotation should be explicit type,"let host_value_result: auto = json::object_get(db_obj, ""host"");","let host_value_result: <explicit_type> = json::object_get(db_obj, ""host"");"
examples/json_examples.asthra,543,auto_type,MEDIUM,Auto type annotation should be explicit type,let host_value: auto = match host_value_result {;,let host_value: <explicit_type> = match host_value_result {;
examples/json_examples.asthra,547,auto_type,MEDIUM,Auto type annotation should be explicit type,let host_result: auto = json::as_string(host_value);,let host_result: <explicit_type> = json::as_string(host_value);
examples/json_examples.asthra,548,auto_type,MEDIUM,Auto type annotation should be explicit type,let host: auto = match host_result {;,let host: <explicit_type> = match host_result {;
examples/json_examples.asthra,554,auto_type,MEDIUM,Auto type annotation should be explicit type,"let port_value_result: auto = json::object_get(db_obj, ""port"");","let port_value_result: <explicit_type> = json::object_get(db_obj, ""port"");"
examples/json_examples.asthra,555,auto_type,MEDIUM,Auto type annotation should be explicit type,let port_value: auto = match port_value_result {;,let port_value: <explicit_type> = match port_value_result {;
examples/json_examples.asthra,559,auto_type,MEDIUM,Auto type annotation should be explicit type,let port_result: auto = json::as_number(port_value);,let port_result: <explicit_type> = json::as_number(port_value);
examples/json_examples.asthra,560,auto_type,MEDIUM,Auto type annotation should be explicit type,let port: auto = match port_result {;,let port: <explicit_type> = match port_result {;
examples/json_examples.asthra,576,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_type_safety() -> Result<void, json::JSONError> {","fn example_type_safety(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,579,auto_type,MEDIUM,Auto type annotation should be explicit type,let mixed_json: auto = '{;,let mixed_json: <explicit_type> = '{;
examples/json_examples.asthra,588,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = json::parse(mixed_json);,let result: <explicit_type> = json::parse(mixed_json);
examples/json_examples.asthra,591,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj_result: auto = json::as_object(value);,let obj_result: <explicit_type> = json::as_object(value);
examples/json_examples.asthra,592,auto_type,MEDIUM,Auto type annotation should be explicit type,let obj: auto = match obj_result {;,let obj: <explicit_type> = match obj_result {;
examples/json_examples.asthra,598,auto_type,MEDIUM,Auto type annotation should be explicit type,"let string_value_result: auto = json::object_get(obj, ""string_field"");","let string_value_result: <explicit_type> = json::object_get(obj, ""string_field"");"
examples/json_examples.asthra,599,auto_type,MEDIUM,Auto type annotation should be explicit type,let string_value: auto = match string_value_result {;,let string_value: <explicit_type> = match string_value_result {;
examples/json_examples.asthra,604,auto_type,MEDIUM,Auto type annotation should be explicit type,let str_val_result: auto = json::as_string(string_value);,let str_val_result: <explicit_type> = json::as_string(string_value);
examples/json_examples.asthra,605,auto_type,MEDIUM,Auto type annotation should be explicit type,let str_val: auto = match str_val_result {;,let str_val: <explicit_type> = match str_val_result {;
examples/json_examples.asthra,612,auto_type,MEDIUM,Auto type annotation should be explicit type,"let number_value_result: auto = json::object_get(obj, ""number_field"");","let number_value_result: <explicit_type> = json::object_get(obj, ""number_field"");"
examples/json_examples.asthra,613,auto_type,MEDIUM,Auto type annotation should be explicit type,let number_value: auto = match number_value_result {;,let number_value: <explicit_type> = match number_value_result {;
examples/json_examples.asthra,618,auto_type,MEDIUM,Auto type annotation should be explicit type,let num_val_result: auto = json::as_number(number_value);,let num_val_result: <explicit_type> = json::as_number(number_value);
examples/json_examples.asthra,619,auto_type,MEDIUM,Auto type annotation should be explicit type,let num_val: auto = match num_val_result {;,let num_val: <explicit_type> = match num_val_result {;
examples/json_examples.asthra,626,auto_type,MEDIUM,Auto type annotation should be explicit type,"let boolean_value_result: auto = json::object_get(obj, ""boolean_field"");","let boolean_value_result: <explicit_type> = json::object_get(obj, ""boolean_field"");"
examples/json_examples.asthra,627,auto_type,MEDIUM,Auto type annotation should be explicit type,let boolean_value: auto = match boolean_value_result {;,let boolean_value: <explicit_type> = match boolean_value_result {;
examples/json_examples.asthra,632,auto_type,MEDIUM,Auto type annotation should be explicit type,let bool_val_result: auto = json::as_bool(boolean_value);,let bool_val_result: <explicit_type> = json::as_bool(boolean_value);
examples/json_examples.asthra,633,auto_type,MEDIUM,Auto type annotation should be explicit type,let bool_val: auto = match bool_val_result {;,let bool_val: <explicit_type> = match bool_val_result {;
examples/json_examples.asthra,640,auto_type,MEDIUM,Auto type annotation should be explicit type,"let null_value_result: auto = json::object_get(obj, ""null_field"");","let null_value_result: <explicit_type> = json::object_get(obj, ""null_field"");"
examples/json_examples.asthra,641,auto_type,MEDIUM,Auto type annotation should be explicit type,let null_value: auto = match null_value_result {;,let null_value: <explicit_type> = match null_value_result {;
examples/json_examples.asthra,649,auto_type,MEDIUM,Auto type annotation should be explicit type,"let array_value_result: auto = json::object_get(obj, ""array_field"");","let array_value_result: <explicit_type> = json::object_get(obj, ""array_field"");"
examples/json_examples.asthra,650,auto_type,MEDIUM,Auto type annotation should be explicit type,let array_value: auto = match array_value_result {;,let array_value: <explicit_type> = match array_value_result {;
examples/json_examples.asthra,655,auto_type,MEDIUM,Auto type annotation should be explicit type,let arr_result: auto = json::as_array(array_value);,let arr_result: <explicit_type> = json::as_array(array_value);
examples/json_examples.asthra,656,auto_type,MEDIUM,Auto type annotation should be explicit type,let arr: auto = match arr_result {;,let arr: <explicit_type> = match arr_result {;
examples/json_examples.asthra,663,auto_type,MEDIUM,Auto type annotation should be explicit type,"let object_value_result: auto = json::object_get(obj, ""object_field"");","let object_value_result: <explicit_type> = json::object_get(obj, ""object_field"");"
examples/json_examples.asthra,664,auto_type,MEDIUM,Auto type annotation should be explicit type,let object_value: auto = match object_value_result {;,let object_value: <explicit_type> = match object_value_result {;
examples/json_examples.asthra,669,auto_type,MEDIUM,Auto type annotation should be explicit type,let nested_obj_result: auto = json::as_object(object_value);,let nested_obj_result: <explicit_type> = json::as_object(object_value);
examples/json_examples.asthra,670,auto_type,MEDIUM,Auto type annotation should be explicit type,let nested_obj: auto = match nested_obj_result {;,let nested_obj: <explicit_type> = match nested_obj_result {;
examples/json_examples.asthra,678,auto_type,MEDIUM,Auto type annotation should be explicit type,let type_mismatch_result: auto = json::as_number(string_value);,let type_mismatch_result: <explicit_type> = json::as_number(string_value);
examples/json_examples.asthra,699,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_manipulation() -> Result<void, json::JSONError> {","fn example_manipulation(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,717,auto_type,MEDIUM,Auto type annotation should be explicit type,"let modified_value_result: auto = json::array_get(dynamic_array, 1);","let modified_value_result: <explicit_type> = json::array_get(dynamic_array, 1);"
examples/json_examples.asthra,718,auto_type,MEDIUM,Auto type annotation should be explicit type,let modified_value: auto = match modified_value_result {;,let modified_value: <explicit_type> = match modified_value_result {;
examples/json_examples.asthra,722,auto_type,MEDIUM,Auto type annotation should be explicit type,let modified_num_result: auto = json::as_number(modified_value);,let modified_num_result: <explicit_type> = json::as_number(modified_value);
examples/json_examples.asthra,723,auto_type,MEDIUM,Auto type annotation should be explicit type,let modified_num: auto = match modified_num_result {;,let modified_num: <explicit_type> = match modified_num_result {;
examples/json_examples.asthra,748,auto_type,MEDIUM,Auto type annotation should be explicit type,"let updated_count_result: auto = json::object_get(dynamic_object, ""count"");","let updated_count_result: <explicit_type> = json::object_get(dynamic_object, ""count"");"
examples/json_examples.asthra,749,auto_type,MEDIUM,Auto type annotation should be explicit type,let updated_count: auto = match updated_count_result {;,let updated_count: <explicit_type> = match updated_count_result {;
examples/json_examples.asthra,753,auto_type,MEDIUM,Auto type annotation should be explicit type,let count_val_result: auto = json::as_number(updated_count);,let count_val_result: <explicit_type> = json::as_number(updated_count);
examples/json_examples.asthra,754,auto_type,MEDIUM,Auto type annotation should be explicit type,let count_val: auto = match count_val_result {;,let count_val: <explicit_type> = match count_val_result {;
examples/json_examples.asthra,767,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_value: auto = json::JSONValue.Object(dynamic_object);,let final_value: <explicit_type> = json::JSONValue.Object(dynamic_object);
examples/json_examples.asthra,768,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_json_result: auto = json::stringify(final_value);,let final_json_result: <explicit_type> = json::stringify(final_value);
examples/json_examples.asthra,769,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_json: auto = match final_json_result {;,let final_json: <explicit_type> = match final_json_result {;
examples/json_examples.asthra,782,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_json_path_queries() -> Result<void, json::JSONError> {","fn example_json_path_queries(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,785,auto_type,MEDIUM,Auto type annotation should be explicit type,let complex_json: auto = '{;,let complex_json: <explicit_type> = '{;
examples/json_examples.asthra,811,auto_type,MEDIUM,Auto type annotation should be explicit type,let root_result: auto = json::parse(complex_json);,let root_result: <explicit_type> = json::parse(complex_json);
examples/json_examples.asthra,812,auto_type,MEDIUM,Auto type annotation should be explicit type,let root: auto = match root_result {;,let root: <explicit_type> = match root_result {;
examples/json_examples.asthra,818,auto_type,MEDIUM,Auto type annotation should be explicit type,"let company_name_result: auto = json::json_path_get(root, ""company.name"");","let company_name_result: <explicit_type> = json::json_path_get(root, ""company.name"");"
examples/json_examples.asthra,821,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_result: auto = json::as_string(name_value);,let name_result: <explicit_type> = json::as_string(name_value);
examples/json_examples.asthra,822,auto_type,MEDIUM,Auto type annotation should be explicit type,let name: auto = match name_result {;,let name: <explicit_type> = match name_result {;
examples/json_examples.asthra,832,auto_type,MEDIUM,Auto type annotation should be explicit type,"let dept_name_result: auto = json::json_path_get(root, ""company.departments.0.name"");","let dept_name_result: <explicit_type> = json::json_path_get(root, ""company.departments.0.name"");"
examples/json_examples.asthra,835,auto_type,MEDIUM,Auto type annotation should be explicit type,let dept_name_result: auto = json::as_string(dept_value);,let dept_name_result: <explicit_type> = json::as_string(dept_value);
examples/json_examples.asthra,836,auto_type,MEDIUM,Auto type annotation should be explicit type,let dept_name: auto = match dept_name_result {;,let dept_name: <explicit_type> = match dept_name_result {;
examples/json_examples.asthra,846,auto_type,MEDIUM,Auto type annotation should be explicit type,"let employee_result: auto = json::json_path_get(root, ""company.departments.0.employees.0.name"");","let employee_result: <explicit_type> = json::json_path_get(root, ""company.departments.0.employees.0.name"");"
examples/json_examples.asthra,849,auto_type,MEDIUM,Auto type annotation should be explicit type,let emp_name_result: auto = json::as_string(emp_value);,let emp_name_result: <explicit_type> = json::as_string(emp_value);
examples/json_examples.asthra,850,auto_type,MEDIUM,Auto type annotation should be explicit type,let emp_name: auto = match emp_name_result {;,let emp_name: <explicit_type> = match emp_name_result {;
examples/json_examples.asthra,860,auto_type,MEDIUM,Auto type annotation should be explicit type,"let founded_result: auto = json::json_path_get(root, ""company.metadata.founded"");","let founded_result: <explicit_type> = json::json_path_get(root, ""company.metadata.founded"");"
examples/json_examples.asthra,863,auto_type,MEDIUM,Auto type annotation should be explicit type,let founded_year_result: auto = json::as_number(founded_value);,let founded_year_result: <explicit_type> = json::as_number(founded_value);
examples/json_examples.asthra,864,auto_type,MEDIUM,Auto type annotation should be explicit type,let founded_year: auto = match founded_year_result {;,let founded_year: <explicit_type> = match founded_year_result {;
examples/json_examples.asthra,880,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_schema_validation() -> Result<void, json::JSONError> {","fn example_schema_validation(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,884,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_schema: auto = json::JSONSchema {;,let name_schema: <explicit_type> = json::JSONSchema {;
examples/json_examples.asthra,894,auto_type,MEDIUM,Auto type annotation should be explicit type,let age_schema: auto = json::JSONSchema {;,let age_schema: <explicit_type> = json::JSONSchema {;
examples/json_examples.asthra,906,auto_type,MEDIUM,Auto type annotation should be explicit type,let valid_user_result: auto = json::parse(valid_user_json);,let valid_user_result: <explicit_type> = json::parse(valid_user_json);
examples/json_examples.asthra,907,auto_type,MEDIUM,Auto type annotation should be explicit type,let valid_user: auto = match valid_user_result {;,let valid_user: <explicit_type> = match valid_user_result {;
examples/json_examples.asthra,913,auto_type,MEDIUM,Auto type annotation should be explicit type,"let name_value_result: auto = json::json_path_get(valid_user, ""name"");","let name_value_result: <explicit_type> = json::json_path_get(valid_user, ""name"");"
examples/json_examples.asthra,914,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_value: auto = match name_value_result {;,let name_value: <explicit_type> = match name_value_result {;
examples/json_examples.asthra,918,auto_type,MEDIUM,Auto type annotation should be explicit type,"let name_valid_result: auto = json::validate_schema(name_value, name_schema);","let name_valid_result: <explicit_type> = json::validate_schema(name_value, name_schema);"
examples/json_examples.asthra,919,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_valid: auto = match name_valid_result {;,let name_valid: <explicit_type> = match name_valid_result {;
examples/json_examples.asthra,930,auto_type,MEDIUM,Auto type annotation should be explicit type,"let age_value_result: auto = json::json_path_get(valid_user, ""age"");","let age_value_result: <explicit_type> = json::json_path_get(valid_user, ""age"");"
examples/json_examples.asthra,931,auto_type,MEDIUM,Auto type annotation should be explicit type,let age_value: auto = match age_value_result {;,let age_value: <explicit_type> = match age_value_result {;
examples/json_examples.asthra,935,auto_type,MEDIUM,Auto type annotation should be explicit type,"let age_valid_result: auto = json::validate_schema(age_value, age_schema);","let age_valid_result: <explicit_type> = json::validate_schema(age_value, age_schema);"
examples/json_examples.asthra,936,auto_type,MEDIUM,Auto type annotation should be explicit type,let age_valid: auto = match age_valid_result {;,let age_valid: <explicit_type> = match age_valid_result {;
examples/json_examples.asthra,948,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_user_result: auto = json::parse(invalid_user_json);,let invalid_user_result: <explicit_type> = json::parse(invalid_user_json);
examples/json_examples.asthra,949,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_user: auto = match invalid_user_result {;,let invalid_user: <explicit_type> = match invalid_user_result {;
examples/json_examples.asthra,954,auto_type,MEDIUM,Auto type annotation should be explicit type,"let invalid_name_value_result: auto = json::json_path_get(invalid_user, ""name"");","let invalid_name_value_result: <explicit_type> = json::json_path_get(invalid_user, ""name"");"
examples/json_examples.asthra,955,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_name_value: auto = match invalid_name_value_result {;,let invalid_name_value: <explicit_type> = match invalid_name_value_result {;
examples/json_examples.asthra,959,auto_type,MEDIUM,Auto type annotation should be explicit type,"let invalid_name_valid_result: auto = json::validate_schema(invalid_name_value, name_schema);","let invalid_name_valid_result: <explicit_type> = json::validate_schema(invalid_name_value, name_schema);"
examples/json_examples.asthra,960,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_name_valid: auto = match invalid_name_valid_result {;,let invalid_name_valid: <explicit_type> = match invalid_name_valid_result {;
examples/json_examples.asthra,968,auto_type,MEDIUM,Auto type annotation should be explicit type,"let invalid_age_value_result: auto = json::json_path_get(invalid_user, ""age"");","let invalid_age_value_result: <explicit_type> = json::json_path_get(invalid_user, ""age"");"
examples/json_examples.asthra,969,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_age_value: auto = match invalid_age_value_result {;,let invalid_age_value: <explicit_type> = match invalid_age_value_result {;
examples/json_examples.asthra,973,auto_type,MEDIUM,Auto type annotation should be explicit type,"let invalid_age_valid_result: auto = json::validate_schema(invalid_age_value, age_schema);","let invalid_age_valid_result: <explicit_type> = json::validate_schema(invalid_age_value, age_schema);"
examples/json_examples.asthra,974,auto_type,MEDIUM,Auto type annotation should be explicit type,let invalid_age_valid: auto = match invalid_age_valid_result {;,let invalid_age_valid: <explicit_type> = match invalid_age_valid_result {;
examples/json_examples.asthra,989,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_streaming_parser() -> Result<void, json::JSONError> {","fn example_streaming_parser(none) -> Result<void, json::JSONError> {"
examples/json_examples.asthra,992,auto_type,MEDIUM,Auto type annotation should be explicit type,let config: auto = json::default_config();,let config: <explicit_type> = json::default_config();
examples/json_examples.asthra,996,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunks: auto = [;,let chunks: <explicit_type> = [;
examples/json_examples.asthra,1005,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_bytes: auto = string::to_utf8(chunks[i]);,let chunk_bytes: <explicit_type> = string::to_utf8(chunks[i]);
examples/json_examples.asthra,1006,auto_type,MEDIUM,Auto type annotation should be explicit type,"let feed_result: auto = json::stream_parser_feed(&mut parser, chunk_bytes);","let feed_result: <explicit_type> = json::stream_parser_feed(&mut parser, chunk_bytes);"
examples/json_examples.asthra,1026,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/json_examples.asthra,1050,auto_type,MEDIUM,Auto type annotation should be explicit type,let example_fn: auto = examples[i];,let example_fn: <explicit_type> = examples[i];
examples/json_examples.asthra,1051,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = example_fn();,let result: <explicit_type> = example_fn();
examples/hello_world.asthra,6,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/import_alias_examples.asthra,34,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_current_limitations() -> i32 {,fn demonstrate_current_limitations(none) -> i32 {
examples/import_alias_examples.asthra,64,empty_params,HIGH,Function with empty parameter list should use (none),fn working_example() -> i32 {,fn working_example(none) -> i32 {
examples/import_alias_examples.asthra,98,empty_params,HIGH,Function with empty parameter list should use (none),fn future_working_example() -> i32 {,fn future_working_example(none) -> i32 {
examples/import_alias_examples.asthra,144,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/ffi_error_example.asthra,12,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result: auto = libc::safe_open(filename, libc::O_RDONLY, 0);","let result: <explicit_type> = libc::safe_open(filename, libc::O_RDONLY, 0);"
examples/ffi_error_example.asthra,42,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result: auto = libc::safe_mkdir(dirname, 0o755);  // rwxr-xr-x permissions;","let result: <explicit_type> = libc::safe_mkdir(dirname, 0o755);  // rwxr-xr-x permissions;"
examples/ffi_error_example.asthra,63,auto_type,MEDIUM,Auto type annotation should be explicit type,let buffer: auto = [0u8; 1024];,let buffer: <explicit_type> = [0u8; 1024];
examples/ffi_error_example.asthra,66,auto_type,MEDIUM,Auto type annotation should be explicit type,"let read_operation: auto = fn() -> Result<usize, error::FFIError> {;","let read_operation: <explicit_type> = fn() -> Result<usize, error::FFIError> {;"
examples/ffi_error_example.asthra,67,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result: auto = libc::safe_read(fd, buffer);","let result: <explicit_type> = libc::safe_read(fd, buffer);"
examples/ffi_error_example.asthra,75,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result: auto = error::retry(read_operation, 3);","let result: <explicit_type> = error::retry(read_operation, 3);"
examples/ffi_error_example.asthra,85,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = string::from_bytes(buffer[0:bytes_read]);,let data: <explicit_type> = string::from_bytes(buffer[0:bytes_read]);
examples/ffi_error_example.asthra,96,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/ffi_error_example.asthra,102,auto_type,MEDIUM,Auto type annotation should be explicit type,"let _: auto = try_open_file(""non_existent_file.txt"");","let _: <explicit_type> = try_open_file(""non_existent_file.txt"");"
examples/ffi_error_example.asthra,109,auto_type,MEDIUM,Auto type annotation should be explicit type,"let fd_result: auto = libc::safe_open(filename, libc::O_CREAT | libc::O_WRONLY | libc::O_TRUNC, 0o644);","let fd_result: <explicit_type> = libc::safe_open(filename, libc::O_CREAT | libc::O_WRONLY | libc::O_TRUNC, 0o644);"
examples/ffi_error_example.asthra,115,auto_type,MEDIUM,Auto type annotation should be explicit type,"let write_result: auto = libc::safe_write(fd, data.bytes());","let write_result: <explicit_type> = libc::safe_write(fd, data.bytes());"
examples/ffi_error_example.asthra,127,auto_type,MEDIUM,Auto type annotation should be explicit type,let _: auto = libc::safe_close(fd);,let _: <explicit_type> = libc::safe_close(fd);
examples/ffi_error_example.asthra,130,auto_type,MEDIUM,Auto type annotation should be explicit type,let read_fd_result: auto = try_open_file(filename);,let read_fd_result: <explicit_type> = try_open_file(filename);
examples/ffi_error_example.asthra,135,auto_type,MEDIUM,Auto type annotation should be explicit type,let read_result: auto = retry_read_example(read_fd);,let read_result: <explicit_type> = retry_read_example(read_fd);
examples/ffi_error_example.asthra,147,auto_type,MEDIUM,Auto type annotation should be explicit type,let _: auto = libc::safe_close(read_fd);,let _: <explicit_type> = libc::safe_close(read_fd);
examples/ffi_error_example.asthra,155,auto_type,MEDIUM,Auto type annotation should be explicit type,let unlink_result: auto = libc::safe_unlink(filename);,let unlink_result: <explicit_type> = libc::safe_unlink(filename);
examples/ffi_error_example.asthra,175,auto_type,MEDIUM,Auto type annotation should be explicit type,let dir_result: auto = try_create_directory(dirname);,let dir_result: <explicit_type> = try_create_directory(dirname);
examples/ffi_error_example.asthra,178,auto_type,MEDIUM,Auto type annotation should be explicit type,let rmdir_result: auto = libc::safe_rmdir(dirname);,let rmdir_result: <explicit_type> = libc::safe_rmdir(dirname);
examples/test_types.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/advanced_concurrency_example.asthra,16,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_task_handles() -> void {,fn demonstrate_task_handles(none) -> void {
examples/advanced_concurrency_example.asthra,31,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Fibonacci(10) = {result1}"");","Convert to concatenation: ""log(""Fibonacci(10) ="" + result1 + "");"""
examples/advanced_concurrency_example.asthra,32,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Fibonacci(15) = {result2}"");","Convert to concatenation: ""log(""Fibonacci(15) ="" + result2 + "");"""
examples/advanced_concurrency_example.asthra,33,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Fibonacci(20) = {result3}"");","Convert to concatenation: ""log(""Fibonacci(20) ="" + result3 + "");"""
examples/advanced_concurrency_example.asthra,38,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Producer starting: {start} to {start + count}"");","Convert to concatenation: ""log(""Producer starting:"" + start + ""to"" + start + count + "");"""
examples/advanced_concurrency_example.asthra,42,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Sent: {i}"");","Convert to concatenation: ""log(""Sent:"" + i + "");"""
examples/advanced_concurrency_example.asthra,49,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Consumer {consumer_id} starting"");","Convert to concatenation: ""log(""Consumer"" + consumer_id + ""starting"");"""
examples/advanced_concurrency_example.asthra,53,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Consumer {consumer_id} received: {value}"");","Convert to concatenation: ""log(""Consumer"" + consumer_id + ""received:"" + value + "");"""
examples/advanced_concurrency_example.asthra,56,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Consumer {consumer_id} finished"");","Convert to concatenation: ""log(""Consumer"" + consumer_id + ""finished"");"""
examples/advanced_concurrency_example.asthra,59,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_channels() -> void {,fn demonstrate_channels(none) -> void {
examples/advanced_concurrency_example.asthra,104,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""String producer sent: {msg}"");","Convert to concatenation: ""log(""String producer sent:"" + msg + "");"""
examples/advanced_concurrency_example.asthra,111,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Number producer sent: {i * 10}"");","Convert to concatenation: ""log(""Number producer sent:"" + i * 10 + "");"""
examples/advanced_concurrency_example.asthra,115,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_select() -> void {,fn demonstrate_select(none) -> void {
examples/advanced_concurrency_example.asthra,142,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Result: {result}"");","Convert to concatenation: ""log(""Result:"" + result + "");"""
examples/advanced_concurrency_example.asthra,156,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Stage 1: {value} -> {processed}"");","Convert to concatenation: ""log(""Stage 1:"" + value + ""->"" + processed + "");"""
examples/advanced_concurrency_example.asthra,169,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Stage 2: {value} -> {processed}"");","Convert to concatenation: ""log(""Stage 2:"" + value + ""->"" + processed + "");"""
examples/advanced_concurrency_example.asthra,182,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Stage 3: {value} -> {processed}"");","Convert to concatenation: ""log(""Stage 3:"" + value + ""->"" + processed + "");"""
examples/advanced_concurrency_example.asthra,188,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_pipeline() -> void {,fn demonstrate_pipeline(none) -> void {
examples/advanced_concurrency_example.asthra,221,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Fed into pipeline: {value}"");","Convert to concatenation: ""log(""Fed into pipeline:"" + value + "");"""
examples/advanced_concurrency_example.asthra,232,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Pipeline output: {result}"");","Convert to concatenation: ""log(""Pipeline output:"" + result + "");"""
examples/advanced_concurrency_example.asthra,240,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Worker {worker_id} starting"");","Convert to concatenation: ""log(""Worker"" + worker_id + ""starting"");"""
examples/advanced_concurrency_example.asthra,246,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Worker {worker_id}: {work_item} -> {result}"");","Convert to concatenation: ""log(""Worker"" + worker_id + "":"" + work_item + ""->"" + result + "");"""
examples/advanced_concurrency_example.asthra,249,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Worker {worker_id} finished"");","Convert to concatenation: ""log(""Worker"" + worker_id + ""finished"");"""
examples/advanced_concurrency_example.asthra,252,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_fan_out_fan_in() -> void {,fn demonstrate_fan_out_fan_in(none) -> void {
examples/advanced_concurrency_example.asthra,282,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Queued work item: {i}"");","Convert to concatenation: ""log(""Queued work item:"" + i + "");"""
examples/advanced_concurrency_example.asthra,293,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","log(""Collected result: {result}"");","Convert to concatenation: ""log(""Collected result:"" + result + "");"""
examples/advanced_concurrency_example.asthra,300,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/concurrency_demo.asthra,3,empty_params,HIGH,Function with empty parameter list should use (none),fn worker_a() -> i32 {,fn worker_a(none) -> i32 {
examples/concurrency_demo.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),fn worker_b() -> i32 {,fn worker_b(none) -> i32 {
examples/concurrency_demo.asthra,15,empty_params,HIGH,Function with empty parameter list should use (none),fn worker_c() -> i32 {,fn worker_c(none) -> i32 {
examples/concurrency_demo.asthra,21,empty_params,HIGH,Function with empty parameter list should use (none),fn background_logger() -> i32 {,fn background_logger(none) -> i32 {
examples/concurrency_demo.asthra,27,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/ffi_example.asthra,25,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_ffi() -> Result<i32, string> {","fn demonstrate_ffi(none) -> Result<i32, string> {"
examples/ffi_example.asthra,51,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
examples/concurrency/tier3_external.asthra,10,empty_params,HIGH,Function with empty parameter list should use (none),fn tokio_runtime_new() -> *mut TokioRuntime;,fn tokio_runtime_new(none) -> *mut TokioRuntime;
examples/concurrency/tier3_external.asthra,36,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_tokio_high_performance() -> Result<PerformanceMetrics, string> {","fn example_tokio_high_performance(none) -> Result<PerformanceMetrics, string> {"
examples/concurrency/tier3_external.asthra,39,auto_type,MEDIUM,Auto type annotation should be explicit type,let runtime: auto = tokio_runtime_new();,let runtime: <explicit_type> = tokio_runtime_new();
examples/concurrency/tier3_external.asthra,49,auto_type,MEDIUM,Auto type annotation should be explicit type,"let handle: auto = tokio_spawn(runtime, move || {;","let handle: <explicit_type> = tokio_spawn(runtime, move || {;"
examples/concurrency/tier3_external.asthra,57,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_system_time_ms();,let start_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,60,auto_type,MEDIUM,Auto type annotation should be explicit type,"let results: auto = tokio_await_all(runtime, handles);","let results: <explicit_type> = tokio_await_all(runtime, handles);"
examples/concurrency/tier3_external.asthra,61,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Tokio await failed: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Tokio await failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,66,auto_type,MEDIUM,Auto type annotation should be explicit type,let end_time: auto = get_system_time_ms();,let end_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,67,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_time: auto = end_time - start_time;,let total_time: <explicit_type> = end_time - start_time;
examples/concurrency/tier3_external.asthra,72,auto_type,MEDIUM,Auto type annotation should be explicit type,let metrics: auto = PerformanceMetrics {;,let metrics: <explicit_type> = PerformanceMetrics {;
examples/concurrency/tier3_external.asthra,80,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""Tokio performance: {} tasks in {} ms ({:.2} tasks/sec)"",","Convert to concatenation: ""println(""Tokio performance: {} tasks in {} ms ("" + :.2 + ""tasks/sec)"","""
examples/concurrency/tier3_external.asthra,119,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_rayon_parallel_processing() -> Result<ProcessingResults, string> {","fn example_rayon_parallel_processing(none) -> Result<ProcessingResults, string> {"
examples/concurrency/tier3_external.asthra,123,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = rayon_init_thread_pool(thread_count);,let pool: <explicit_type> = rayon_init_thread_pool(thread_count);
examples/concurrency/tier3_external.asthra,127,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = generate_large_dataset(data_size);,let data: <explicit_type> = generate_large_dataset(data_size);
examples/concurrency/tier3_external.asthra,131,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_system_time_ms();,let start_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,134,auto_type,MEDIUM,Auto type annotation should be explicit type,"let mapped_data: auto = rayon_par_iter_map(pool, data.clone(), |x| x * x);","let mapped_data: <explicit_type> = rayon_par_iter_map(pool, data.clone(), |x| x * x);"
examples/concurrency/tier3_external.asthra,135,auto_type,MEDIUM,Auto type annotation should be explicit type,let map_time: auto = get_system_time_ms();,let map_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,138,auto_type,MEDIUM,Auto type annotation should be explicit type,"let filtered_data: auto = rayon_par_iter_filter_map(pool, mapped_data, |x| {;","let filtered_data: <explicit_type> = rayon_par_iter_filter_map(pool, mapped_data, |x| {;"
examples/concurrency/tier3_external.asthra,145,auto_type,MEDIUM,Auto type annotation should be explicit type,let filter_time: auto = get_system_time_ms();,let filter_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,148,auto_type,MEDIUM,Auto type annotation should be explicit type,"let sum: auto = rayon_par_iter_reduce(pool, filtered_data.clone(), 0, |a, b| a + b);","let sum: <explicit_type> = rayon_par_iter_reduce(pool, filtered_data.clone(), 0, |a, b| a + b);"
examples/concurrency/tier3_external.asthra,149,auto_type,MEDIUM,Auto type annotation should be explicit type,let reduce_time: auto = get_system_time_ms();,let reduce_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,154,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = ProcessingResults {;,let results: <explicit_type> = ProcessingResults {;
examples/concurrency/tier3_external.asthra,167,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""Performance: {:.2} elements/ms"", results.throughput_elements_per_ms);","Convert to concatenation: ""println(""Performance:"" + :.2 + ""elements/ms"", results.throughput_elements_per_ms);"""
examples/concurrency/tier3_external.asthra,197,empty_params,HIGH,Function with empty parameter list should use (none),fn actix_system_new() -> ActixSystem;,fn actix_system_new(none) -> ActixSystem;
examples/concurrency/tier3_external.asthra,217,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_actor_system() -> Result<ActorSystemResults, string> {","fn example_actor_system(none) -> Result<ActorSystemResults, string> {"
examples/concurrency/tier3_external.asthra,220,auto_type,MEDIUM,Auto type annotation should be explicit type,let system: auto = actix_system_new();,let system: <explicit_type> = actix_system_new();
examples/concurrency/tier3_external.asthra,223,auto_type,MEDIUM,Auto type annotation should be explicit type,"let worker_actors: auto = create_worker_actors(system, 5);","let worker_actors: <explicit_type> = create_worker_actors(system, 5);"
examples/concurrency/tier3_external.asthra,224,auto_type,MEDIUM,Auto type annotation should be explicit type,let coordinator_actor: auto = create_coordinator_actor(system);,let coordinator_actor: <explicit_type> = create_coordinator_actor(system);
examples/concurrency/tier3_external.asthra,225,auto_type,MEDIUM,Auto type annotation should be explicit type,let monitor_actor: auto = create_monitor_actor(system);,let monitor_actor: <explicit_type> = create_monitor_actor(system);
examples/concurrency/tier3_external.asthra,229,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_system_time_ms();,let start_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,232,auto_type,MEDIUM,Auto type annotation should be explicit type,let work_items: auto = generate_work_messages(100);,let work_items: <explicit_type> = generate_work_messages(100);
examples/concurrency/tier3_external.asthra,236,auto_type,MEDIUM,Auto type annotation should be explicit type,let target_actor: auto = worker_actors[index % worker_actors.len()];,let target_actor: <explicit_type> = worker_actors[index % worker_actors.len()];
examples/concurrency/tier3_external.asthra,237,auto_type,MEDIUM,Auto type annotation should be explicit type,"let future: auto = actix_send_message(target_actor, work_item);","let future: <explicit_type> = actix_send_message(target_actor, work_item);"
examples/concurrency/tier3_external.asthra,242,auto_type,MEDIUM,Auto type annotation should be explicit type,"let monitor_message: auto = create_monitor_message(""track_progress"", work_items.len());","let monitor_message: <explicit_type> = create_monitor_message(""track_progress"", work_items.len());"
examples/concurrency/tier3_external.asthra,246,auto_type,MEDIUM,Auto type annotation should be explicit type,"let coordination_message: auto = create_coordination_message(""await_completion"");","let coordination_message: <explicit_type> = create_coordination_message(""await_completion"");"
examples/concurrency/tier3_external.asthra,247,auto_type,MEDIUM,Auto type annotation should be explicit type,"let completion_future: auto = actix_send_message(coordinator_actor, coordination_message);","let completion_future: <explicit_type> = actix_send_message(coordinator_actor, coordination_message);"
examples/concurrency/tier3_external.asthra,250,auto_type,MEDIUM,Auto type annotation should be explicit type,let processing_time: auto = simulate_actor_processing_time(work_items.len());,let processing_time: <explicit_type> = simulate_actor_processing_time(work_items.len());
examples/concurrency/tier3_external.asthra,252,auto_type,MEDIUM,Auto type annotation should be explicit type,let end_time: auto = get_system_time_ms();,let end_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,257,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = ActorSystemResults {;,let results: <explicit_type> = ActorSystemResults {;
examples/concurrency/tier3_external.asthra,282,auto_type,MEDIUM,Auto type annotation should be explicit type,let worker: auto = create_worker_actor(i);,let worker: <explicit_type> = create_worker_actor(i);
examples/concurrency/tier3_external.asthra,283,auto_type,MEDIUM,Auto type annotation should be explicit type,"let addr: auto = actix_spawn_actor(system, worker);","let addr: <explicit_type> = actix_spawn_actor(system, worker);"
examples/concurrency/tier3_external.asthra,296,auto_type,MEDIUM,Auto type annotation should be explicit type,"let coordinator: auto = create_actor_with_role(""coordinator"");","let coordinator: <explicit_type> = create_actor_with_role(""coordinator"");"
examples/concurrency/tier3_external.asthra,301,auto_type,MEDIUM,Auto type annotation should be explicit type,"let monitor: auto = create_actor_with_role(""monitor"");","let monitor: <explicit_type> = create_actor_with_role(""monitor"");"
examples/concurrency/tier3_external.asthra,308,auto_type,MEDIUM,Auto type annotation should be explicit type,"let message: auto = create_work_message(i, format!(""work_data_{}"", i));","let message: <explicit_type> = create_work_message(i, format!(""work_data_{}"", i));"
examples/concurrency/tier3_external.asthra,320,empty_params,HIGH,Function with empty parameter list should use (none),"fn MPI_Init() -> Result<(), MPIError>;","fn MPI_Init(none) -> Result<(), MPIError>;"
examples/concurrency/tier3_external.asthra,321,empty_params,HIGH,Function with empty parameter list should use (none),"fn MPI_Finalize() -> Result<(), MPIError>;","fn MPI_Finalize(none) -> Result<(), MPIError>;"
examples/concurrency/tier3_external.asthra,345,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_distributed_computing() -> Result<DistributedResults, string> {","fn example_distributed_computing(none) -> Result<DistributedResults, string> {"
examples/concurrency/tier3_external.asthra,349,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match MPI_Init().map_err(|e| format!(""MPI initialization failed: {:?}"", e)) {","Convert to concatenation: ""match MPI_Init().map_err(|e| format!(""MPI initialization failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,354,auto_type,MEDIUM,Auto type annotation should be explicit type,let rank: auto = MPI_Comm_rank(MPI_COMM_WORLD);,let rank: <explicit_type> = MPI_Comm_rank(MPI_COMM_WORLD);
examples/concurrency/tier3_external.asthra,355,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to get MPI rank: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to get MPI rank:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,359,auto_type,MEDIUM,Auto type annotation should be explicit type,let size: auto = MPI_Comm_size(MPI_COMM_WORLD);,let size: <explicit_type> = MPI_Comm_size(MPI_COMM_WORLD);
examples/concurrency/tier3_external.asthra,360,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to get MPI size: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to get MPI size:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,367,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_system_time_ms();,let start_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,370,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = if rank == 0 {;,let results: <explicit_type> = if rank == 0 {;
examples/concurrency/tier3_external.asthra,381,auto_type,MEDIUM,Auto type annotation should be explicit type,let end_time: auto = get_system_time_ms();,let end_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,384,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match MPI_Finalize().map_err(|e| format!(""MPI finalization failed: {:?}"", e)) {","Convert to concatenation: ""match MPI_Finalize().map_err(|e| format!(""MPI finalization failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,389,auto_type,MEDIUM,Auto type annotation should be explicit type,let distributed_results: auto = DistributedResults {;,let distributed_results: <explicit_type> = DistributedResults {;
examples/concurrency/tier3_external.asthra,425,auto_type,MEDIUM,Auto type annotation should be explicit type,let work_size_ptr: auto = &work_size as *const i32 as *mut void;,let work_size_ptr: <explicit_type> = &work_size as *const i32 as *mut void;
examples/concurrency/tier3_external.asthra,427,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Broadcast failed: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Broadcast failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,433,auto_type,MEDIUM,Auto type annotation should be explicit type,"let local_result: auto = distributed_computation_chunk(0, work_size / size);","let local_result: <explicit_type> = distributed_computation_chunk(0, work_size / size);"
examples/concurrency/tier3_external.asthra,439,auto_type,MEDIUM,Auto type annotation should be explicit type,let worker_result_ptr: auto = &mut worker_result as *mut i32 as *mut void;,let worker_result_ptr: <explicit_type> = &mut worker_result as *mut i32 as *mut void;
examples/concurrency/tier3_external.asthra,442,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Receive from worker {} failed: {:?}"", worker_rank, e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Receive from worker {} failed:"" + :? + "", worker_rank, e)) {"""
examples/concurrency/tier3_external.asthra,462,auto_type,MEDIUM,Auto type annotation should be explicit type,let work_size_ptr: auto = &mut work_size as *mut i32 as *mut void;,let work_size_ptr: <explicit_type> = &mut work_size as *mut i32 as *mut void;
examples/concurrency/tier3_external.asthra,464,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Broadcast receive failed: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Broadcast receive failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,470,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_size: auto = work_size / size;,let chunk_size: <explicit_type> = work_size / size;
examples/concurrency/tier3_external.asthra,471,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_index: auto = rank * chunk_size;,let start_index: <explicit_type> = rank * chunk_size;
examples/concurrency/tier3_external.asthra,472,auto_type,MEDIUM,Auto type annotation should be explicit type,"let local_result: auto = distributed_computation_chunk(start_index, chunk_size);","let local_result: <explicit_type> = distributed_computation_chunk(start_index, chunk_size);"
examples/concurrency/tier3_external.asthra,475,auto_type,MEDIUM,Auto type annotation should be explicit type,let local_result_ptr: auto = &local_result as *const i32 as *mut void;,let local_result_ptr: <explicit_type> = &local_result as *const i32 as *mut void;
examples/concurrency/tier3_external.asthra,477,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Send to master failed: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Send to master failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,518,empty_params,HIGH,Function with empty parameter list should use (none),"fn cuda_device_count() -> Result<i32, CudaError>;","fn cuda_device_count(none) -> Result<i32, CudaError>;"
examples/concurrency/tier3_external.asthra,525,empty_params,HIGH,Function with empty parameter list should use (none),"fn cuda_device_synchronize() -> Result<(), CudaError>;","fn cuda_device_synchronize(none) -> Result<(), CudaError>;"
examples/concurrency/tier3_external.asthra,536,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_gpu_computing() -> Result<GPUResults, string> {","fn example_gpu_computing(none) -> Result<GPUResults, string> {"
examples/concurrency/tier3_external.asthra,540,auto_type,MEDIUM,Auto type annotation should be explicit type,let device_count: auto = cuda_device_count();,let device_count: <explicit_type> = cuda_device_count();
examples/concurrency/tier3_external.asthra,541,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to get CUDA device count: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to get CUDA device count:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,554,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to set CUDA device: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to set CUDA device:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,560,auto_type,MEDIUM,Auto type annotation should be explicit type,let data_bytes: auto = data_size * 4; // 4 bytes per i32;,let data_bytes: <explicit_type> = data_size * 4; // 4 bytes per i32;
examples/concurrency/tier3_external.asthra,563,auto_type,MEDIUM,Auto type annotation should be explicit type,let host_input: auto = generate_gpu_input_data(data_size);,let host_input: <explicit_type> = generate_gpu_input_data(data_size);
examples/concurrency/tier3_external.asthra,567,auto_type,MEDIUM,Auto type annotation should be explicit type,let device_input: auto = cuda_malloc(data_bytes as usize);,let device_input: <explicit_type> = cuda_malloc(data_bytes as usize);
examples/concurrency/tier3_external.asthra,568,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to allocate device input memory: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to allocate device input memory:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,572,auto_type,MEDIUM,Auto type annotation should be explicit type,let device_output: auto = cuda_malloc(data_bytes as usize);,let device_output: <explicit_type> = cuda_malloc(data_bytes as usize);
examples/concurrency/tier3_external.asthra,573,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Failed to allocate device output memory: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Failed to allocate device output memory:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,578,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_system_time_ms();,let start_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,585,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match ).map_err(|e| format!(""Failed to copy data to device: {:?}"", e)) {","Convert to concatenation: ""match ).map_err(|e| format!(""Failed to copy data to device:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,590,auto_type,MEDIUM,Auto type annotation should be explicit type,let copy_to_device_time: auto = get_system_time_ms();,let copy_to_device_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,593,auto_type,MEDIUM,Auto type annotation should be explicit type,let kernel: auto = load_vector_add_kernel();,let kernel: <explicit_type> = load_vector_add_kernel();
examples/concurrency/tier3_external.asthra,595,auto_type,MEDIUM,Auto type annotation should be explicit type,let grid_size: auto = (data_size + block_size - 1) / block_size;,let grid_size: <explicit_type> = (data_size + block_size - 1) / block_size;
examples/concurrency/tier3_external.asthra,602,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match ).map_err(|e| format!(""Failed to launch kernel: {:?}"", e)) {","Convert to concatenation: ""match ).map_err(|e| format!(""Failed to launch kernel:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,609,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match .map_err(|e| format!(""Kernel execution failed: {:?}"", e)) {","Convert to concatenation: ""match .map_err(|e| format!(""Kernel execution failed:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,614,auto_type,MEDIUM,Auto type annotation should be explicit type,let kernel_time: auto = get_system_time_ms();,let kernel_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,621,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","match ).map_err(|e| format!(""Failed to copy data from device: {:?}"", e)) {","Convert to concatenation: ""match ).map_err(|e| format!(""Failed to copy data from device:"" + :? + "", e)) {"""
examples/concurrency/tier3_external.asthra,626,auto_type,MEDIUM,Auto type annotation should be explicit type,let copy_from_device_time: auto = get_system_time_ms();,let copy_from_device_time: <explicit_type> = get_system_time_ms();
examples/concurrency/tier3_external.asthra,632,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_time: auto = copy_from_device_time - start_time;,let total_time: <explicit_type> = copy_from_device_time - start_time;
examples/concurrency/tier3_external.asthra,633,auto_type,MEDIUM,Auto type annotation should be explicit type,let kernel_only_time: auto = kernel_time - copy_to_device_time;,let kernel_only_time: <explicit_type> = kernel_time - copy_to_device_time;
examples/concurrency/tier3_external.asthra,636,auto_type,MEDIUM,Auto type annotation should be explicit type,"let validation_passed: auto = validate_gpu_results(&host_input, &host_output);","let validation_passed: <explicit_type> = validate_gpu_results(&host_input, &host_output);"
examples/concurrency/tier3_external.asthra,638,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = GPUResults {;,let results: <explicit_type> = GPUResults {;
examples/concurrency/tier3_external.asthra,648,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""GPU computation completed: {} elements in {} ms ({:.2} elements/ms)"",","Convert to concatenation: ""println(""GPU computation completed: {} elements in {} ms ("" + :.2 + ""elements/ms)"","""
examples/concurrency/tier3_external.asthra,650,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""Memory bandwidth: {:.2} GB/s"", results.memory_bandwidth_gb_per_s);","Convert to concatenation: ""println(""Memory bandwidth:"" + :.2 + ""GB/s"", results.memory_bandwidth_gb_per_s);"""
examples/concurrency/tier3_external.asthra,673,empty_params,HIGH,Function with empty parameter list should use (none),fn load_vector_add_kernel() -> CudaKernel {,fn load_vector_add_kernel(none) -> CudaKernel {
examples/concurrency/tier3_external.asthra,685,auto_type,MEDIUM,Auto type annotation should be explicit type,let expected: auto = inp * 2; // Assuming kernel doubles the input;,let expected: <explicit_type> = inp * 2; // Assuming kernel doubles the input;
examples/concurrency/tier3_external.asthra,696,auto_type,MEDIUM,Auto type annotation should be explicit type,let bytes_per_second: auto = (bytes_transferred as f64) / (time_ms as f64 / 1000.0);,let bytes_per_second: <explicit_type> = (bytes_transferred as f64) / (time_ms as f64 / 1000.0);
examples/concurrency/tier3_external.asthra,704,empty_params,HIGH,Function with empty parameter list should use (none),fn get_system_time_ms() -> i64 {,fn get_system_time_ms(none) -> i64 {
examples/concurrency/tier3_external.asthra,748,empty_params,HIGH,Function with empty parameter list should use (none),"fn main() -> Result<(), string> {","fn main(none) -> Result<(), string> {"
examples/concurrency/tier3_external.asthra,755,auto_type,MEDIUM,Auto type annotation should be explicit type,let tokio_results_result: auto = example_tokio_high_performance();,let tokio_results_result: <explicit_type> = example_tokio_high_performance();
examples/concurrency/tier3_external.asthra,756,auto_type,MEDIUM,Auto type annotation should be explicit type,let tokio_results: auto = match tokio_results_result {;,let tokio_results: <explicit_type> = match tokio_results_result {;
examples/concurrency/tier3_external.asthra,760,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println!(""Tokio achieved {:.2} tasks/second"", tokio_results.tasks_per_second);","Convert to concatenation: ""println!(""Tokio achieved"" + :.2 + ""tasks/second"", tokio_results.tasks_per_second);"""
examples/concurrency/tier3_external.asthra,764,auto_type,MEDIUM,Auto type annotation should be explicit type,let rayon_results_result: auto = example_rayon_parallel_processing();,let rayon_results_result: <explicit_type> = example_rayon_parallel_processing();
examples/concurrency/tier3_external.asthra,765,auto_type,MEDIUM,Auto type annotation should be explicit type,let rayon_results: auto = match rayon_results_result {;,let rayon_results: <explicit_type> = match rayon_results_result {;
examples/concurrency/tier3_external.asthra,769,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println!(""Rayon processed {:.2} elements/ms"", rayon_results.throughput_elements_per_ms);","Convert to concatenation: ""println!(""Rayon processed"" + :.2 + ""elements/ms"", rayon_results.throughput_elements_per_ms);"""
examples/concurrency/tier3_external.asthra,773,auto_type,MEDIUM,Auto type annotation should be explicit type,let actor_results_result: auto = example_actor_system();,let actor_results_result: <explicit_type> = example_actor_system();
examples/concurrency/tier3_external.asthra,774,auto_type,MEDIUM,Auto type annotation should be explicit type,let actor_results: auto = match actor_results_result {;,let actor_results: <explicit_type> = match actor_results_result {;
examples/concurrency/tier3_external.asthra,778,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println!(""Actor system achieved {:.2} messages/second"", actor_results.messages_per_second);","Convert to concatenation: ""println!(""Actor system achieved"" + :.2 + ""messages/second"", actor_results.messages_per_second);"""
examples/concurrency/tier3_external.asthra,782,auto_type,MEDIUM,Auto type annotation should be explicit type,let distributed_results_result: auto = example_distributed_computing();,let distributed_results_result: <explicit_type> = example_distributed_computing();
examples/concurrency/tier3_external.asthra,783,auto_type,MEDIUM,Auto type annotation should be explicit type,let distributed_results: auto = match distributed_results_result {;,let distributed_results: <explicit_type> = match distributed_results_result {;
examples/concurrency/tier3_external.asthra,792,auto_type,MEDIUM,Auto type annotation should be explicit type,let gpu_results_result: auto = example_gpu_computing();,let gpu_results_result: <explicit_type> = example_gpu_computing();
examples/concurrency/tier3_external.asthra,793,auto_type,MEDIUM,Auto type annotation should be explicit type,let gpu_results: auto = match gpu_results_result {;,let gpu_results: <explicit_type> = match gpu_results_result {;
examples/concurrency/tier3_external.asthra,797,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println!(""GPU computation achieved {:.2} GB/s memory bandwidth"",","Convert to concatenation: ""println!(""GPU computation achieved"" + :.2 + ""GB/s memory bandwidth"","""
examples/concurrency/migration_guide.asthra,13,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,37,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_result: auto = patterns.WorkerPool::<i32>::new(4);,let pool_result: <explicit_type> = patterns.WorkerPool::<i32>::new(4);
examples/concurrency/migration_guide.asthra,38,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = match pool_result {;,let pool: <explicit_type> = match pool_result {;
examples/concurrency/migration_guide.asthra,83,empty_params,HIGH,Function with empty parameter list should use (none),"fn tier1_producer_consumer() -> Result<Vec<i32>, string> {","fn tier1_producer_consumer(none) -> Result<Vec<i32>, string> {"
examples/concurrency/migration_guide.asthra,85,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = produce_all_data();,let data: <explicit_type> = produce_all_data();
examples/concurrency/migration_guide.asthra,90,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,99,empty_params,HIGH,Function with empty parameter list should use (none),fn produce_all_data() -> Vec<i32> {,fn produce_all_data(none) -> Vec<i32> {
examples/concurrency/migration_guide.asthra,115,empty_params,HIGH,Function with empty parameter list should use (none),"fn tier2_producer_consumer() -> Result<Vec<i32>, string> {","fn tier2_producer_consumer(none) -> Result<Vec<i32>, string> {"
examples/concurrency/migration_guide.asthra,116,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_pair_result: auto = channels.channel_pair<i32>(10);,let channel_pair_result: <explicit_type> = channels.channel_pair<i32>(10);
examples/concurrency/migration_guide.asthra,123,auto_type,MEDIUM,Auto type annotation should be explicit type,let producer: auto = spawn_with_handle move || {;,let producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,138,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer: auto = spawn_with_handle move || {;,let consumer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,143,auto_type,MEDIUM,Auto type annotation should be explicit type,let processed_result: auto = consume_item_advanced(item);,let processed_result: <explicit_type> = consume_item_advanced(item);
examples/concurrency/migration_guide.asthra,144,auto_type,MEDIUM,Auto type annotation should be explicit type,let processed: auto = match processed_result {;,let processed: <explicit_type> = match processed_result {;
examples/concurrency/migration_guide.asthra,162,auto_type,MEDIUM,Auto type annotation should be explicit type,let results_result: auto = await consumer;,let results_result: <explicit_type> = await consumer;
examples/concurrency/migration_guide.asthra,163,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = match results_result {;,let results: <explicit_type> = match results_result {;
examples/concurrency/migration_guide.asthra,192,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,196,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_result: auto = await handle;,let result_result: <explicit_type> = await handle;
examples/concurrency/migration_guide.asthra,197,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/migration_guide.asthra,209,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_pair_result: auto = channels.channel_pair<i32>(1);,let channel_pair_result: <explicit_type> = channels.channel_pair<i32>(1);
examples/concurrency/migration_guide.asthra,216,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_result: auto = process_data_go_style(data);,let result_result: <explicit_type> = process_data_go_style(data);
examples/concurrency/migration_guide.asthra,217,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/migration_guide.asthra,300,empty_params,HIGH,Function with empty parameter list should use (none),"fn rust_to_asthra_tier1() -> Result<i32, string> {","fn rust_to_asthra_tier1(none) -> Result<i32, string> {"
examples/concurrency/migration_guide.asthra,301,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle expensive_computation();,let handle: <explicit_type> = spawn_with_handle expensive_computation();
examples/concurrency/migration_guide.asthra,302,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_result: auto = await handle;,let result_result: <explicit_type> = await handle;
examples/concurrency/migration_guide.asthra,303,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/migration_guide.asthra,319,empty_params,HIGH,Function with empty parameter list should use (none),"fn rust_async_to_asthra() -> Result<i32, string> {","fn rust_async_to_asthra(none) -> Result<i32, string> {"
examples/concurrency/migration_guide.asthra,320,auto_type,MEDIUM,Auto type annotation should be explicit type,let step1_handle: auto = spawn_with_handle async_step1();,let step1_handle: <explicit_type> = spawn_with_handle async_step1();
examples/concurrency/migration_guide.asthra,321,auto_type,MEDIUM,Auto type annotation should be explicit type,let step1_result_result: auto = await step1_handle;,let step1_result_result: <explicit_type> = await step1_handle;
examples/concurrency/migration_guide.asthra,322,auto_type,MEDIUM,Auto type annotation should be explicit type,let step1_result: auto = match step1_result_result {;,let step1_result: <explicit_type> = match step1_result_result {;
examples/concurrency/migration_guide.asthra,327,auto_type,MEDIUM,Auto type annotation should be explicit type,let step2_handle: auto = spawn_with_handle async_step2(step1_result);,let step2_handle: <explicit_type> = spawn_with_handle async_step2(step1_result);
examples/concurrency/migration_guide.asthra,328,auto_type,MEDIUM,Auto type annotation should be explicit type,let step2_result_result: auto = await step2_handle;,let step2_result_result: <explicit_type> = await step2_handle;
examples/concurrency/migration_guide.asthra,329,auto_type,MEDIUM,Auto type annotation should be explicit type,let step2_result: auto = match step2_result_result {;,let step2_result: <explicit_type> = match step2_result_result {;
examples/concurrency/migration_guide.asthra,334,auto_type,MEDIUM,Auto type annotation should be explicit type,let step3_handle: auto = spawn_with_handle async_step3(step2_result);,let step3_handle: <explicit_type> = spawn_with_handle async_step3(step2_result);
examples/concurrency/migration_guide.asthra,335,auto_type,MEDIUM,Auto type annotation should be explicit type,let step3_result_result: auto = await step3_handle;,let step3_result_result: <explicit_type> = await step3_handle;
examples/concurrency/migration_guide.asthra,336,auto_type,MEDIUM,Auto type annotation should be explicit type,let step3_result: auto = match step3_result_result {;,let step3_result: <explicit_type> = match step3_result_result {;
examples/concurrency/migration_guide.asthra,344,empty_params,HIGH,Function with empty parameter list should use (none),"fn expensive_computation() -> Result<i32, string> {","fn expensive_computation(none) -> Result<i32, string> {"
examples/concurrency/migration_guide.asthra,353,empty_params,HIGH,Function with empty parameter list should use (none),"fn async_step1() -> Result<i32, string> {","fn async_step1(none) -> Result<i32, string> {"
examples/concurrency/migration_guide.asthra,383,empty_params,HIGH,Function with empty parameter list should use (none),"fn java_executor_to_asthra() -> Result<Vec<i32>, string> {","fn java_executor_to_asthra(none) -> Result<Vec<i32>, string> {"
examples/concurrency/migration_guide.asthra,384,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_result: auto = patterns.WorkerPool::<i32>::new(4);,let pool_result: <explicit_type> = patterns.WorkerPool::<i32>::new(4);
examples/concurrency/migration_guide.asthra,385,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = match pool_result {;,let pool: <explicit_type> = match pool_result {;
examples/concurrency/migration_guide.asthra,431,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,447,auto_type,MEDIUM,Auto type annotation should be explicit type,let cpu_count: auto = get_cpu_count();,let cpu_count: <explicit_type> = get_cpu_count();
examples/concurrency/migration_guide.asthra,448,auto_type,MEDIUM,Auto type annotation should be explicit type,"let chunk_size: auto = max(1, data.len() / cpu_count);","let chunk_size: <explicit_type> = max(1, data.len() / cpu_count);"
examples/concurrency/migration_guide.asthra,454,auto_type,MEDIUM,Auto type annotation should be explicit type,"let chunk_end: auto = min(chunk_start + chunk_size, data.len());","let chunk_end: <explicit_type> = min(chunk_start + chunk_size, data.len());"
examples/concurrency/migration_guide.asthra,455,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_data: auto = data[chunk_start..chunk_end].to_vec();,let chunk_data: <explicit_type> = data[chunk_start..chunk_end].to_vec();
examples/concurrency/migration_guide.asthra,457,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,465,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_results_result: auto = await handle;,let chunk_results_result: <explicit_type> = await handle;
examples/concurrency/migration_guide.asthra,466,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_results: auto = match chunk_results_result {;,let chunk_results: <explicit_type> = match chunk_results_result {;
examples/concurrency/migration_guide.asthra,489,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_result: auto = patterns.WorkerPool::<i32>::new(get_cpu_count());,let pool_result: <explicit_type> = patterns.WorkerPool::<i32>::new(get_cpu_count());
examples/concurrency/migration_guide.asthra,490,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = match pool_result {;,let pool: <explicit_type> = match pool_result {;
examples/concurrency/migration_guide.asthra,535,empty_params,HIGH,Function with empty parameter list should use (none),"fn basic_error_handling() -> Result<Vec<i32>, string> {","fn basic_error_handling(none) -> Result<Vec<i32>, string> {"
examples/concurrency/migration_guide.asthra,539,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,554,empty_params,HIGH,Function with empty parameter list should use (none),"fn robust_error_handling() -> Result<ProcessingReport, string> {","fn robust_error_handling(none) -> Result<ProcessingReport, string> {"
examples/concurrency/migration_guide.asthra,558,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/migration_guide.asthra,580,auto_type,MEDIUM,Auto type annotation should be explicit type,let report: auto = ProcessingReport {;,let report: <explicit_type> = ProcessingReport {;
examples/concurrency/migration_guide.asthra,589,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","Result.Err(format!(""Too many failures: only {:.1}% success rate"", report.success_rate * 100.0))","Convert to concatenation: ""Result.Err(format!(""Too many failures: only"" + :.1 + ""% success rate"", report.success_rate * 100.0))"""
examples/concurrency/migration_guide.asthra,649,empty_params,HIGH,Function with empty parameter list should use (none),"fn tier2_performance_limit() -> Result<(), string> {","fn tier2_performance_limit(none) -> Result<(), string> {"
examples/concurrency/migration_guide.asthra,661,empty_params,HIGH,Function with empty parameter list should use (none),fn tokio_runtime_new() -> *mut TokioRuntime;,fn tokio_runtime_new(none) -> *mut TokioRuntime;
examples/concurrency/migration_guide.asthra,669,empty_params,HIGH,Function with empty parameter list should use (none),"fn tier3_high_performance() -> Result<(), string> {","fn tier3_high_performance(none) -> Result<(), string> {"
examples/concurrency/migration_guide.asthra,676,auto_type,MEDIUM,Auto type annotation should be explicit type,let runtime: auto = tokio_runtime_new();,let runtime: <explicit_type> = tokio_runtime_new();
examples/concurrency/migration_guide.asthra,686,empty_params,HIGH,Function with empty parameter list should use (none),fn get_cpu_count() -> usize {,fn get_cpu_count(none) -> usize {
examples/concurrency/migration_guide.asthra,702,empty_params,HIGH,Function with empty parameter list should use (none),"fn main() -> Result<(), string> {","fn main(none) -> Result<(), string> {"
examples/concurrency/migration_guide.asthra,706,auto_type,MEDIUM,Auto type annotation should be explicit type,"let test_data: auto = vec![1, 2, 3, 4, 5];","let test_data: <explicit_type> = vec![1, 2, 3, 4, 5];"
examples/concurrency/migration_guide.asthra,708,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier1_results_result: auto = tier1_simple_processing(test_data.clone());,let tier1_results_result: <explicit_type> = tier1_simple_processing(test_data.clone());
examples/concurrency/migration_guide.asthra,709,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier1_results: auto = match tier1_results_result {;,let tier1_results: <explicit_type> = match tier1_results_result {;
examples/concurrency/migration_guide.asthra,715,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier2_results_result: auto = tier2_managed_processing(test_data);,let tier2_results_result: <explicit_type> = tier2_managed_processing(test_data);
examples/concurrency/migration_guide.asthra,716,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier2_results: auto = match tier2_results_result {;,let tier2_results: <explicit_type> = match tier2_results_result {;
examples/concurrency/migration_guide.asthra,723,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier1_pc_results_result: auto = tier1_producer_consumer();,let tier1_pc_results_result: <explicit_type> = tier1_producer_consumer();
examples/concurrency/migration_guide.asthra,724,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier1_pc_results: auto = match tier1_pc_results_result {;,let tier1_pc_results: <explicit_type> = match tier1_pc_results_result {;
examples/concurrency/migration_guide.asthra,730,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier2_pc_results_result: auto = tier2_producer_consumer();,let tier2_pc_results_result: <explicit_type> = tier2_producer_consumer();
examples/concurrency/migration_guide.asthra,731,auto_type,MEDIUM,Auto type annotation should be explicit type,let tier2_pc_results: auto = match tier2_pc_results_result {;,let tier2_pc_results: <explicit_type> = match tier2_pc_results_result {;
examples/concurrency/migration_guide.asthra,738,auto_type,MEDIUM,Auto type annotation should be explicit type,let go_result_result: auto = go_to_asthra_tier1(100);,let go_result_result: <explicit_type> = go_to_asthra_tier1(100);
examples/concurrency/migration_guide.asthra,739,auto_type,MEDIUM,Auto type annotation should be explicit type,let go_result: auto = match go_result_result {;,let go_result: <explicit_type> = match go_result_result {;
examples/concurrency/migration_guide.asthra,745,auto_type,MEDIUM,Auto type annotation should be explicit type,let rust_result_result: auto = rust_to_asthra_tier1();,let rust_result_result: <explicit_type> = rust_to_asthra_tier1();
examples/concurrency/migration_guide.asthra,746,auto_type,MEDIUM,Auto type annotation should be explicit type,let rust_result: auto = match rust_result_result {;,let rust_result: <explicit_type> = match rust_result_result {;
examples/concurrency/migration_guide.asthra,752,auto_type,MEDIUM,Auto type annotation should be explicit type,let java_results_result: auto = java_executor_to_asthra();,let java_results_result: <explicit_type> = java_executor_to_asthra();
examples/concurrency/migration_guide.asthra,753,auto_type,MEDIUM,Auto type annotation should be explicit type,let java_results: auto = match java_results_result {;,let java_results: <explicit_type> = match java_results_result {;
examples/concurrency/migration_guide.asthra,760,auto_type,MEDIUM,Auto type annotation should be explicit type,let test_data_large: auto = (0..100).collect();,let test_data_large: <explicit_type> = (0..100).collect();
examples/concurrency/migration_guide.asthra,762,auto_type,MEDIUM,Auto type annotation should be explicit type,let naive_results_result: auto = naive_parallel(test_data_large.clone());,let naive_results_result: <explicit_type> = naive_parallel(test_data_large.clone());
examples/concurrency/migration_guide.asthra,763,auto_type,MEDIUM,Auto type annotation should be explicit type,let naive_results: auto = match naive_results_result {;,let naive_results: <explicit_type> = match naive_results_result {;
examples/concurrency/migration_guide.asthra,769,auto_type,MEDIUM,Auto type annotation should be explicit type,let optimized_results_result: auto = optimized_chunked(test_data_large.clone());,let optimized_results_result: <explicit_type> = optimized_chunked(test_data_large.clone());
examples/concurrency/migration_guide.asthra,770,auto_type,MEDIUM,Auto type annotation should be explicit type,let optimized_results: auto = match optimized_results_result {;,let optimized_results: <explicit_type> = match optimized_results_result {;
examples/concurrency/migration_guide.asthra,776,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_results_result: auto = optimized_worker_pool(test_data_large);,let pool_results_result: <explicit_type> = optimized_worker_pool(test_data_large);
examples/concurrency/migration_guide.asthra,777,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_results: auto = match pool_results_result {;,let pool_results: <explicit_type> = match pool_results_result {;
examples/concurrency/migration_guide.asthra,786,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""Robust error handling: {:.1}% success rate ({}/{})"",","Convert to concatenation: ""println(""Robust error handling:"" + :.1 + ""% success rate ({}/{})"","""
examples/concurrency/tier1_basic.asthra,50,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_result_collection() -> Result<Vec<i32>, string> {","fn example_result_collection(none) -> Result<Vec<i32>, string> {"
examples/concurrency/tier1_basic.asthra,53,auto_type,MEDIUM,Auto type annotation should be explicit type,let handles: auto = [];,let handles: <explicit_type> = [];
examples/concurrency/tier1_basic.asthra,57,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle compute_square(i);,let handle: <explicit_type> = spawn_with_handle compute_square(i);
examples/concurrency/tier1_basic.asthra,64,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_result: auto = await handle;,let result_result: <explicit_type> = await handle;
examples/concurrency/tier1_basic.asthra,65,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/tier1_basic.asthra,80,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = n * n;,let result: <explicit_type> = n * n;
examples/concurrency/tier1_basic.asthra,96,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_parallel_file_processing() -> Result<Vec<FileInfo>, string> {","fn example_parallel_file_processing(none) -> Result<Vec<FileInfo>, string> {"
examples/concurrency/tier1_basic.asthra,97,auto_type,MEDIUM,Auto type annotation should be explicit type,let filenames: auto = vec![;,let filenames: <explicit_type> = vec![;
examples/concurrency/tier1_basic.asthra,111,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle process_file(filename);,let handle: <explicit_type> = spawn_with_handle process_file(filename);
examples/concurrency/tier1_basic.asthra,135,auto_type,MEDIUM,Auto type annotation should be explicit type,let content_result: auto = read_file_content(filename.clone());,let content_result: <explicit_type> = read_file_content(filename.clone());
examples/concurrency/tier1_basic.asthra,136,auto_type,MEDIUM,Auto type annotation should be explicit type,let content: auto = match content_result {;,let content: <explicit_type> = match content_result {;
examples/concurrency/tier1_basic.asthra,140,auto_type,MEDIUM,Auto type annotation should be explicit type,let size: auto = content.len();,let size: <explicit_type> = content.len();
examples/concurrency/tier1_basic.asthra,141,auto_type,MEDIUM,Auto type annotation should be explicit type,let checksum_result: auto = calculate_checksum(content);,let checksum_result: <explicit_type> = calculate_checksum(content);
examples/concurrency/tier1_basic.asthra,142,auto_type,MEDIUM,Auto type annotation should be explicit type,let checksum: auto = match checksum_result {;,let checksum: <explicit_type> = match checksum_result {;
examples/concurrency/tier1_basic.asthra,160,auto_type,MEDIUM,Auto type annotation should be explicit type,"let content: auto = format!(""Content of {}"", filename);","let content: <explicit_type> = format!(""Content of {}"", filename);"
examples/concurrency/tier1_basic.asthra,167,auto_type,MEDIUM,Auto type annotation should be explicit type,let hash: auto = content.len() * 31; // Simple hash;,let hash: <explicit_type> = content.len() * 31; // Simple hash;
examples/concurrency/tier1_basic.asthra,175,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_sequential_dependencies() -> Result<string, string> {","fn example_sequential_dependencies(none) -> Result<string, string> {"
examples/concurrency/tier1_basic.asthra,179,auto_type,MEDIUM,Auto type annotation should be explicit type,let prep_handle: auto = spawn_with_handle prepare_data();,let prep_handle: <explicit_type> = spawn_with_handle prepare_data();
examples/concurrency/tier1_basic.asthra,180,auto_type,MEDIUM,Auto type annotation should be explicit type,let prepared_data_result: auto = await prep_handle;,let prepared_data_result: <explicit_type> = await prep_handle;
examples/concurrency/tier1_basic.asthra,181,auto_type,MEDIUM,Auto type annotation should be explicit type,let prepared_data: auto = match prepared_data_result {;,let prepared_data: <explicit_type> = match prepared_data_result {;
examples/concurrency/tier1_basic.asthra,188,auto_type,MEDIUM,Auto type annotation should be explicit type,let process_handle: auto = spawn_with_handle process_data(prepared_data);,let process_handle: <explicit_type> = spawn_with_handle process_data(prepared_data);
examples/concurrency/tier1_basic.asthra,189,auto_type,MEDIUM,Auto type annotation should be explicit type,let processed_data_result: auto = await process_handle;,let processed_data_result: <explicit_type> = await process_handle;
examples/concurrency/tier1_basic.asthra,190,auto_type,MEDIUM,Auto type annotation should be explicit type,let processed_data: auto = match processed_data_result {;,let processed_data: <explicit_type> = match processed_data_result {;
examples/concurrency/tier1_basic.asthra,197,auto_type,MEDIUM,Auto type annotation should be explicit type,let finalize_handle: auto = spawn_with_handle finalize_data(processed_data);,let finalize_handle: <explicit_type> = spawn_with_handle finalize_data(processed_data);
examples/concurrency/tier1_basic.asthra,198,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_result_result: auto = await finalize_handle;,let final_result_result: <explicit_type> = await finalize_handle;
examples/concurrency/tier1_basic.asthra,199,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_result: auto = match final_result_result {;,let final_result: <explicit_type> = match final_result_result {;
examples/concurrency/tier1_basic.asthra,208,empty_params,HIGH,Function with empty parameter list should use (none),"fn prepare_data() -> Result<string, string> {","fn prepare_data(none) -> Result<string, string> {"
examples/concurrency/tier1_basic.asthra,247,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_cpu_bound_computation() -> Result<Vec<i64>, string> {","fn example_cpu_bound_computation(none) -> Result<Vec<i64>, string> {"
examples/concurrency/tier1_basic.asthra,248,auto_type,MEDIUM,Auto type annotation should be explicit type,"let numbers: auto = vec![25, 30, 35, 40, 45, 50];","let numbers: <explicit_type> = vec![25, 30, 35, 40, 45, 50];"
examples/concurrency/tier1_basic.asthra,256,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle compute_fibonacci(number);,let handle: <explicit_type> = spawn_with_handle compute_fibonacci(number);
examples/concurrency/tier1_basic.asthra,291,auto_type,MEDIUM,Auto type annotation should be explicit type,let temp: auto = a + b;,let temp: <explicit_type> = a + b;
examples/concurrency/tier1_basic.asthra,336,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_parallel_matrix_multiply() -> Result<Matrix, string> {","fn example_parallel_matrix_multiply(none) -> Result<Matrix, string> {"
examples/concurrency/tier1_basic.asthra,338,auto_type,MEDIUM,Auto type annotation should be explicit type,"let matrix_a: auto = Matrix::new(size, size);","let matrix_a: <explicit_type> = Matrix::new(size, size);"
examples/concurrency/tier1_basic.asthra,339,auto_type,MEDIUM,Auto type annotation should be explicit type,"let matrix_b: auto = Matrix::new(size, size);","let matrix_b: <explicit_type> = Matrix::new(size, size);"
examples/concurrency/tier1_basic.asthra,343,auto_type,MEDIUM,Auto type annotation should be explicit type,let cpu_count: auto = get_cpu_count();,let cpu_count: <explicit_type> = get_cpu_count();
examples/concurrency/tier1_basic.asthra,344,auto_type,MEDIUM,Auto type annotation should be explicit type,"let chunk_size: auto = max(1, size / cpu_count);","let chunk_size: <explicit_type> = max(1, size / cpu_count);"
examples/concurrency/tier1_basic.asthra,350,auto_type,MEDIUM,Auto type annotation should be explicit type,"let end_row: auto = min(start_row + chunk_size, size);","let end_row: <explicit_type> = min(start_row + chunk_size, size);"
examples/concurrency/tier1_basic.asthra,351,auto_type,MEDIUM,Auto type annotation should be explicit type,let a_clone: auto = matrix_a.clone();,let a_clone: <explicit_type> = matrix_a.clone();
examples/concurrency/tier1_basic.asthra,352,auto_type,MEDIUM,Auto type annotation should be explicit type,let b_clone: auto = matrix_b.clone();,let b_clone: <explicit_type> = matrix_b.clone();
examples/concurrency/tier1_basic.asthra,354,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier1_basic.asthra,363,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk_result: auto = await handle;,let chunk_result: <explicit_type> = await handle;
examples/concurrency/tier1_basic.asthra,364,auto_type,MEDIUM,Auto type annotation should be explicit type,let chunk: auto = match chunk_result {;,let chunk: <explicit_type> = match chunk_result {;
examples/concurrency/tier1_basic.asthra,372,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result_result: auto = combine_matrix_chunks(result_chunks, size, size);","let result_result: <explicit_type> = combine_matrix_chunks(result_chunks, size, size);"
examples/concurrency/tier1_basic.asthra,373,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/tier1_basic.asthra,415,auto_type,MEDIUM,Auto type annotation should be explicit type,let global_row: auto = chunk.start_row + local_row;,let global_row: <explicit_type> = chunk.start_row + local_row;
examples/concurrency/tier1_basic.asthra,429,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_robust_error_handling() -> Result<ProcessingSummary, string> {","fn example_robust_error_handling(none) -> Result<ProcessingSummary, string> {"
examples/concurrency/tier1_basic.asthra,430,auto_type,MEDIUM,Auto type annotation should be explicit type,let work_items: auto = generate_work_items(20);,let work_items: <explicit_type> = generate_work_items(20);
examples/concurrency/tier1_basic.asthra,438,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle process_work_item(item);,let handle: <explicit_type> = spawn_with_handle process_work_item(item);
examples/concurrency/tier1_basic.asthra,463,auto_type,MEDIUM,Auto type annotation should be explicit type,let summary: auto = ProcessingSummary {;,let summary: <explicit_type> = ProcessingSummary {;
examples/concurrency/tier1_basic.asthra,557,empty_params,HIGH,Function with empty parameter list should use (none),fn get_cpu_count() -> usize {,fn get_cpu_count(none) -> usize {
examples/concurrency/tier1_basic.asthra,578,empty_params,HIGH,Function with empty parameter list should use (none),"fn main() -> Result<(), string> {","fn main(none) -> Result<(), string> {"
examples/concurrency/tier1_basic.asthra,587,auto_type,MEDIUM,Auto type annotation should be explicit type,let results_result: auto = example_result_collection();,let results_result: <explicit_type> = example_result_collection();
examples/concurrency/tier1_basic.asthra,588,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = match results_result {;,let results: <explicit_type> = match results_result {;
examples/concurrency/tier1_basic.asthra,596,auto_type,MEDIUM,Auto type annotation should be explicit type,let file_infos_result: auto = example_parallel_file_processing();,let file_infos_result: <explicit_type> = example_parallel_file_processing();
examples/concurrency/tier1_basic.asthra,597,auto_type,MEDIUM,Auto type annotation should be explicit type,let file_infos: auto = match file_infos_result {;,let file_infos: <explicit_type> = match file_infos_result {;
examples/concurrency/tier1_basic.asthra,605,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_result_result: auto = example_sequential_dependencies();,let final_result_result: <explicit_type> = example_sequential_dependencies();
examples/concurrency/tier1_basic.asthra,606,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_result: auto = match final_result_result {;,let final_result: <explicit_type> = match final_result_result {;
examples/concurrency/tier1_basic.asthra,614,auto_type,MEDIUM,Auto type annotation should be explicit type,let fibonacci_results_result: auto = example_cpu_bound_computation();,let fibonacci_results_result: <explicit_type> = example_cpu_bound_computation();
examples/concurrency/tier1_basic.asthra,615,auto_type,MEDIUM,Auto type annotation should be explicit type,let fibonacci_results: auto = match fibonacci_results_result {;,let fibonacci_results: <explicit_type> = match fibonacci_results_result {;
examples/concurrency/tier1_basic.asthra,623,auto_type,MEDIUM,Auto type annotation should be explicit type,let matrix_result_result: auto = example_parallel_matrix_multiply();,let matrix_result_result: <explicit_type> = example_parallel_matrix_multiply();
examples/concurrency/tier1_basic.asthra,624,auto_type,MEDIUM,Auto type annotation should be explicit type,let matrix_result: auto = match matrix_result_result {;,let matrix_result: <explicit_type> = match matrix_result_result {;
examples/concurrency/tier1_basic.asthra,632,auto_type,MEDIUM,Auto type annotation should be explicit type,let summary_result: auto = example_robust_error_handling();,let summary_result: <explicit_type> = example_robust_error_handling();
examples/concurrency/tier1_basic.asthra,633,auto_type,MEDIUM,Auto type annotation should be explicit type,let summary: auto = match summary_result {;,let summary: <explicit_type> = match summary_result {;
examples/concurrency/tier1_basic.asthra,637,string_interpolation,CRITICAL,"String interpolation removed in v1.22, use concatenation","println(""Processing summary: {:.1}% success rate"", summary.success_rate);","Convert to concatenation: ""println(""Processing summary:"" + :.1 + ""% success rate"", summary.success_rate);"""
examples/concurrency/tier2_advanced.asthra,13,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_basic_channels() -> Result<Vec<i32>, string> {","fn example_basic_channels(none) -> Result<Vec<i32>, string> {"
examples/concurrency/tier2_advanced.asthra,17,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_pair_result: auto = channels.channel_pair<i32>(10);,let channel_pair_result: <explicit_type> = channels.channel_pair<i32>(10);
examples/concurrency/tier2_advanced.asthra,24,auto_type,MEDIUM,Auto type annotation should be explicit type,let producer: auto = spawn_with_handle move || {;,let producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,48,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer: auto = spawn_with_handle move || {;,let consumer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,76,auto_type,MEDIUM,Auto type annotation should be explicit type,let results_result: auto = await consumer;,let results_result: <explicit_type> = await consumer;
examples/concurrency/tier2_advanced.asthra,77,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = match results_result {;,let results: <explicit_type> = match results_result {;
examples/concurrency/tier2_advanced.asthra,91,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_multi_producer() -> Result<ProcessingReport, string> {","fn example_multi_producer(none) -> Result<ProcessingReport, string> {"
examples/concurrency/tier2_advanced.asthra,94,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_pair_result: auto = channels.channel_pair<WorkMessage>(50);,let channel_pair_result: <explicit_type> = channels.channel_pair<WorkMessage>(50);
examples/concurrency/tier2_advanced.asthra,104,auto_type,MEDIUM,Auto type annotation should be explicit type,let sender_clone: auto = sender.clone();,let sender_clone: <explicit_type> = sender.clone();
examples/concurrency/tier2_advanced.asthra,105,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,112,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer: auto = spawn_with_handle move || {;,let consumer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,131,auto_type,MEDIUM,Auto type annotation should be explicit type,let report_result: auto = await consumer;,let report_result: <explicit_type> = await consumer;
examples/concurrency/tier2_advanced.asthra,132,auto_type,MEDIUM,Auto type annotation should be explicit type,let report: auto = match report_result {;,let report: <explicit_type> = match report_result {;
examples/concurrency/tier2_advanced.asthra,157,auto_type,MEDIUM,Auto type annotation should be explicit type,let message: auto = WorkMessage {;,let message: <explicit_type> = WorkMessage {;
examples/concurrency/tier2_advanced.asthra,188,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_current_time_ms();,let start_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,213,auto_type,MEDIUM,Auto type annotation should be explicit type,let end_time: auto = get_current_time_ms();,let end_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,214,auto_type,MEDIUM,Auto type annotation should be explicit type,let processing_time: auto = end_time - start_time;,let processing_time: <explicit_type> = end_time - start_time;
examples/concurrency/tier2_advanced.asthra,230,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_select_operations() -> Result<SelectionResults, string> {","fn example_select_operations(none) -> Result<SelectionResults, string> {"
examples/concurrency/tier2_advanced.asthra,234,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_numbers_result: auto = channels.channel<i32>(5);,let ch_numbers_result: <explicit_type> = channels.channel<i32>(5);
examples/concurrency/tier2_advanced.asthra,235,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_numbers: auto = match ch_numbers_result {;,let ch_numbers: <explicit_type> = match ch_numbers_result {;
examples/concurrency/tier2_advanced.asthra,239,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_strings_result: auto = channels.channel<string>(5);,let ch_strings_result: <explicit_type> = channels.channel<string>(5);
examples/concurrency/tier2_advanced.asthra,240,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_strings: auto = match ch_strings_result {;,let ch_strings: <explicit_type> = match ch_strings_result {;
examples/concurrency/tier2_advanced.asthra,244,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_control_result: auto = channels.channel<ControlMessage>(2);,let ch_control_result: <explicit_type> = channels.channel<ControlMessage>(2);
examples/concurrency/tier2_advanced.asthra,245,auto_type,MEDIUM,Auto type annotation should be explicit type,let ch_control: auto = match ch_control_result {;,let ch_control: <explicit_type> = match ch_control_result {;
examples/concurrency/tier2_advanced.asthra,251,auto_type,MEDIUM,Auto type annotation should be explicit type,let number_producer: auto = spawn_with_handle move || {;,let number_producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,255,auto_type,MEDIUM,Auto type annotation should be explicit type,let string_producer: auto = spawn_with_handle move || {;,let string_producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,259,auto_type,MEDIUM,Auto type annotation should be explicit type,let control_producer: auto = spawn_with_handle move || {;,let control_producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,264,auto_type,MEDIUM,Auto type annotation should be explicit type,let selector: auto = spawn_with_handle move || {;,let selector: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,283,auto_type,MEDIUM,Auto type annotation should be explicit type,let results_result: auto = await selector;,let results_result: <explicit_type> = await selector;
examples/concurrency/tier2_advanced.asthra,284,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = match results_result {;,let results: <explicit_type> = match results_result {;
examples/concurrency/tier2_advanced.asthra,322,auto_type,MEDIUM,Auto type annotation should be explicit type,"let strings: auto = vec![""hello"", ""world"", ""asthra"", ""concurrent"", ""programming""];","let strings: <explicit_type> = vec![""hello"", ""world"", ""asthra"", ""concurrent"", ""programming""];"
examples/concurrency/tier2_advanced.asthra,338,auto_type,MEDIUM,Auto type annotation should be explicit type,"let messages: auto = vec![ControlMessage.Pause, ControlMessage.Resume, ControlMessage.Stop];","let messages: <explicit_type> = vec![ControlMessage.Pause, ControlMessage.Resume, ControlMessage.Stop];"
examples/concurrency/tier2_advanced.asthra,453,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_worker_pool() -> Result<WorkerPoolResults, string> {","fn example_worker_pool(none) -> Result<WorkerPoolResults, string> {"
examples/concurrency/tier2_advanced.asthra,460,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_result: auto = patterns.WorkerPool::<TaskResult>::new(pool_size);,let pool_result: <explicit_type> = patterns.WorkerPool::<TaskResult>::new(pool_size);
examples/concurrency/tier2_advanced.asthra,461,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = match pool_result {;,let pool: <explicit_type> = match pool_result {;
examples/concurrency/tier2_advanced.asthra,468,auto_type,MEDIUM,Auto type annotation should be explicit type,let task: auto = Task {;,let task: <explicit_type> = Task {;
examples/concurrency/tier2_advanced.asthra,510,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = WorkerPoolResults {;,let results: <explicit_type> = WorkerPoolResults {;
examples/concurrency/tier2_advanced.asthra,554,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_current_time_ms();,let start_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,566,auto_type,MEDIUM,Auto type annotation should be explicit type,let end_time: auto = get_current_time_ms();,let end_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,567,auto_type,MEDIUM,Auto type annotation should be explicit type,let processing_time: auto = end_time - start_time;,let processing_time: <explicit_type> = end_time - start_time;
examples/concurrency/tier2_advanced.asthra,581,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_barrier_synchronization() -> Result<BarrierResults, string> {","fn example_barrier_synchronization(none) -> Result<BarrierResults, string> {"
examples/concurrency/tier2_advanced.asthra,585,auto_type,MEDIUM,Auto type annotation should be explicit type,let barrier_result: auto = coordination.create_barrier(worker_count);,let barrier_result: <explicit_type> = coordination.create_barrier(worker_count);
examples/concurrency/tier2_advanced.asthra,586,auto_type,MEDIUM,Auto type annotation should be explicit type,let barrier: auto = match barrier_result {;,let barrier: <explicit_type> = match barrier_result {;
examples/concurrency/tier2_advanced.asthra,595,auto_type,MEDIUM,Auto type annotation should be explicit type,let barrier_ref: auto = barrier.clone();,let barrier_ref: <explicit_type> = barrier.clone();
examples/concurrency/tier2_advanced.asthra,596,auto_type,MEDIUM,Auto type annotation should be explicit type,let handle: auto = spawn_with_handle move || {;,let handle: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,605,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_result: auto = await handle;,let result_result: <explicit_type> = await handle;
examples/concurrency/tier2_advanced.asthra,606,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = match result_result {;,let result: <explicit_type> = match result_result {;
examples/concurrency/tier2_advanced.asthra,613,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = BarrierResults {;,let results: <explicit_type> = BarrierResults {;
examples/concurrency/tier2_advanced.asthra,636,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_current_time_ms();,let start_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,642,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase1_start: auto = get_current_time_ms();,let phase1_start: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,646,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase1_time: auto = get_current_time_ms() - phase1_start;,let phase1_time: <explicit_type> = get_current_time_ms() - phase1_start;
examples/concurrency/tier2_advanced.asthra,659,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase2_start: auto = get_current_time_ms();,let phase2_start: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,663,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase2_time: auto = get_current_time_ms() - phase2_start;,let phase2_time: <explicit_type> = get_current_time_ms() - phase2_start;
examples/concurrency/tier2_advanced.asthra,676,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase3_start: auto = get_current_time_ms();,let phase3_start: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,680,auto_type,MEDIUM,Auto type annotation should be explicit type,let phase3_time: auto = get_current_time_ms() - phase3_start;,let phase3_time: <explicit_type> = get_current_time_ms() - phase3_start;
examples/concurrency/tier2_advanced.asthra,692,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_time: auto = get_current_time_ms() - start_time;,let total_time: <explicit_type> = get_current_time_ms() - start_time;
examples/concurrency/tier2_advanced.asthra,725,empty_params,HIGH,Function with empty parameter list should use (none),"fn example_backpressure_control() -> Result<BackpressureResults, string> {","fn example_backpressure_control(none) -> Result<BackpressureResults, string> {"
examples/concurrency/tier2_advanced.asthra,728,auto_type,MEDIUM,Auto type annotation should be explicit type,let buffer_size: auto = 5; // Small buffer to demonstrate backpressure;,let buffer_size: <explicit_type> = 5; // Small buffer to demonstrate backpressure;
examples/concurrency/tier2_advanced.asthra,729,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_pair_result: auto = channels.channel_pair<DataPacket>(buffer_size);,let channel_pair_result: <explicit_type> = channels.channel_pair<DataPacket>(buffer_size);
examples/concurrency/tier2_advanced.asthra,736,auto_type,MEDIUM,Auto type annotation should be explicit type,let producer: auto = spawn_with_handle move || {;,let producer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,741,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer: auto = spawn_with_handle move || {;,let consumer: <explicit_type> = spawn_with_handle move || {;
examples/concurrency/tier2_advanced.asthra,746,auto_type,MEDIUM,Auto type annotation should be explicit type,let producer_stats_result: auto = await producer;,let producer_stats_result: <explicit_type> = await producer;
examples/concurrency/tier2_advanced.asthra,747,auto_type,MEDIUM,Auto type annotation should be explicit type,let producer_stats: auto = match producer_stats_result {;,let producer_stats: <explicit_type> = match producer_stats_result {;
examples/concurrency/tier2_advanced.asthra,751,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer_stats_result: auto = await consumer;,let consumer_stats_result: <explicit_type> = await consumer;
examples/concurrency/tier2_advanced.asthra,752,auto_type,MEDIUM,Auto type annotation should be explicit type,let consumer_stats: auto = match consumer_stats_result {;,let consumer_stats: <explicit_type> = match consumer_stats_result {;
examples/concurrency/tier2_advanced.asthra,757,auto_type,MEDIUM,Auto type annotation should be explicit type,let results: auto = BackpressureResults {;,let results: <explicit_type> = BackpressureResults {;
examples/concurrency/tier2_advanced.asthra,801,auto_type,MEDIUM,Auto type annotation should be explicit type,let packet: auto = DataPacket {;,let packet: <explicit_type> = DataPacket {;
examples/concurrency/tier2_advanced.asthra,807,auto_type,MEDIUM,Auto type annotation should be explicit type,let send_start: auto = get_current_time_ms();,let send_start: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,811,auto_type,MEDIUM,Auto type annotation should be explicit type,let send_time: auto = get_current_time_ms() - send_start;,let send_time: <explicit_type> = get_current_time_ms() - send_start;
examples/concurrency/tier2_advanced.asthra,844,auto_type,MEDIUM,Auto type annotation should be explicit type,let start_time: auto = get_current_time_ms();,let start_time: <explicit_type> = get_current_time_ms();
examples/concurrency/tier2_advanced.asthra,867,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_processing_time: auto = get_current_time_ms() - start_time;,let total_processing_time: <explicit_type> = get_current_time_ms() - start_time;
examples/concurrency/tier2_advanced.asthra,915,empty_params,HIGH,Function with empty parameter list should use (none),fn get_current_time_ms() -> i64 {,fn get_current_time_ms(none) -> i64 {
examples/concurrency/tier2_advanced.asthra,926,empty_params,HIGH,Function with empty parameter list should use (none),"fn main() -> Result<(), string> {","fn main(none) -> Result<(), string> {"
examples/concurrency/tier2_advanced.asthra,931,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_results_result: auto = example_basic_channels();,let channel_results_result: <explicit_type> = example_basic_channels();
examples/concurrency/tier2_advanced.asthra,932,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel_results: auto = match channel_results_result {;,let channel_results: <explicit_type> = match channel_results_result {;
examples/concurrency/tier2_advanced.asthra,940,auto_type,MEDIUM,Auto type annotation should be explicit type,let multi_results_result: auto = example_multi_producer();,let multi_results_result: <explicit_type> = example_multi_producer();
examples/concurrency/tier2_advanced.asthra,941,auto_type,MEDIUM,Auto type annotation should be explicit type,let multi_results: auto = match multi_results_result {;,let multi_results: <explicit_type> = match multi_results_result {;
examples/concurrency/tier2_advanced.asthra,949,auto_type,MEDIUM,Auto type annotation should be explicit type,let select_results_result: auto = example_select_operations();,let select_results_result: <explicit_type> = example_select_operations();
examples/concurrency/tier2_advanced.asthra,950,auto_type,MEDIUM,Auto type annotation should be explicit type,let select_results: auto = match select_results_result {;,let select_results: <explicit_type> = match select_results_result {;
examples/concurrency/tier2_advanced.asthra,958,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_results_result: auto = example_worker_pool();,let pool_results_result: <explicit_type> = example_worker_pool();
examples/concurrency/tier2_advanced.asthra,959,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool_results: auto = match pool_results_result {;,let pool_results: <explicit_type> = match pool_results_result {;
examples/concurrency/tier2_advanced.asthra,968,auto_type,MEDIUM,Auto type annotation should be explicit type,let barrier_results_result: auto = example_barrier_synchronization();,let barrier_results_result: <explicit_type> = example_barrier_synchronization();
examples/concurrency/tier2_advanced.asthra,969,auto_type,MEDIUM,Auto type annotation should be explicit type,let barrier_results: auto = match barrier_results_result {;,let barrier_results: <explicit_type> = match barrier_results_result {;
examples/concurrency/tier2_advanced.asthra,978,auto_type,MEDIUM,Auto type annotation should be explicit type,let backpressure_results_result: auto = example_backpressure_control();,let backpressure_results_result: <explicit_type> = example_backpressure_control();
examples/concurrency/tier2_advanced.asthra,979,auto_type,MEDIUM,Auto type annotation should be explicit type,let backpressure_results: auto = match backpressure_results_result {;,let backpressure_results: <explicit_type> = match backpressure_results_result {;
stdlib/fs.asthra,245,auto_type,MEDIUM,Auto type annotation should be explicit type,let mode: auto = if options.create_new {;,let mode: <explicit_type> = if options.create_new {;
stdlib/fs.asthra,255,auto_type,MEDIUM,Auto type annotation should be explicit type,"let file_result: auto = open(path, mode);","let file_result: <explicit_type> = open(path, mode);"
stdlib/fs.asthra,346,auto_type,MEDIUM,Auto type annotation should be explicit type,let options: auto = CopyOptions {;,let options: <explicit_type> = CopyOptions {;
stdlib/fs.asthra,479,auto_type,MEDIUM,Auto type annotation should be explicit type,let bytes_result: auto = self.read_to_end();,let bytes_result: <explicit_type> = self.read_to_end();
stdlib/fs.asthra,483,auto_type,MEDIUM,Auto type annotation should be explicit type,let validation_result: auto = validate_utf8(bytes);,let validation_result: <explicit_type> = validate_utf8(bytes);
stdlib/fs.asthra,486,auto_type,MEDIUM,Auto type annotation should be explicit type,let content: auto = string_from_bytes(bytes);,let content: <explicit_type> = string_from_bytes(bytes);
stdlib/fs.asthra,532,auto_type,MEDIUM,Auto type annotation should be explicit type,"let bytes_read_result: auto = self.read_into_buffer(buffer_ptr, remaining_size);","let bytes_read_result: <explicit_type> = self.read_into_buffer(buffer_ptr, remaining_size);"
stdlib/fs.asthra,555,auto_type,MEDIUM,Auto type annotation should be explicit type,let bytes: auto = string_to_bytes(text);,let bytes: <explicit_type> = string_to_bytes(text);
stdlib/fs.asthra,638,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = close_file_handle(self.handle);,let result: <explicit_type> = close_file_handle(self.handle);
stdlib/fs.asthra,686,auto_type,MEDIUM,Auto type annotation should be explicit type,let parent_result: auto = get_parent_path(path);,let parent_result: <explicit_type> = get_parent_path(path);
stdlib/fs.asthra,690,auto_type,MEDIUM,Auto type annotation should be explicit type,let parent_result: auto = create_dir_all(parent);,let parent_result: <explicit_type> = create_dir_all(parent);
stdlib/fs.asthra,733,auto_type,MEDIUM,Auto type annotation should be explicit type,let options: auto = DirOptions {;,let options: <explicit_type> = DirOptions {;
stdlib/fs.asthra,741,auto_type,MEDIUM,Auto type annotation should be explicit type,"let iterator_result: auto = read_dir_with_options(path, options);","let iterator_result: <explicit_type> = read_dir_with_options(path, options);"
stdlib/fs.asthra,744,auto_type,MEDIUM,Auto type annotation should be explicit type,let entries_result: auto = iterator.collect();,let entries_result: <explicit_type> = iterator.collect();
stdlib/fs.asthra,815,auto_type,MEDIUM,Auto type annotation should be explicit type,let access_mode: auto = match mode {;,let access_mode: <explicit_type> = match mode {;
stdlib/crypto.asthra,114,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_aes256_key() -> Result<[]u8, CryptoError> {","fn generate_aes256_key(none) -> Result<[]u8, CryptoError> {"
stdlib/crypto.asthra,119,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_chacha20_key() -> Result<[]u8, CryptoError> {","fn generate_chacha20_key(none) -> Result<[]u8, CryptoError> {"
stdlib/crypto.asthra,124,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_hmac_key() -> Result<[]u8, CryptoError> {","fn generate_hmac_key(none) -> Result<[]u8, CryptoError> {"
stdlib/crypto.asthra,134,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_CIPHER_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_CIPHER_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,136,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_aes_256_gcm() -> *const void;","extern ""libcrypto"" fn EVP_aes_256_gcm(none) -> *const void;"
stdlib/crypto.asthra,267,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_CIPHER_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_CIPHER_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,269,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_aes_256_gcm() -> *const void;","extern ""libcrypto"" fn EVP_aes_256_gcm(none) -> *const void;"
stdlib/crypto.asthra,403,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_CIPHER_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_CIPHER_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,405,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_chacha20_poly1305() -> *const void;","extern ""libcrypto"" fn EVP_chacha20_poly1305(none) -> *const void;"
stdlib/crypto.asthra,536,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_CIPHER_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_CIPHER_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,538,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_chacha20_poly1305() -> *const void;","extern ""libcrypto"" fn EVP_chacha20_poly1305(none) -> *const void;"
stdlib/crypto.asthra,668,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_MD_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_MD_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,670,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_sha256() -> *const void;","extern ""libcrypto"" fn EVP_sha256(none) -> *const void;"
stdlib/crypto.asthra,729,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_MD_CTX_new() -> *mut void;","extern ""libcrypto"" fn EVP_MD_CTX_new(none) -> *mut void;"
stdlib/crypto.asthra,731,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_sha512() -> *const void;","extern ""libcrypto"" fn EVP_sha512(none) -> *const void;"
stdlib/crypto.asthra,803,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_sha256() -> *const void;","extern ""libcrypto"" fn EVP_sha256(none) -> *const void;"
stdlib/crypto.asthra,850,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_sha512() -> *const void;","extern ""libcrypto"" fn EVP_sha512(none) -> *const void;"
stdlib/crypto.asthra,902,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcrypto"" fn EVP_sha256() -> *const void;","extern ""libcrypto"" fn EVP_sha256(none) -> *const void;"
stdlib/crypto.asthra,1043,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_salt() -> Result<[]u8, CryptoError> {","fn generate_salt(none) -> Result<[]u8, CryptoError> {"
stdlib/crypto_enhancements.asthra,129,empty_params,HIGH,Function with empty parameter list should use (none),"fn generate_hybrid_keypair() -> Result<HybridKeyPair, CryptoError> {","fn generate_hybrid_keypair(none) -> Result<HybridKeyPair, CryptoError> {"
stdlib/crypto_enhancements.asthra,268,empty_params,HIGH,Function with empty parameter list should use (none),fn get_crypto_metrics() -> CryptoMetrics {,fn get_crypto_metrics(none) -> CryptoMetrics {
stdlib/crypto_enhancements.asthra,276,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_time_ns() -> u64;","extern ""asthra_runtime"" fn asthra_get_time_ns(none) -> u64;"
stdlib/crypto_enhancements.asthra,312,empty_params,HIGH,Function with empty parameter list should use (none),fn get_default_crypto_config() -> CryptoConfig {,fn get_default_crypto_config(none) -> CryptoConfig {
stdlib/http.asthra,138,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> HTTPClient {,fn new(none) -> HTTPClient {
stdlib/http.asthra,179,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,196,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,213,auto_type,MEDIUM,Auto type annotation should be explicit type,let content_type_header: auto = HTTPHeader {;,let content_type_header: <explicit_type> = HTTPHeader {;
stdlib/http.asthra,218,auto_type,MEDIUM,Auto type annotation should be explicit type,let headers: auto = [content_type_header];,let headers: <explicit_type> = [content_type_header];
stdlib/http.asthra,219,auto_type,MEDIUM,Auto type annotation should be explicit type,let body_bytes: auto = str::to_bytes(json_body);,let body_bytes: <explicit_type> = str::to_bytes(json_body);
stdlib/http.asthra,221,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,238,auto_type,MEDIUM,Auto type annotation should be explicit type,let form_body: auto = encode_form_data(form_data);,let form_body: <explicit_type> = encode_form_data(form_data);
stdlib/http.asthra,239,auto_type,MEDIUM,Auto type annotation should be explicit type,let content_type_header: auto = HTTPHeader {;,let content_type_header: <explicit_type> = HTTPHeader {;
stdlib/http.asthra,244,auto_type,MEDIUM,Auto type annotation should be explicit type,let headers: auto = [content_type_header];,let headers: <explicit_type> = [content_type_header];
stdlib/http.asthra,246,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,263,auto_type,MEDIUM,Auto type annotation should be explicit type,let content_type_header: auto = HTTPHeader {;,let content_type_header: <explicit_type> = HTTPHeader {;
stdlib/http.asthra,268,auto_type,MEDIUM,Auto type annotation should be explicit type,let headers: auto = [content_type_header];,let headers: <explicit_type> = [content_type_header];
stdlib/http.asthra,270,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,287,auto_type,MEDIUM,Auto type annotation should be explicit type,let request: auto = HTTPRequest {;,let request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,305,auto_type,MEDIUM,Auto type annotation should be explicit type,let validation_result: auto = validate_request(request);,let validation_result: <explicit_type> = validate_request(request);
stdlib/http.asthra,312,auto_type,MEDIUM,Auto type annotation should be explicit type,let url_result: auto = parse_url(request.url);,let url_result: <explicit_type> = parse_url(request.url);
stdlib/http.asthra,313,auto_type,MEDIUM,Auto type annotation should be explicit type,let url_components: auto = match url_result {;,let url_components: <explicit_type> = match url_result {;
stdlib/http.asthra,329,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = HTTPClient::new();,let client: <explicit_type> = HTTPClient::new();
stdlib/http.asthra,335,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = HTTPClient::new();,let client: <explicit_type> = HTTPClient::new();
stdlib/http.asthra,341,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = HTTPClient::new();,let client: <explicit_type> = HTTPClient::new();
stdlib/http.asthra,347,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = HTTPClient::new();,let client: <explicit_type> = HTTPClient::new();
stdlib/http.asthra,353,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = HTTPClient::new();,let client: <explicit_type> = HTTPClient::new();
stdlib/http.asthra,385,auto_type,MEDIUM,Auto type annotation should be explicit type,let host_port_result: auto = parse_host_port(remaining);,let host_port_result: <explicit_type> = parse_host_port(remaining);
stdlib/http.asthra,418,auto_type,MEDIUM,Auto type annotation should be explicit type,"let slash_pos: auto = str::find(remaining, ""/"");","let slash_pos: <explicit_type> = str::find(remaining, ""/"");"
stdlib/http.asthra,430,auto_type,MEDIUM,Auto type annotation should be explicit type,"let colon_pos: auto = str::find(host_port, "":"");","let colon_pos: <explicit_type> = str::find(host_port, "":"");"
stdlib/http.asthra,439,auto_type,MEDIUM,Auto type annotation should be explicit type,"let port_str: auto = str::substring(host_port, colon_pos + 1, str::len(host_port));","let port_str: <explicit_type> = str::substring(host_port, colon_pos + 1, str::len(host_port));"
stdlib/http.asthra,440,auto_type,MEDIUM,Auto type annotation should be explicit type,let port_result: auto = str::parse_u16(port_str);,let port_result: <explicit_type> = str::parse_u16(port_str);
stdlib/http.asthra,456,auto_type,MEDIUM,Auto type annotation should be explicit type,"let fragment_pos: auto = str::find(path_query, ""#"");","let fragment_pos: <explicit_type> = str::find(path_query, ""#"");"
stdlib/http.asthra,468,auto_type,MEDIUM,Auto type annotation should be explicit type,"let query_pos: auto = str::find(path_query_only, ""?"");","let query_pos: <explicit_type> = str::find(path_query_only, ""?"");"
stdlib/http.asthra,510,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = request.headers[i];,let header: <explicit_type> = request.headers[i];
stdlib/http.asthra,558,auto_type,MEDIUM,Auto type annotation should be explicit type,"let response_result: auto = execute_http_request(client, request, url);","let response_result: <explicit_type> = execute_http_request(client, request, url);"
stdlib/http.asthra,559,auto_type,MEDIUM,Auto type annotation should be explicit type,let response: auto = match response_result {;,let response: <explicit_type> = match response_result {;
stdlib/http.asthra,566,auto_type,MEDIUM,Auto type annotation should be explicit type,"let location_header: auto = find_header(response.headers, ""Location"");","let location_header: <explicit_type> = find_header(response.headers, ""Location"");"
stdlib/http.asthra,570,auto_type,MEDIUM,Auto type annotation should be explicit type,let redirect_request: auto = HTTPRequest {;,let redirect_request: <explicit_type> = HTTPRequest {;
stdlib/http.asthra,582,auto_type,MEDIUM,Auto type annotation should be explicit type,let redirect_url_result: auto = parse_url(location);,let redirect_url_result: <explicit_type> = parse_url(location);
stdlib/http.asthra,583,auto_type,MEDIUM,Auto type annotation should be explicit type,let redirect_url: auto = match redirect_url_result {;,let redirect_url: <explicit_type> = match redirect_url_result {;
stdlib/http.asthra,609,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libcurl"" fn curl_easy_init() -> *mut void;","extern ""libcurl"" fn curl_easy_init(none) -> *mut void;"
stdlib/http.asthra,622,auto_type,MEDIUM,Auto type annotation should be explicit type,let url_cstr: auto = str::to_cstr(request.url);,let url_cstr: <explicit_type> = str::to_cstr(request.url);
stdlib/http.asthra,626,auto_type,MEDIUM,Auto type annotation should be explicit type,"let method_result: auto = set_curl_method(curl_handle, request.method);","let method_result: <explicit_type> = set_curl_method(curl_handle, request.method);"
stdlib/http.asthra,636,auto_type,MEDIUM,Auto type annotation should be explicit type,"let headers_result: auto = set_curl_headers(curl_handle, request.headers);","let headers_result: <explicit_type> = set_curl_headers(curl_handle, request.headers);"
stdlib/http.asthra,652,auto_type,MEDIUM,Auto type annotation should be explicit type,let timeout_seconds: auto = request.timeout_ms / 1000;,let timeout_seconds: <explicit_type> = request.timeout_ms / 1000;
stdlib/http.asthra,662,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_data: auto = ResponseData::new();,let response_data: <explicit_type> = ResponseData::new();
stdlib/http.asthra,684,auto_type,MEDIUM,Auto type annotation should be explicit type,let final_url: auto = if final_url_ptr != null {;,let final_url: <explicit_type> = if final_url_ptr != null {;
stdlib/http.asthra,693,auto_type,MEDIUM,Auto type annotation should be explicit type,let response: auto = HTTPResponse {;,let response: <explicit_type> = HTTPResponse {;
stdlib/http.asthra,718,empty_params,HIGH,Function with empty parameter list should use (none),fn new() -> ResponseData {,fn new(none) -> ResponseData {
stdlib/http.asthra,734,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_size: auto = size * nmemb;,let total_size: <explicit_type> = size * nmemb;
stdlib/http.asthra,735,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_data: auto = userdata as *mut ResponseData;,let response_data: <explicit_type> = userdata as *mut ResponseData;
stdlib/http.asthra,756,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_size: auto = size * nitems;,let total_size: <explicit_type> = size * nitems;
stdlib/http.asthra,757,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_data: auto = userdata as *mut ResponseData;,let response_data: <explicit_type> = userdata as *mut ResponseData;
stdlib/http.asthra,760,auto_type,MEDIUM,Auto type annotation should be explicit type,"let header_str: auto = str::from_bytes_with_length(buffer, total_size);","let header_str: <explicit_type> = str::from_bytes_with_length(buffer, total_size);"
stdlib/http.asthra,764,auto_type,MEDIUM,Auto type annotation should be explicit type,"let colon_pos: auto = str::find(header_str, "":"");","let colon_pos: <explicit_type> = str::find(header_str, "":"");"
stdlib/http.asthra,766,auto_type,MEDIUM,Auto type annotation should be explicit type,"let name: auto = str::trim(str::substring(header_str, 0, colon_pos));","let name: <explicit_type> = str::trim(str::substring(header_str, 0, colon_pos));"
stdlib/http.asthra,767,auto_type,MEDIUM,Auto type annotation should be explicit type,"let value: auto = str::trim(str::substring(header_str, colon_pos + 1, str::len(header_str)));","let value: <explicit_type> = str::trim(str::substring(header_str, colon_pos + 1, str::len(header_str)));"
stdlib/http.asthra,769,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = HTTPHeader {;,let header: <explicit_type> = HTTPHeader {;
stdlib/http.asthra,859,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = headers[i];,let header: <explicit_type> = headers[i];
stdlib/http.asthra,860,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_name_lower: auto = str::to_lowercase(header.name);,let header_name_lower: <explicit_type> = str::to_lowercase(header.name);
stdlib/http.asthra,892,auto_type,MEDIUM,Auto type annotation should be explicit type,let name_lower: auto = str::to_lowercase(name);,let name_lower: <explicit_type> = str::to_lowercase(name);
stdlib/http.asthra,896,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = headers[i];,let header: <explicit_type> = headers[i];
stdlib/http.asthra,897,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_name_lower: auto = str::to_lowercase(header.name);,let header_name_lower: <explicit_type> = str::to_lowercase(header.name);
stdlib/http.asthra,915,auto_type,MEDIUM,Auto type annotation should be explicit type,let field: auto = form_data[i];,let field: <explicit_type> = form_data[i];
stdlib/http.asthra,921,auto_type,MEDIUM,Auto type annotation should be explicit type,let encoded_name: auto = url_encode(field.name);,let encoded_name: <explicit_type> = url_encode(field.name);
stdlib/http.asthra,922,auto_type,MEDIUM,Auto type annotation should be explicit type,let encoded_value: auto = url_encode(field.value);,let encoded_value: <explicit_type> = url_encode(field.value);
stdlib/http.asthra,934,auto_type,MEDIUM,Auto type annotation should be explicit type,let bytes: auto = str::to_bytes(input);,let bytes: <explicit_type> = str::to_bytes(input);
stdlib/http.asthra,938,auto_type,MEDIUM,Auto type annotation should be explicit type,let byte: auto = bytes[i];,let byte: <explicit_type> = bytes[i];
stdlib/http.asthra,958,auto_type,MEDIUM,Auto type annotation should be explicit type,let high: auto = (byte >> 4) & 0x0F;,let high: <explicit_type> = (byte >> 4) & 0x0F;
stdlib/http.asthra,959,auto_type,MEDIUM,Auto type annotation should be explicit type,let low: auto = byte & 0x0F;,let low: <explicit_type> = byte & 0x0F;
stdlib/http.asthra,984,auto_type,MEDIUM,Auto type annotation should be explicit type,"let method_str: auto = str::to_cstr(""DELETE"");","let method_str: <explicit_type> = str::to_cstr(""DELETE"");"
stdlib/http.asthra,993,auto_type,MEDIUM,Auto type annotation should be explicit type,"let method_str: auto = str::to_cstr(""OPTIONS"");","let method_str: <explicit_type> = str::to_cstr(""OPTIONS"");"
stdlib/http.asthra,998,auto_type,MEDIUM,Auto type annotation should be explicit type,"let method_str: auto = str::to_cstr(""PATCH"");","let method_str: <explicit_type> = str::to_cstr(""PATCH"");"
stdlib/http.asthra,1019,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = headers[i];,let header: <explicit_type> = headers[i];
stdlib/http.asthra,1020,auto_type,MEDIUM,Auto type annotation should be explicit type,"let header_string: auto = header.name + "": "" + header.value;","let header_string: <explicit_type> = header.name + "": "" + header.value;"
stdlib/http.asthra,1021,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_cstr: auto = str::to_cstr(header_string);,let header_cstr: <explicit_type> = str::to_cstr(header_string);
stdlib/http.asthra,1112,auto_type,MEDIUM,Auto type annotation should be explicit type,let validation_result: auto = validate_utf8(self.body);,let validation_result: <explicit_type> = validate_utf8(self.body);
stdlib/http.asthra,1135,auto_type,MEDIUM,Auto type annotation should be explicit type,"let content_length_str_result: auto = self.get_header(""Content-Length"");","let content_length_str_result: <explicit_type> = self.get_header(""Content-Length"");"
stdlib/http.asthra,1138,auto_type,MEDIUM,Auto type annotation should be explicit type,let parse_result: auto = str::parse_usize(length_str);,let parse_result: <explicit_type> = str::parse_usize(length_str);
stdlib/io.asthra,35,empty_params,HIGH,Function with empty parameter list should use (none),"fn read_line() -> Result<string, IOError> {","fn read_line(none) -> Result<string, IOError> {"
stdlib/io.asthra,71,empty_params,HIGH,Function with empty parameter list should use (none),"fn read_char() -> Result<char, IOError> {","fn read_char(none) -> Result<char, IOError> {"
stdlib/io.asthra,98,empty_params,HIGH,Function with empty parameter list should use (none),"fn read_all() -> Result<string, IOError> {","fn read_all(none) -> Result<string, IOError> {"
stdlib/io.asthra,222,empty_params,HIGH,Function with empty parameter list should use (none),"fn flush_stdout() -> Result<void, IOError> {","fn flush_stdout(none) -> Result<void, IOError> {"
stdlib/io.asthra,299,empty_params,HIGH,Function with empty parameter list should use (none),"fn flush_stderr() -> Result<void, IOError> {","fn flush_stderr(none) -> Result<void, IOError> {"
stdlib/io.asthra,319,empty_params,HIGH,Function with empty parameter list should use (none),fn c_stdin() -> *mut void {,fn c_stdin(none) -> *mut void {
stdlib/io.asthra,320,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_stdin() -> *mut void;","extern ""asthra_runtime"" fn asthra_get_stdin(none) -> *mut void;"
stdlib/io.asthra,328,empty_params,HIGH,Function with empty parameter list should use (none),fn c_stdout() -> *mut void {,fn c_stdout(none) -> *mut void {
stdlib/io.asthra,329,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_stdout() -> *mut void;","extern ""asthra_runtime"" fn asthra_get_stdout(none) -> *mut void;"
stdlib/io.asthra,337,empty_params,HIGH,Function with empty parameter list should use (none),fn c_stderr() -> *mut void {,fn c_stderr(none) -> *mut void {
stdlib/io.asthra,338,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_stderr() -> *mut void;","extern ""asthra_runtime"" fn asthra_get_stderr(none) -> *mut void;"
stdlib/json.asthra,109,empty_params,HIGH,Function with empty parameter list should use (none),fn default_config() -> JSONConfig {,fn default_config(none) -> JSONConfig {
stdlib/json.asthra,121,empty_params,HIGH,Function with empty parameter list should use (none),fn default_serialize_config() -> JSONSerializeConfig {,fn default_serialize_config(none) -> JSONSerializeConfig {
stdlib/datetime/time.asthra,190,empty_params,HIGH,Function with empty parameter list should use (none),fn instant_now() -> Instant {,fn instant_now(none) -> Instant {
stdlib/datetime/time.asthra,257,empty_params,HIGH,Function with empty parameter list should use (none),fn system_time_now() -> SystemTime {,fn system_time_now(none) -> SystemTime {
stdlib/ffi/error.asthra,22,empty_params,HIGH,Function with empty parameter list should use (none),fn from_errno() -> FFIError;,fn from_errno(none) -> FFIError;
stdlib/examples/collections_comprehensive.asthra,15,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_enhanced_vectors() -> void {,fn demonstrate_enhanced_vectors(none) -> void {
stdlib/examples/collections_comprehensive.asthra,19,auto_type,MEDIUM,Auto type annotation should be explicit type,let config: auto = collections::VecConfig {;,let config: <explicit_type> = collections::VecConfig {;
stdlib/examples/collections_comprehensive.asthra,29,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = collections::vec_push(&mut custom_vec, 42);","let push_result: <explicit_type> = collections::vec_push(&mut custom_vec, 42);"
stdlib/examples/collections_comprehensive.asthra,44,auto_type,MEDIUM,Auto type annotation should be explicit type,let vec_from_slice_result: auto = collections::vec_from_slice(initial_data);,let vec_from_slice_result: <explicit_type> = collections::vec_from_slice(initial_data);
stdlib/examples/collections_comprehensive.asthra,50,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = collections::vec_insert(&mut vec, 2, 99);","let insert_result: <explicit_type> = collections::vec_insert(&mut vec, 2, 99);"
stdlib/examples/collections_comprehensive.asthra,60,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = collections::vec_remove(&mut vec, 1);","let remove_result: <explicit_type> = collections::vec_remove(&mut vec, 1);"
stdlib/examples/collections_comprehensive.asthra,72,auto_type,MEDIUM,Auto type annotation should be explicit type,"let swap_remove_result: auto = collections::vec_swap_remove(&mut vec, 0);","let swap_remove_result: <explicit_type> = collections::vec_swap_remove(&mut vec, 0);"
stdlib/examples/collections_comprehensive.asthra,83,auto_type,MEDIUM,Auto type annotation should be explicit type,"let find_result: auto = collections::vec_find(&vec, &search_value);","let find_result: <explicit_type> = collections::vec_find(&vec, &search_value);"
stdlib/examples/collections_comprehensive.asthra,96,auto_type,MEDIUM,Auto type annotation should be explicit type,let extend_vec_result: auto = collections::vec_from_slice(extension_data);,let extend_vec_result: <explicit_type> = collections::vec_from_slice(extension_data);
stdlib/examples/collections_comprehensive.asthra,99,auto_type,MEDIUM,Auto type annotation should be explicit type,"let extend_result: auto = collections::vec_extend(&mut vec, &extend_vec);","let extend_result: <explicit_type> = collections::vec_extend(&mut vec, &extend_vec);"
stdlib/examples/collections_comprehensive.asthra,111,auto_type,MEDIUM,Auto type annotation should be explicit type,let shrink_result: auto = collections::vec_shrink_to_fit(&mut vec);,let shrink_result: <explicit_type> = collections::vec_shrink_to_fit(&mut vec);
stdlib/examples/collections_comprehensive.asthra,134,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_hash_sets() -> void {,fn demonstrate_hash_sets(none) -> void {
stdlib/examples/collections_comprehensive.asthra,144,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = collections::hashset_insert(&mut set, items[i]);","let insert_result: <explicit_type> = collections::hashset_insert(&mut set, items[i]);"
stdlib/examples/collections_comprehensive.asthra,161,auto_type,MEDIUM,Auto type annotation should be explicit type,"let duplicate_result: auto = collections::hashset_insert(&mut set, ""apple"");","let duplicate_result: <explicit_type> = collections::hashset_insert(&mut set, ""apple"");"
stdlib/examples/collections_comprehensive.asthra,186,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = collections::hashset_remove(&mut set, &""banana"");","let remove_result: <explicit_type> = collections::hashset_remove(&mut set, &""banana"");"
stdlib/examples/collections_comprehensive.asthra,202,auto_type,MEDIUM,Auto type annotation should be explicit type,let set_from_slice_result: auto = collections::hashset_from_slice(fruit_array);,let set_from_slice_result: <explicit_type> = collections::hashset_from_slice(fruit_array);
stdlib/examples/collections_comprehensive.asthra,208,auto_type,MEDIUM,Auto type annotation should be explicit type,"let union_result: auto = collections::hashset_union(&mut set, &fruit_set);","let union_result: <explicit_type> = collections::hashset_union(&mut set, &fruit_set);"
stdlib/examples/collections_comprehensive.asthra,230,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_enhanced_hashmaps() -> void {,fn demonstrate_enhanced_hashmaps(none) -> void {
stdlib/examples/collections_comprehensive.asthra,246,auto_type,MEDIUM,Auto type annotation should be explicit type,let pair: auto = insert_pairs[i];,let pair: <explicit_type> = insert_pairs[i];
stdlib/examples/collections_comprehensive.asthra,247,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = collections::hashmap_insert(&mut map, pair.key, pair.value);","let insert_result: <explicit_type> = collections::hashmap_insert(&mut map, pair.key, pair.value);"
stdlib/examples/collections_comprehensive.asthra,269,auto_type,MEDIUM,Auto type annotation should be explicit type,"let get_result: auto = collections::hashmap_get(&map, &""score"");","let get_result: <explicit_type> = collections::hashmap_get(&map, &""score"");"
stdlib/examples/collections_comprehensive.asthra,281,auto_type,MEDIUM,Auto type annotation should be explicit type,"let get_or_insert_result: auto = collections::hashmap_get_or_insert(&mut map, ""health"", default_health);","let get_or_insert_result: <explicit_type> = collections::hashmap_get_or_insert(&mut map, ""health"", default_health);"
stdlib/examples/collections_comprehensive.asthra,292,auto_type,MEDIUM,Auto type annotation should be explicit type,"let update_result: auto = collections::hashmap_insert(&mut map, ""score"", 150);","let update_result: <explicit_type> = collections::hashmap_insert(&mut map, ""score"", 150);"
stdlib/examples/collections_comprehensive.asthra,313,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = collections::hashmap_remove(&mut map, &""lives"");","let remove_result: <explicit_type> = collections::hashmap_remove(&mut map, &""lives"");"
stdlib/examples/collections_comprehensive.asthra,334,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_enhanced_linked_lists() -> void {,fn demonstrate_enhanced_linked_lists(none) -> void {
stdlib/examples/collections_comprehensive.asthra,339,auto_type,MEDIUM,Auto type annotation should be explicit type,let list_result: auto = collections::list_from_slice(initial_data);,let list_result: <explicit_type> = collections::list_from_slice(initial_data);
stdlib/examples/collections_comprehensive.asthra,345,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = collections::list_insert(&mut list, 2, ""inserted"");","let insert_result: <explicit_type> = collections::list_insert(&mut list, 2, ""inserted"");"
stdlib/examples/collections_comprehensive.asthra,358,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = collections::list_remove_at(&mut list, 1);","let remove_result: <explicit_type> = collections::list_remove_at(&mut list, 1);"
stdlib/examples/collections_comprehensive.asthra,371,auto_type,MEDIUM,Auto type annotation should be explicit type,"let find_result: auto = collections::list_find(&list, &search_value);","let find_result: <explicit_type> = collections::list_find(&list, &search_value);"
stdlib/examples/collections_comprehensive.asthra,390,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_front_result: auto = collections::list_push_front(&mut list, ""new_first"");","let push_front_result: <explicit_type> = collections::list_push_front(&mut list, ""new_first"");"
stdlib/examples/collections_comprehensive.asthra,396,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_back_result: auto = collections::list_push_back(&mut list, ""new_last"");","let push_back_result: <explicit_type> = collections::list_push_back(&mut list, ""new_last"");"
stdlib/examples/collections_comprehensive.asthra,405,auto_type,MEDIUM,Auto type annotation should be explicit type,let pop_front_result: auto = collections::list_pop_front(&mut list);,let pop_front_result: <explicit_type> = collections::list_pop_front(&mut list);
stdlib/examples/collections_comprehensive.asthra,411,auto_type,MEDIUM,Auto type annotation should be explicit type,let pop_back_result: auto = collections::list_pop_back(&mut list);,let pop_back_result: <explicit_type> = collections::list_pop_back(&mut list);
stdlib/examples/collections_comprehensive.asthra,427,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_collection_conversions() -> void {,fn demonstrate_collection_conversions(none) -> void {
stdlib/examples/collections_comprehensive.asthra,432,auto_type,MEDIUM,Auto type annotation should be explicit type,let vec_result: auto = collections::vec_from_slice(vector_data);,let vec_result: <explicit_type> = collections::vec_from_slice(vector_data);
stdlib/examples/collections_comprehensive.asthra,438,auto_type,MEDIUM,Auto type annotation should be explicit type,let list_result: auto = collections::vec_to_list(&vec);,let list_result: <explicit_type> = collections::vec_to_list(&vec);
stdlib/examples/collections_comprehensive.asthra,444,auto_type,MEDIUM,Auto type annotation should be explicit type,let vec2_result: auto = collections::list_to_vec(&list);,let vec2_result: <explicit_type> = collections::list_to_vec(&list);
stdlib/examples/collections_comprehensive.asthra,450,auto_type,MEDIUM,Auto type annotation should be explicit type,let slice: auto = collections::vec_as_slice(&vec2);,let slice: <explicit_type> = collections::vec_as_slice(&vec2);
stdlib/examples/collections_comprehensive.asthra,473,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_performance_features() -> void {,fn demonstrate_performance_features(none) -> void {
stdlib/examples/collections_comprehensive.asthra,477,auto_type,MEDIUM,Auto type annotation should be explicit type,let performance_config: auto = collections::VecConfig {;,let performance_config: <explicit_type> = collections::VecConfig {;
stdlib/examples/collections_comprehensive.asthra,489,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = collections::vec_push(&mut perf_vec, i as i32);","let push_result: <explicit_type> = collections::vec_push(&mut perf_vec, i as i32);"
stdlib/examples/collections_comprehensive.asthra,504,auto_type,MEDIUM,Auto type annotation should be explicit type,let pop_result: auto = collections::vec_pop(&mut perf_vec);,let pop_result: <explicit_type> = collections::vec_pop(&mut perf_vec);
stdlib/examples/collections_comprehensive.asthra,517,auto_type,MEDIUM,Auto type annotation should be explicit type,let shrink_result: auto = collections::vec_shrink_to_fit(&mut perf_vec);,let shrink_result: <explicit_type> = collections::vec_shrink_to_fit(&mut perf_vec);
stdlib/examples/collections_comprehensive.asthra,527,auto_type,MEDIUM,Auto type annotation should be explicit type,"let reserve_result: auto = collections::vec_reserve(&mut perf_vec, 50);","let reserve_result: <explicit_type> = collections::vec_reserve(&mut perf_vec, 50);"
stdlib/examples/collections_comprehensive.asthra,542,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_error_handling() -> void {,fn demonstrate_error_handling(none) -> void {
stdlib/examples/collections_comprehensive.asthra,549,auto_type,MEDIUM,Auto type annotation should be explicit type,"let get_result: auto = collections::vec_get(&test_vec, 0);","let get_result: <explicit_type> = collections::vec_get(&test_vec, 0);"
stdlib/examples/collections_comprehensive.asthra,569,auto_type,MEDIUM,Auto type annotation should be explicit type,let pop_result: auto = collections::vec_pop(&mut test_vec);,let pop_result: <explicit_type> = collections::vec_pop(&mut test_vec);
stdlib/examples/collections_comprehensive.asthra,587,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
stdlib/examples/comprehensive_example.asthra,19,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
stdlib/examples/comprehensive_example.asthra,60,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_core() -> void {,fn demonstrate_core(none) -> void {
stdlib/examples/comprehensive_example.asthra,103,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_environment() -> void {,fn demonstrate_environment(none) -> void {
stdlib/examples/comprehensive_example.asthra,155,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_strings() -> void {,fn demonstrate_strings(none) -> void {
stdlib/examples/comprehensive_example.asthra,222,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_collections() -> void {,fn demonstrate_collections(none) -> void {
stdlib/examples/comprehensive_example.asthra,303,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_filesystem() -> void {,fn demonstrate_filesystem(none) -> void {
stdlib/examples/comprehensive_example.asthra,403,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_debugging() -> void {,fn demonstrate_debugging(none) -> void {
stdlib/examples/comprehensive_example.asthra,435,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_time() -> void {,fn demonstrate_time(none) -> void {
stdlib/examples/comprehensive_example.asthra,493,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_math() -> void {,fn demonstrate_math(none) -> void {
stdlib/examples/comprehensive_example.asthra,559,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_random() -> void {,fn demonstrate_random(none) -> void {
stdlib/examples/fs_example.asthra,10,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
stdlib/examples/fs_example.asthra,14,auto_type,MEDIUM,Auto type annotation should be explicit type,let basic_result: auto = demonstrate_basic_file_operations();,let basic_result: <explicit_type> = demonstrate_basic_file_operations();
stdlib/examples/fs_example.asthra,20,auto_type,MEDIUM,Auto type annotation should be explicit type,let error_msg: auto = fs.handle_fs_error(error);,let error_msg: <explicit_type> = fs.handle_fs_error(error);
stdlib/examples/fs_example.asthra,27,auto_type,MEDIUM,Auto type annotation should be explicit type,let advanced_result: auto = demonstrate_advanced_file_handling();,let advanced_result: <explicit_type> = demonstrate_advanced_file_handling();
stdlib/examples/fs_example.asthra,33,auto_type,MEDIUM,Auto type annotation should be explicit type,let error_msg: auto = fs.handle_fs_error(error);,let error_msg: <explicit_type> = fs.handle_fs_error(error);
stdlib/examples/fs_example.asthra,40,auto_type,MEDIUM,Auto type annotation should be explicit type,let directory_result: auto = demonstrate_directory_operations();,let directory_result: <explicit_type> = demonstrate_directory_operations();
stdlib/examples/fs_example.asthra,46,auto_type,MEDIUM,Auto type annotation should be explicit type,let error_msg: auto = fs.handle_fs_error(error);,let error_msg: <explicit_type> = fs.handle_fs_error(error);
stdlib/examples/fs_example.asthra,60,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_basic_file_operations() -> Result<void, fs.FSError> {","fn demonstrate_basic_file_operations(none) -> Result<void, fs.FSError> {"
stdlib/examples/fs_example.asthra,92,auto_type,MEDIUM,Auto type annotation should be explicit type,let copy_options: auto = fs.CopyOptions {;,let copy_options: <explicit_type> = fs.CopyOptions {;
stdlib/examples/fs_example.asthra,100,auto_type,MEDIUM,Auto type annotation should be explicit type,"let copy_result: auto = fs.copy_with_options(""test_basic.txt"", ""test_basic_copy.txt"", copy_options);","let copy_result: <explicit_type> = fs.copy_with_options(""test_basic.txt"", ""test_basic_copy.txt"", copy_options);"
stdlib/examples/fs_example.asthra,126,auto_type,MEDIUM,Auto type annotation should be explicit type,"let append_result: auto = fs.append_string(""test_basic.txt"", ""\nAppended line"");","let append_result: <explicit_type> = fs.append_string(""test_basic.txt"", ""\nAppended line"");"
stdlib/examples/fs_example.asthra,151,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_advanced_file_handling() -> Result<void, fs.FSError> {","fn demonstrate_advanced_file_handling(none) -> Result<void, fs.FSError> {"
stdlib/examples/fs_example.asthra,155,auto_type,MEDIUM,Auto type annotation should be explicit type,let open_options: auto = fs.OpenOptions {;,let open_options: <explicit_type> = fs.OpenOptions {;
stdlib/examples/fs_example.asthra,165,auto_type,MEDIUM,Auto type annotation should be explicit type,"let file_result: auto = fs.open_with_options(""test_advanced.txt"", open_options);","let file_result: <explicit_type> = fs.open_with_options(""test_advanced.txt"", open_options);"
stdlib/examples/fs_example.asthra,199,auto_type,MEDIUM,Auto type annotation should be explicit type,let seek_result: auto = file.seek(fs.SeekFrom.Start(0));,let seek_result: <explicit_type> = file.seek(fs.SeekFrom.Start(0));
stdlib/examples/fs_example.asthra,215,auto_type,MEDIUM,Auto type annotation should be explicit type,"let lines: auto = content.split(""\n"");","let lines: <explicit_type> = content.split(""\n"");"
stdlib/examples/fs_example.asthra,229,auto_type,MEDIUM,Auto type annotation should be explicit type,let close_result: auto = file.close();,let close_result: <explicit_type> = file.close();
stdlib/examples/fs_example.asthra,299,empty_params,HIGH,Function with empty parameter list should use (none),"fn demonstrate_directory_operations() -> Result<void, fs.FSError> {","fn demonstrate_directory_operations(none) -> Result<void, fs.FSError> {"
stdlib/examples/fs_example.asthra,333,auto_type,MEDIUM,Auto type annotation should be explicit type,"let entries_result: auto = fs.read_dir(""test_dir"");","let entries_result: <explicit_type> = fs.read_dir(""test_dir"");"
stdlib/examples/fs_example.asthra,338,auto_type,MEDIUM,Auto type annotation should be explicit type,let type_str: auto = format_file_type(entry.file_type);,let type_str: <explicit_type> = format_file_type(entry.file_type);
stdlib/examples/fs_example.asthra,348,auto_type,MEDIUM,Auto type annotation should be explicit type,let dir_options: auto = fs.DirOptions {;,let dir_options: <explicit_type> = fs.DirOptions {;
stdlib/examples/fs_example.asthra,356,auto_type,MEDIUM,Auto type annotation should be explicit type,"let iterator_result: auto = fs.read_dir_with_options(""test_dir"", dir_options);","let iterator_result: <explicit_type> = fs.read_dir_with_options(""test_dir"", dir_options);"
stdlib/examples/fs_example.asthra,362,auto_type,MEDIUM,Auto type annotation should be explicit type,let entry_result: auto = iterator.next();,let entry_result: <explicit_type> = iterator.next();
stdlib/examples/fs_example.asthra,365,auto_type,MEDIUM,Auto type annotation should be explicit type,let type_str: auto = format_file_type(entry.file_type);,let type_str: <explicit_type> = format_file_type(entry.file_type);
stdlib/examples/fs_example.asthra,366,auto_type,MEDIUM,Auto type annotation should be explicit type,"let relative_path: auto = entry.path.replace(""test_dir/"", """");","let relative_path: <explicit_type> = entry.path.replace(""test_dir/"", """");"
stdlib/examples/fs_example.asthra,421,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_error_handling_patterns() -> void {,fn demonstrate_error_handling_patterns(none) -> void {
stdlib/examples/fs_example.asthra,446,auto_type,MEDIUM,Auto type annotation should be explicit type,"let dir_result: auto = fs.create_dir(""test_file.txt"");","let dir_result: <explicit_type> = fs.create_dir(""test_file.txt"");"
stdlib/examples/fs_example.asthra,460,auto_type,MEDIUM,Auto type annotation should be explicit type,"let safe_result: auto = safe_file_operation(""test_file.txt"", fn(file: fs.File) -> Result<string, fs.FSError> {;","let safe_result: <explicit_type> = safe_file_operation(""test_file.txt"", fn(file: fs.File) -> Result<string, fs.FSError> {;"
stdlib/examples/fs_example.asthra,484,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = operation(file);,let result: <explicit_type> = operation(file);
stdlib/examples/fs_example.asthra,487,auto_type,MEDIUM,Auto type annotation should be explicit type,let close_result: auto = file.close();,let close_result: <explicit_type> = file.close();
stdlib/examples/io_example.asthra,9,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
stdlib/examples/io_example.asthra,218,empty_params,HIGH,Function with empty parameter list should use (none),fn demonstrate_error_handling() -> void {,fn demonstrate_error_handling(none) -> void {
stdlib/examples/http_example.asthra,11,empty_params,HIGH,Function with empty parameter list should use (none),fn main() -> i32 {,fn main(none) -> i32 {
stdlib/examples/http_example.asthra,45,empty_params,HIGH,Function with empty parameter list should use (none),fn example_simple_get() -> void {,fn example_simple_get(none) -> void {
stdlib/examples/http_example.asthra,58,auto_type,MEDIUM,Auto type annotation should be explicit type,let body_result: auto = response.body_as_string();,let body_result: <explicit_type> = response.body_as_string();
stdlib/examples/http_example.asthra,75,empty_params,HIGH,Function with empty parameter list should use (none),fn example_get_with_headers() -> void {,fn example_get_with_headers(none) -> void {
stdlib/examples/http_example.asthra,78,auto_type,MEDIUM,Auto type annotation should be explicit type,let client: auto = http::HTTPClient::new();,let client: <explicit_type> = http::HTTPClient::new();
stdlib/examples/http_example.asthra,88,auto_type,MEDIUM,Auto type annotation should be explicit type,"let response_result: auto = client.get_with_headers(url, headers);","let response_result: <explicit_type> = client.get_with_headers(url, headers);"
stdlib/examples/http_example.asthra,96,auto_type,MEDIUM,Auto type annotation should be explicit type,let content_type_result: auto = response.content_type();,let content_type_result: <explicit_type> = response.content_type();
stdlib/examples/http_example.asthra,113,empty_params,HIGH,Function with empty parameter list should use (none),fn example_post_json() -> void {,fn example_post_json(none) -> void {
stdlib/examples/http_example.asthra,119,auto_type,MEDIUM,Auto type annotation should be explicit type,"let response_result: auto = http::post_json(url, json_data);","let response_result: <explicit_type> = http::post_json(url, json_data);"
stdlib/examples/http_example.asthra,135,auto_type,MEDIUM,Auto type annotation should be explicit type,"let server_result: auto = response.get_header(""Server"");","let server_result: <explicit_type> = response.get_header(""Server"");"
stdlib/examples/http_example.asthra,148,empty_params,HIGH,Function with empty parameter list should use (none),fn example_post_form() -> void {,fn example_post_form(none) -> void {
stdlib/examples/http_example.asthra,160,auto_type,MEDIUM,Auto type annotation should be explicit type,"let response_result: auto = http::post_form(url, form_data);","let response_result: <explicit_type> = http::post_form(url, form_data);"
stdlib/examples/http_example.asthra,176,empty_params,HIGH,Function with empty parameter list should use (none),fn example_put_request() -> void {,fn example_put_request(none) -> void {
stdlib/examples/http_example.asthra,181,auto_type,MEDIUM,Auto type annotation should be explicit type,let data_bytes: auto = str::to_bytes(data);,let data_bytes: <explicit_type> = str::to_bytes(data);
stdlib/examples/http_example.asthra,184,auto_type,MEDIUM,Auto type annotation should be explicit type,"let response_result: auto = http::put(url, data_bytes, content_type);","let response_result: <explicit_type> = http::put(url, data_bytes, content_type);"
stdlib/examples/http_example.asthra,192,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_length_result: auto = response.content_length_header();,let header_length_result: <explicit_type> = response.content_length_header();
stdlib/examples/http_example.asthra,214,empty_params,HIGH,Function with empty parameter list should use (none),fn example_delete_request() -> void {,fn example_delete_request(none) -> void {
stdlib/examples/http_example.asthra,219,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_result: auto = http::delete(url);,let response_result: <explicit_type> = http::delete(url);
stdlib/examples/http_example.asthra,230,auto_type,MEDIUM,Auto type annotation should be explicit type,let header: auto = response.headers[i];,let header: <explicit_type> = response.headers[i];
stdlib/examples/http_example.asthra,242,empty_params,HIGH,Function with empty parameter list should use (none),fn example_custom_client() -> void {,fn example_custom_client(none) -> void {
stdlib/examples/http_example.asthra,246,auto_type,MEDIUM,Auto type annotation should be explicit type,let client_result: auto = http::HTTPClient::with_config(;,let client_result: <explicit_type> = http::HTTPClient::with_config(;
stdlib/examples/http_example.asthra,258,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_result: auto = client.get(url);,let response_result: <explicit_type> = client.get(url);
stdlib/examples/http_example.asthra,269,auto_type,MEDIUM,Auto type annotation should be explicit type,"let location_result: auto = response.get_header(""Location"");","let location_result: <explicit_type> = response.get_header(""Location"");"
stdlib/examples/http_example.asthra,292,empty_params,HIGH,Function with empty parameter list should use (none),fn example_error_handling() -> void {,fn example_error_handling(none) -> void {
stdlib/examples/http_example.asthra,299,auto_type,MEDIUM,Auto type annotation should be explicit type,"let invalid_url_result: auto = http::get(""not-a-valid-url"");","let invalid_url_result: <explicit_type> = http::get(""not-a-valid-url"");"
stdlib/examples/http_example.asthra,307,auto_type,MEDIUM,Auto type annotation should be explicit type,"let nonexistent_result: auto = http::get(""https://this-domain-definitely-does-not-exist-12345.com"");","let nonexistent_result: <explicit_type> = http::get(""https://this-domain-definitely-does-not-exist-12345.com"");"
stdlib/examples/http_example.asthra,315,auto_type,MEDIUM,Auto type annotation should be explicit type,"let not_found_result: auto = http::get(""https://httpbin.org/status/404"");","let not_found_result: <explicit_type> = http::get(""https://httpbin.org/status/404"");"
stdlib/examples/http_example.asthra,328,auto_type,MEDIUM,Auto type annotation should be explicit type,"let server_error_result: auto = http::get(""https://httpbin.org/status/500"");","let server_error_result: <explicit_type> = http::get(""https://httpbin.org/status/500"");"
stdlib/examples/http_example.asthra,341,empty_params,HIGH,Function with empty parameter list should use (none),fn example_response_processing() -> void {,fn example_response_processing(none) -> void {
stdlib/examples/http_example.asthra,345,auto_type,MEDIUM,Auto type annotation should be explicit type,let response_result: auto = http::get(url);,let response_result: <explicit_type> = http::get(url);
stdlib/examples/http_example.asthra,363,auto_type,MEDIUM,Auto type annotation should be explicit type,let body_result: auto = response.body_as_string();,let body_result: <explicit_type> = response.body_as_string();
stdlib/examples/http_example.asthra,370,auto_type,MEDIUM,Auto type annotation should be explicit type,let preview_length: auto = if str::len(body) > 500 { 500 } else { str::len(body) };,let preview_length: <explicit_type> = if str::len(body) > 500 { 500 } else { str::len(body) };
stdlib/examples/http_example.asthra,371,auto_type,MEDIUM,Auto type annotation should be explicit type,"let preview: auto = str::substring(body, 0, preview_length);","let preview: <explicit_type> = str::substring(body, 0, preview_length);"
stdlib/examples/http_example.asthra,416,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_name: auto = common_headers[i];,let header_name: <explicit_type> = common_headers[i];
stdlib/examples/http_example.asthra,417,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_result: auto = response.get_header(header_name);,let header_result: <explicit_type> = response.get_header(header_name);
stdlib/examples/http_example.asthra,453,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_name: auto = security_headers[i];,let header_name: <explicit_type> = security_headers[i];
stdlib/examples/http_example.asthra,454,auto_type,MEDIUM,Auto type annotation should be explicit type,let header_result: auto = response.get_header(header_name);,let header_result: <explicit_type> = response.get_header(header_name);
stdlib/examples/http_example.asthra,483,auto_type,MEDIUM,Auto type annotation should be explicit type,let print_result: auto = io::print_line(message);,let print_result: <explicit_type> = io::print_line(message);
stdlib/concurrent/coordination.asthra,55,empty_params,HIGH,Function with empty parameter list should use (none),pub fn new() -> SelectBuilder<T> {,pub fn new(none) -> SelectBuilder<T> {
stdlib/concurrent/patterns.asthra,121,auto_type,MEDIUM,Auto type annotation should be explicit type,let task_channel_result: auto = channel::<Task>(100);,let task_channel_result: <explicit_type> = channel::<Task>(100);
stdlib/concurrent/patterns.asthra,122,auto_type,MEDIUM,Auto type annotation should be explicit type,let task_channel: auto = match task_channel_result {;,let task_channel: <explicit_type> = match task_channel_result {;
stdlib/concurrent/patterns.asthra,126,auto_type,MEDIUM,Auto type annotation should be explicit type,"let result_channel_result: auto = channel::<Result<*mut void, string>>(100);","let result_channel_result: <explicit_type> = channel::<Result<*mut void, string>>(100);"
stdlib/concurrent/patterns.asthra,127,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_channel: auto = match result_channel_result {;,let result_channel: <explicit_type> = match result_channel_result {;
stdlib/concurrent/patterns.asthra,131,auto_type,MEDIUM,Auto type annotation should be explicit type,let shutdown_signal_result: auto = channel::<()>(worker_count);,let shutdown_signal_result: <explicit_type> = channel::<()>(worker_count);
stdlib/concurrent/patterns.asthra,132,auto_type,MEDIUM,Auto type annotation should be explicit type,let shutdown_signal: auto = match shutdown_signal_result {;,let shutdown_signal: <explicit_type> = match shutdown_signal_result {;
stdlib/concurrent/patterns.asthra,137,auto_type,MEDIUM,Auto type annotation should be explicit type,let pool: auto = WorkerPool {;,let pool: <explicit_type> = WorkerPool {;
stdlib/concurrent/patterns.asthra,148,auto_type,MEDIUM,Auto type annotation should be explicit type,let task_ch: auto = pool.task_channel.clone();,let task_ch: <explicit_type> = pool.task_channel.clone();
stdlib/concurrent/patterns.asthra,149,auto_type,MEDIUM,Auto type annotation should be explicit type,let result_ch: auto = pool.result_channel.clone();,let result_ch: <explicit_type> = pool.result_channel.clone();
stdlib/concurrent/patterns.asthra,150,auto_type,MEDIUM,Auto type annotation should be explicit type,let shutdown_ch: auto = pool.shutdown_signal.clone();,let shutdown_ch: <explicit_type> = pool.shutdown_signal.clone();
stdlib/concurrent/patterns.asthra,174,auto_type,MEDIUM,Auto type annotation should be explicit type,let task_id: auto = self.next_task_id;,let task_id: <explicit_type> = self.next_task_id;
stdlib/concurrent/patterns.asthra,177,auto_type,MEDIUM,Auto type annotation should be explicit type,"let task_with_id: auto = Task::new(task.execute_fn, task.cleanup_fn, task.data, task_id);","let task_with_id: <explicit_type> = Task::new(task.execute_fn, task.cleanup_fn, task.data, task_id);"
stdlib/concurrent/patterns.asthra,282,auto_type,MEDIUM,Auto type annotation should be explicit type,let result: auto = task.execute();,let result: <explicit_type> = task.execute();
stdlib/concurrent/patterns.asthra,316,auto_type,MEDIUM,Auto type annotation should be explicit type,"let func: auto = data as fn() -> Result<*mut void, string>;","let func: <explicit_type> = data as fn() -> Result<*mut void, string>;"
stdlib/concurrent/patterns.asthra,335,empty_params,HIGH,Function with empty parameter list should use (none),extern fn get_current_time_ms() -> u64;,extern fn get_current_time_ms(none) -> u64;
stdlib/concurrent/patterns.asthra,363,auto_type,MEDIUM,Auto type annotation should be explicit type,let semaphore_result: auto = create_semaphore(max_rate);,let semaphore_result: <explicit_type> = create_semaphore(max_rate);
stdlib/concurrent/patterns.asthra,364,auto_type,MEDIUM,Auto type annotation should be explicit type,let semaphore: auto = match semaphore_result {;,let semaphore: <explicit_type> = match semaphore_result {;
stdlib/concurrent/patterns.asthra,384,auto_type,MEDIUM,Auto type annotation should be explicit type,let current_time: auto = get_current_time_ms();,let current_time: <explicit_type> = get_current_time_ms();
stdlib/concurrent/patterns.asthra,385,auto_type,MEDIUM,Auto type annotation should be explicit type,let elapsed_seconds: auto = (current_time - self.last_refill) / 1000;,let elapsed_seconds: <explicit_type> = (current_time - self.last_refill) / 1000;
stdlib/concurrent/patterns.asthra,388,auto_type,MEDIUM,Auto type annotation should be explicit type,let permits_to_add: auto = elapsed_seconds * (self.refill_rate as u64);,let permits_to_add: <explicit_type> = elapsed_seconds * (self.refill_rate as u64);
stdlib/concurrent/patterns.asthra,418,empty_params,HIGH,Function with empty parameter list should use (none),"* fn worker_pool_example() -> Result<(), string> {","* fn worker_pool_example(none) -> Result<(), string> {"
stdlib/concurrent/patterns.asthra,482,empty_params,HIGH,Function with empty parameter list should use (none),"* fn rate_limiter_example() -> Result<(), string> {","* fn rate_limiter_example(none) -> Result<(), string> {"
stdlib/concurrent/channels.asthra,227,auto_type,MEDIUM,Auto type annotation should be explicit type,let channel: auto = match channel_result {;,let channel: <explicit_type> = match channel_result {;
stdlib/concurrent/channels.asthra,344,empty_params,HIGH,Function with empty parameter list should use (none),"* fn producer_consumer_example() -> Result<(), string> {","* fn producer_consumer_example(none) -> Result<(), string> {"
stdlib/asthra/collections_enhanced.asthra,51,empty_params,HIGH,Function with empty parameter list should use (none),fn vec_default_config() -> VecConfig {,fn vec_default_config(none) -> VecConfig {
stdlib/asthra/collections_enhanced.asthra,62,auto_type,MEDIUM,Auto type annotation should be explicit type,let config: auto = vec_default_config();,let config: <explicit_type> = vec_default_config();
stdlib/asthra/collections_enhanced.asthra,109,auto_type,MEDIUM,Auto type annotation should be explicit type,let vec_result: auto = vec_with_capacity(slice.len);,let vec_result: <explicit_type> = vec_with_capacity(slice.len);
stdlib/asthra/collections_enhanced.asthra,114,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = vec_push(&mut vec, slice[i]);","let push_result: <explicit_type> = vec_push(&mut vec, slice[i]);"
stdlib/asthra/collections_enhanced.asthra,131,auto_type,MEDIUM,Auto type annotation should be explicit type,let grow_result: auto = vec_grow(vec);,let grow_result: <explicit_type> = vec_grow(vec);
stdlib/asthra/collections_enhanced.asthra,155,auto_type,MEDIUM,Auto type annotation should be explicit type,let grow_result: auto = vec_grow(vec);,let grow_result: <explicit_type> = vec_grow(vec);
stdlib/asthra/collections_enhanced.asthra,252,auto_type,MEDIUM,Auto type annotation should be explicit type,"let find_result: auto = vec_find(vec, item);","let find_result: <explicit_type> = vec_find(vec, item);"
stdlib/asthra/collections_enhanced.asthra,262,auto_type,MEDIUM,Auto type annotation should be explicit type,let required_capacity: auto = (*dest).length + (*src).length;,let required_capacity: <explicit_type> = (*dest).length + (*src).length;
stdlib/asthra/collections_enhanced.asthra,264,auto_type,MEDIUM,Auto type annotation should be explicit type,"let reserve_result: auto = vec_reserve(dest, (*src).length);","let reserve_result: <explicit_type> = vec_reserve(dest, (*src).length);"
stdlib/asthra/collections_enhanced.asthra,274,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = vec_push(dest, *src_ptr);","let push_result: <explicit_type> = vec_push(dest, *src_ptr);"
stdlib/asthra/collections_enhanced.asthra,300,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_size: auto = (*vec).length * (*vec).element_size;,let new_size: <explicit_type> = (*vec).length * (*vec).element_size;
stdlib/asthra/collections_enhanced.asthra,301,auto_type,MEDIUM,Auto type annotation should be explicit type,let realloc_result: auto = core.realloc(;,let realloc_result: <explicit_type> = core.realloc(;
stdlib/asthra/collections_enhanced.asthra,326,auto_type,MEDIUM,Auto type annotation should be explicit type,let load_factor: auto = (*vec).length as f64 / (*vec).capacity as f64;,let load_factor: <explicit_type> = (*vec).length as f64 / (*vec).capacity as f64;
stdlib/asthra/collections_enhanced.asthra,328,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_capacity: auto = (*vec).capacity / 2;,let new_capacity: <explicit_type> = (*vec).capacity / 2;
stdlib/asthra/collections_enhanced.asthra,330,auto_type,MEDIUM,Auto type annotation should be explicit type,"let _: auto = vec_resize(vec, new_capacity);","let _: <explicit_type> = vec_resize(vec, new_capacity);"
stdlib/asthra/collections_enhanced.asthra,339,auto_type,MEDIUM,Auto type annotation should be explicit type,let required_capacity: auto = (*vec).length + additional;,let required_capacity: <explicit_type> = (*vec).length + additional;
stdlib/asthra/collections_enhanced.asthra,361,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_size: auto = new_capacity * (*vec).element_size;,let new_size: <explicit_type> = new_capacity * (*vec).element_size;
stdlib/asthra/collections_enhanced.asthra,363,auto_type,MEDIUM,Auto type annotation should be explicit type,let realloc_result: auto = core.realloc(;,let realloc_result: <explicit_type> = core.realloc(;
stdlib/asthra/collections_enhanced.asthra,385,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_capacity: auto = if (*vec).capacity == 0 { ;,let new_capacity: <explicit_type> = if (*vec).capacity == 0 { ;
stdlib/asthra/collections_enhanced.asthra,426,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashset_insert(&mut set, slice[i]);","let insert_result: <explicit_type> = hashset_insert(&mut set, slice[i]);"
stdlib/asthra/collections_enhanced.asthra,440,auto_type,MEDIUM,Auto type annotation should be explicit type,"let was_present: auto = hashset_contains(set, &item);","let was_present: <explicit_type> = hashset_contains(set, &item);"
stdlib/asthra/collections_enhanced.asthra,442,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashmap_insert(&mut (*set).map, item, true);","let insert_result: <explicit_type> = hashmap_insert(&mut (*set).map, item, true);"
stdlib/asthra/collections_enhanced.asthra,460,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = hashmap_remove(&mut (*set).map, item);","let remove_result: <explicit_type> = hashmap_remove(&mut (*set).map, item);"
stdlib/asthra/collections_enhanced.asthra,506,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = (*src).map.buckets + bucket_index;,let bucket: <explicit_type> = (*src).map.buckets + bucket_index;
stdlib/asthra/collections_enhanced.asthra,513,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashset_insert(dest, (*current).key);","let insert_result: <explicit_type> = hashset_insert(dest, (*current).key);"
stdlib/asthra/collections_enhanced.asthra,539,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = (*dest).map.buckets + bucket_index;,let bucket: <explicit_type> = (*dest).map.buckets + bucket_index;
stdlib/asthra/collections_enhanced.asthra,547,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashset_insert(&mut temp_set, (*current).key);","let insert_result: <explicit_type> = hashset_insert(&mut temp_set, (*current).key);"
stdlib/asthra/collections_enhanced.asthra,569,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = temp_set.map.buckets + bucket_index;,let bucket: <explicit_type> = temp_set.map.buckets + bucket_index;
stdlib/asthra/collections_enhanced.asthra,574,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashset_insert(dest, (*current).key);","let insert_result: <explicit_type> = hashset_insert(dest, (*current).key);"
stdlib/asthra/collections_enhanced.asthra,604,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = (*dest).map.buckets + bucket_index;,let bucket: <explicit_type> = (*dest).map.buckets + bucket_index;
stdlib/asthra/collections_enhanced.asthra,612,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = vec_push(&mut keys_to_remove, (*current).key);","let push_result: <explicit_type> = vec_push(&mut keys_to_remove, (*current).key);"
stdlib/asthra/collections_enhanced.asthra,631,auto_type,MEDIUM,Auto type annotation should be explicit type,"let key_ptr_result: auto = vec_get(&keys_to_remove, i);","let key_ptr_result: <explicit_type> = vec_get(&keys_to_remove, i);"
stdlib/asthra/collections_enhanced.asthra,634,auto_type,MEDIUM,Auto type annotation should be explicit type,"let remove_result: auto = hashset_remove(dest, key_ptr);","let remove_result: <explicit_type> = hashset_remove(dest, key_ptr);"
stdlib/asthra/collections_enhanced.asthra,681,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket_count: auto = if capacity < 16 { 16 } else { next_power_of_two(capacity) };,let bucket_count: <explicit_type> = if capacity < 16 { 16 } else { next_power_of_two(capacity) };
stdlib/asthra/collections_enhanced.asthra,682,auto_type,MEDIUM,Auto type annotation should be explicit type,"let bucket_size: auto = sizeof::<HashBucket<K, V>>();","let bucket_size: <explicit_type> = sizeof::<HashBucket<K, V>>();"
stdlib/asthra/collections_enhanced.asthra,683,auto_type,MEDIUM,Auto type annotation should be explicit type,let total_size: auto = bucket_count * bucket_size;,let total_size: <explicit_type> = bucket_count * bucket_size;
stdlib/asthra/collections_enhanced.asthra,685,auto_type,MEDIUM,Auto type annotation should be explicit type,"let buckets_result: auto = core.alloc(total_size, core.MemoryZone.GC);","let buckets_result: <explicit_type> = core.alloc(total_size, core.MemoryZone.GC);"
stdlib/asthra/collections_enhanced.asthra,688,auto_type,MEDIUM,Auto type annotation should be explicit type,"let buckets: auto = ptr as *mut HashBucket<K, V>;","let buckets: <explicit_type> = ptr as *mut HashBucket<K, V>;"
stdlib/asthra/collections_enhanced.asthra,694,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = buckets + i;,let bucket: <explicit_type> = buckets + i;
stdlib/asthra/collections_enhanced.asthra,735,auto_type,MEDIUM,Auto type annotation should be explicit type,"let resize_result: auto = hashmap_resize(map, (*map).bucket_count * 2);","let resize_result: <explicit_type> = hashmap_resize(map, (*map).bucket_count * 2);"
stdlib/asthra/collections_enhanced.asthra,742,auto_type,MEDIUM,Auto type annotation should be explicit type,"let hash: auto = hash_key_with_seed(&key, (*map).hash_seed);","let hash: <explicit_type> = hash_key_with_seed(&key, (*map).hash_seed);"
stdlib/asthra/collections_enhanced.asthra,743,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket_index: auto = hash % (*map).bucket_count;,let bucket_index: <explicit_type> = hash % (*map).bucket_count;
stdlib/asthra/collections_enhanced.asthra,744,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = (*map).buckets + bucket_index;,let bucket: <explicit_type> = (*map).buckets + bucket_index;
stdlib/asthra/collections_enhanced.asthra,750,auto_type,MEDIUM,Auto type annotation should be explicit type,let old_value: auto = (*current).value;,let old_value: <explicit_type> = (*current).value;
stdlib/asthra/collections_enhanced.asthra,766,auto_type,MEDIUM,Auto type annotation should be explicit type,"let new_bucket_result: auto = core.alloc(sizeof::<HashBucket<K, V>>(), core.MemoryZone.GC);","let new_bucket_result: <explicit_type> = core.alloc(sizeof::<HashBucket<K, V>>(), core.MemoryZone.GC);"
stdlib/asthra/collections_enhanced.asthra,769,auto_type,MEDIUM,Auto type annotation should be explicit type,"let new_bucket: auto = ptr as *mut HashBucket<K, V>;","let new_bucket: <explicit_type> = ptr as *mut HashBucket<K, V>;"
stdlib/asthra/collections_enhanced.asthra,793,auto_type,MEDIUM,Auto type annotation should be explicit type,"let get_result: auto = hashmap_get(map, &key);","let get_result: <explicit_type> = hashmap_get(map, &key);"
stdlib/asthra/collections_enhanced.asthra,797,auto_type,MEDIUM,Auto type annotation should be explicit type,"let insert_result: auto = hashmap_insert(map, key, default_value);","let insert_result: <explicit_type> = hashmap_insert(map, key, default_value);"
stdlib/asthra/collections_enhanced.asthra,801,auto_type,MEDIUM,Auto type annotation should be explicit type,"let get_result2: auto = hashmap_get(map, &key);","let get_result2: <explicit_type> = hashmap_get(map, &key);"
stdlib/asthra/collections_enhanced.asthra,816,auto_type,MEDIUM,Auto type annotation should be explicit type,let old_buckets: auto = (*map).buckets;,let old_buckets: <explicit_type> = (*map).buckets;
stdlib/asthra/collections_enhanced.asthra,817,auto_type,MEDIUM,Auto type annotation should be explicit type,let old_bucket_count: auto = (*map).bucket_count;,let old_bucket_count: <explicit_type> = (*map).bucket_count;
stdlib/asthra/collections_enhanced.asthra,820,auto_type,MEDIUM,Auto type annotation should be explicit type,"let new_size: auto = new_bucket_count * sizeof::<HashBucket<K, V>>();","let new_size: <explicit_type> = new_bucket_count * sizeof::<HashBucket<K, V>>();"
stdlib/asthra/collections_enhanced.asthra,821,auto_type,MEDIUM,Auto type annotation should be explicit type,"let new_buckets_result: auto = core.alloc(new_size, core.MemoryZone.GC);","let new_buckets_result: <explicit_type> = core.alloc(new_size, core.MemoryZone.GC);"
stdlib/asthra/collections_enhanced.asthra,825,auto_type,MEDIUM,Auto type annotation should be explicit type,"let new_buckets: auto = ptr as *mut HashBucket<K, V>;","let new_buckets: <explicit_type> = ptr as *mut HashBucket<K, V>;"
stdlib/asthra/collections_enhanced.asthra,830,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = new_buckets + i;,let bucket: <explicit_type> = new_buckets + i;
stdlib/asthra/collections_enhanced.asthra,840,auto_type,MEDIUM,Auto type annotation should be explicit type,let old_size: auto = (*map).size;,let old_size: <explicit_type> = (*map).size;
stdlib/asthra/collections_enhanced.asthra,846,auto_type,MEDIUM,Auto type annotation should be explicit type,let old_bucket: auto = old_buckets + i;,let old_bucket: <explicit_type> = old_buckets + i;
stdlib/asthra/collections_enhanced.asthra,850,auto_type,MEDIUM,Auto type annotation should be explicit type,let next: auto = (*current).next;,let next: <explicit_type> = (*current).next;
stdlib/asthra/collections_enhanced.asthra,853,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_bucket_index: auto = (*current).hash_value % new_bucket_count;,let new_bucket_index: <explicit_type> = (*current).hash_value % new_bucket_count;
stdlib/asthra/collections_enhanced.asthra,854,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_bucket: auto = new_buckets + new_bucket_index;,let new_bucket: <explicit_type> = new_buckets + new_bucket_index;
stdlib/asthra/collections_enhanced.asthra,924,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = list_push_back(&mut list, slice[i]);","let push_result: <explicit_type> = list_push_back(&mut list, slice[i]);"
stdlib/asthra/collections_enhanced.asthra,959,auto_type,MEDIUM,Auto type annotation should be explicit type,"let node_result: auto = core.alloc(sizeof::<ListNode<T>>(), core.MemoryZone.GC);","let node_result: <explicit_type> = core.alloc(sizeof::<ListNode<T>>(), core.MemoryZone.GC);"
stdlib/asthra/collections_enhanced.asthra,962,auto_type,MEDIUM,Auto type annotation should be explicit type,let new_node: auto = ptr as *mut ListNode<T>;,let new_node: <explicit_type> = ptr as *mut ListNode<T>;
stdlib/asthra/collections_enhanced.asthra,1005,auto_type,MEDIUM,Auto type annotation should be explicit type,let data: auto = (*current).data;,let data: <explicit_type> = (*current).data;
stdlib/asthra/collections_enhanced.asthra,1041,auto_type,MEDIUM,Auto type annotation should be explicit type,"let find_result: auto = list_find(list, item);","let find_result: <explicit_type> = list_find(list, item);"
stdlib/asthra/collections_enhanced.asthra,1066,empty_params,HIGH,Function with empty parameter list should use (none),fn generate_hash_seed() -> u64 {,fn generate_hash_seed(none) -> u64 {
stdlib/asthra/collections_enhanced.asthra,1067,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_random_u64() -> u64;","extern ""asthra_runtime"" fn asthra_random_u64(none) -> u64;"
stdlib/asthra/collections_enhanced.asthra,1120,auto_type,MEDIUM,Auto type annotation should be explicit type,let vec_result: auto = vec_with_capacity(list_len(list));,let vec_result: <explicit_type> = vec_with_capacity(list_len(list));
stdlib/asthra/collections_enhanced.asthra,1126,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = vec_push(&mut vec, (*current).data);","let push_result: <explicit_type> = vec_push(&mut vec, (*current).data);"
stdlib/asthra/collections_enhanced.asthra,1147,auto_type,MEDIUM,Auto type annotation should be explicit type,let element_ptr: auto = (*vec).data + i;,let element_ptr: <explicit_type> = (*vec).data + i;
stdlib/asthra/collections_enhanced.asthra,1148,auto_type,MEDIUM,Auto type annotation should be explicit type,"let push_result: auto = list_push_back(&mut list, *element_ptr);","let push_result: <explicit_type> = list_push_back(&mut list, *element_ptr);"
stdlib/asthra/collections_enhanced.asthra,1172,auto_type,MEDIUM,Auto type annotation should be explicit type,let slice: auto = vec_as_slice(vec);,let slice: <explicit_type> = vec_as_slice(vec);
stdlib/asthra/collections_enhanced.asthra,1183,auto_type,MEDIUM,Auto type annotation should be explicit type,let slice: auto = vec_as_slice(vec);,let slice: <explicit_type> = vec_as_slice(vec);
stdlib/asthra/collections_enhanced.asthra,1213,auto_type,MEDIUM,Auto type annotation should be explicit type,let bucket: auto = (*map).buckets + i;,let bucket: <explicit_type> = (*map).buckets + i;
stdlib/asthra/collections_enhanced.asthra,1217,auto_type,MEDIUM,Auto type annotation should be explicit type,let next: auto = (*current).next;,let next: <explicit_type> = (*current).next;
stdlib/asthra/collections_enhanced.asthra,1239,auto_type,MEDIUM,Auto type annotation should be explicit type,let next: auto = (*current).next;,let next: <explicit_type> = (*current).next;
stdlib/asthra/panic.asthra,75,empty_params,HIGH,Function with empty parameter list should use (none),"fn take_panic_hook() -> Result<PanicHook, string> {","fn take_panic_hook(none) -> Result<PanicHook, string> {"
stdlib/asthra/panic.asthra,76,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_take_panic_hook() -> *mut void;","extern ""asthra_runtime"" fn asthra_take_panic_hook(none) -> *mut void;"
stdlib/asthra/panic.asthra,92,empty_params,HIGH,Function with empty parameter list should use (none),fn capture_backtrace() -> []StackFrame {,fn capture_backtrace(none) -> []StackFrame {
stdlib/asthra/panic.asthra,93,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_capture_backtrace() -> CStackTrace;","extern ""asthra_runtime"" fn asthra_capture_backtrace(none) -> CStackTrace;"
stdlib/asthra/panic.asthra,120,empty_params,HIGH,Function with empty parameter list should use (none),fn print_backtrace() -> void {,fn print_backtrace(none) -> void {
stdlib/asthra/panic.asthra,152,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_is_debug_build() -> i32;","extern ""asthra_runtime"" fn asthra_is_debug_build(none) -> i32;"
stdlib/asthra/panic.asthra,192,empty_params,HIGH,Function with empty parameter list should use (none),fn is_debug() -> bool {,fn is_debug(none) -> bool {
stdlib/asthra/panic.asthra,193,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_is_debug_build() -> i32;","extern ""asthra_runtime"" fn asthra_is_debug_build(none) -> i32;"
stdlib/asthra/panic.asthra,201,empty_params,HIGH,Function with empty parameter list should use (none),fn breakpoint() -> void {,fn breakpoint(none) -> void {
stdlib/asthra/panic.asthra,202,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_breakpoint() -> void;","extern ""asthra_runtime"" fn asthra_breakpoint(none) -> void;"
stdlib/asthra/error.asthra,152,auto_type,MEDIUM,Auto type annotation should be explicit type,let context_str: auto = self.contexts[0];,let context_str: <explicit_type> = self.contexts[0];
stdlib/asthra/random.asthra,25,empty_params,HIGH,Function with empty parameter list should use (none),fn rng_new() -> Rng {,fn rng_new(none) -> Rng {
stdlib/asthra/random.asthra,150,empty_params,HIGH,Function with empty parameter list should use (none),"fn secure_rng_new() -> Result<SecureRng, string> {","fn secure_rng_new(none) -> Result<SecureRng, string> {"
stdlib/asthra/random.asthra,217,empty_params,HIGH,Function with empty parameter list should use (none),fn init_global_rng() -> void {,fn init_global_rng(none) -> void {
stdlib/asthra/random.asthra,227,empty_params,HIGH,Function with empty parameter list should use (none),fn random_u32() -> u32 {,fn random_u32(none) -> u32 {
stdlib/asthra/random.asthra,234,empty_params,HIGH,Function with empty parameter list should use (none),fn random_u64() -> u64 {,fn random_u64(none) -> u64 {
stdlib/asthra/random.asthra,241,empty_params,HIGH,Function with empty parameter list should use (none),fn random_f64() -> f64 {,fn random_f64(none) -> f64 {
stdlib/asthra/random.asthra,248,empty_params,HIGH,Function with empty parameter list should use (none),fn random_f32() -> f32 {,fn random_f32(none) -> f32 {
stdlib/asthra/random.asthra,276,empty_params,HIGH,Function with empty parameter list should use (none),fn random_bool() -> bool {,fn random_bool(none) -> bool {
stdlib/asthra/random.asthra,293,empty_params,HIGH,Function with empty parameter list should use (none),"fn secure_random_u32() -> Result<u32, string> {","fn secure_random_u32(none) -> Result<u32, string> {"
stdlib/asthra/random.asthra,298,empty_params,HIGH,Function with empty parameter list should use (none),"fn secure_random_u64() -> Result<u64, string> {","fn secure_random_u64(none) -> Result<u64, string> {"
stdlib/asthra/random.asthra,565,empty_params,HIGH,Function with empty parameter list should use (none),fn get_entropy_seed() -> u64 {,fn get_entropy_seed(none) -> u64 {
stdlib/asthra/env.asthra,64,empty_params,HIGH,Function with empty parameter list should use (none),fn env_vars() -> []EnvVar {,fn env_vars(none) -> []EnvVar {
stdlib/asthra/env.asthra,65,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn environ() -> **const u8;","extern ""libc"" fn environ(none) -> **const u8;"
stdlib/asthra/env.asthra,102,empty_params,HIGH,Function with empty parameter list should use (none),"fn current_dir() -> Result<string, fs.IOError> {","fn current_dir(none) -> Result<string, fs.IOError> {"
stdlib/asthra/env.asthra,137,empty_params,HIGH,Function with empty parameter list should use (none),"fn current_exe() -> Result<string, fs.IOError> {","fn current_exe(none) -> Result<string, fs.IOError> {"
stdlib/asthra/env.asthra,183,empty_params,HIGH,Function with empty parameter list should use (none),fn args() -> []string {,fn args(none) -> []string {
stdlib/asthra/env.asthra,184,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""asthra_runtime"" fn asthra_get_args() -> CStringArray;","extern ""asthra_runtime"" fn asthra_get_args(none) -> CStringArray;"
stdlib/asthra/env.asthra,206,empty_params,HIGH,Function with empty parameter list should use (none),"fn home_dir() -> Result<string, string> {","fn home_dir(none) -> Result<string, string> {"
stdlib/asthra/env.asthra,222,empty_params,HIGH,Function with empty parameter list should use (none),fn temp_dir() -> string {,fn temp_dir(none) -> string {
stdlib/asthra/env.asthra,243,empty_params,HIGH,Function with empty parameter list should use (none),"fn username() -> Result<string, string> {","fn username(none) -> Result<string, string> {"
stdlib/asthra/env.asthra,258,empty_params,HIGH,Function with empty parameter list should use (none),"fn hostname() -> Result<string, string> {","fn hostname(none) -> Result<string, string> {"
stdlib/asthra/env.asthra,286,empty_params,HIGH,Function with empty parameter list should use (none),fn is_windows() -> bool {,fn is_windows(none) -> bool {
stdlib/asthra/env.asthra,295,empty_params,HIGH,Function with empty parameter list should use (none),fn is_unix() -> bool {,fn is_unix(none) -> bool {
stdlib/asthra/env.asthra,300,empty_params,HIGH,Function with empty parameter list should use (none),fn os_name() -> string {,fn os_name(none) -> string {
stdlib/asthra/process.asthra,110,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn fork() -> i32;","extern ""libc"" fn fork(none) -> i32;"
stdlib/asthra/process.asthra,253,empty_params,HIGH,Function with empty parameter list should use (none),fn abort() -> ! {,fn abort(none) -> ! {
stdlib/asthra/process.asthra,254,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn abort() -> !;","extern ""libc"" fn abort(none) -> !;"
stdlib/asthra/process.asthra,261,empty_params,HIGH,Function with empty parameter list should use (none),fn id() -> u32 {,fn id(none) -> u32 {
stdlib/asthra/process.asthra,262,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn getpid() -> i32;","extern ""libc"" fn getpid(none) -> i32;"
stdlib/asthra/process.asthra,269,empty_params,HIGH,Function with empty parameter list should use (none),fn parent_id() -> u32 {,fn parent_id(none) -> u32 {
stdlib/asthra/process.asthra,270,empty_params,HIGH,Function with empty parameter list should use (none),"extern ""libc"" fn getppid() -> i32;","extern ""libc"" fn getppid(none) -> i32;"
